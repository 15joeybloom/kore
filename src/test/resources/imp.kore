/* This is the complete Kore definition of imp.k.
 * For comparison, K definitions are replicate
 * as comments, followed by the corresponding
 * Kore definitions. 
 */

[]

module BOOL

  sort Bool{} []

  symbol true{}() : Bool{} []

  symbol false{}() : Bool{} []

  symbol andBool{}(Bool{}, Bool{}) : Bool{} []

  symbol notBool{}(Bool{}) : Bool{} []

  /* TODO:: Complete these axioms. */

endmodule []

module INT

  import BOOL []

  sort Int{} []

  symbol zero{}() : Int{} []

  symbol succ{}(Int{}) : Int{} []

  symbol one{}() : Int{} []

  symbol two{}() : Int{} []

  symbol three{}() : Int{} []

  symbol plusInt{}(Int{}, Int{}) : Int{} []

  symbol minusInt{}(Int{}, Int{}) : Int{} []

  symbol divInt{}(Int{}, Int{}) : Int{} []

  symbol leqInt{}(Int{}, Int{}) : Bool{} []

  symbol neqInt{}(Int{}, Int{}) : Bool{} []

  /* TODO:: Complete these axioms. */

endmodule []

module LIST

  sort List{S} []

  symbol nil{S}() : List{S} []

  symbol cons{S}(S, List{S}) : List{S} []

  symbol append{S}(List{S}, List{S}) : List{S} []

  symbol listItem{S}(S) : List{S} []

  /* TODO:: Complete these axioms. */

endmodule []

module SET

  import BOOL []

  sort Set{S} []

  symbol emptySet{S}() : Set{S} []

  symbol union{S}(Set{S}, Set{S}) : Set{S} []

  symbol inSet{S}(S, Set{S}) : Bool{} []

  axiom{S,R}
    \equals{Set{S},R}(
      union{S}(S:Set{S}, emptySet{S}()),
      S:Set{S}) []

  /* TODO:: Complete these axioms. */

endmodule []

module MAP

  import SET []

  sort Map{S1,S2} []

  symbol bind{S1,S2}(S1,S2) : Map{S1,S2} []

  symbol emp{S1,S2}() : Map{S1,S2} []

  symbol merge{S1,S2}(Map{S1,S2}, Map{S1,S2}) : Map{S1,S2} []

  symbol keys{S1,S2}(Map{S1,S2}) : Set{S1} []

endmodule []

module ID

  import INT []

  sort Id{} []
  symbol id{}(Int{}) : Id{} []

endmodule []

module CONTEXT

  sort Ctxt{S1,S2} []

  symbol app{S1,S2}(Ctxt{S1,S2}, S1) : S2 []

  symbol gamma{S1,S2}(S1,S2) : Ctxt{S1,S2} []

  

  /* TODO:: Complete these axioms. */

endmodule []


/** The module of "~>" and "." in K.
  */
module ARROW

  sort K{} []

  /* The injection function from any sort S to K. */
  symbol inj{S}(S) : K{} []

  /* TODO:: add axiom : inj is injective */

  symbol arrow{}(K{}, K{}) : K{} []

  symbol nothing{}() : K{} []

endmodule []


module REWRITE

  import CONTEXT []

endmodule []

module IMP-SYNTAX

  import BOOL []

  import INT []

  import LIST []

  import SET []

  import MAP []

  import ID []

  import CONTEXT []

  import REWRITE []

  /* syntax AExp ::= ... */

  sort AExp{} []

  /* syntax AExp ::= Int */

  symbol intAsAExp{}(Int{}) : AExp{} []

  /* syntax AExp ::= Id */

  symbol idAsAExp{}(Id{}) : AExp{} []

  /* syntax AExp ::= "-" Int */

  symbol minusAExp{}(Int{}) : AExp{} []

  /* syntax AExp ::= AExp "/" AExp [strict] */

  symbol divAExp{}(AExp{}, AExp{}) : AExp{}
  [#strict{}("divAExp", one{}()) ,
   #strict{}("divAExp", two{}())]

  /* (X / Y) = gamma HOLE . (HOLE / Y) [X] */

  axiom{R}
    \equals{AExp{},R}(
      divAExp{}(X:AExp{}, Y:AExp{}),
      app{AExp{},AExp{}}(
        gamma{AExp{},AExp{}}(
          HOLE:AExp{},
          divAExp{}(HOLE:AExp{}, Y:AExp{})),
        X:AExp{}))
  [#strict{}("divAExp", one{}())]

  /* (X / Y) = gamma HOLE . (X / HOLE) [Y] */

  axiom{R}
    \equals{AExp{},R}(
      divAExp{}(X:AExp{}, Y:AExp{}),
      app{AExp{},AExp{}}(
        gamma{AExp{},AExp{}}(
          HOLE:AExp{},
          divAExp{}(X:AExp{}, HOLE:AExp{})),
        Y:AExp{}))
  [#strict{}("divAExp", two{}())]

  /* syntax AExp ::= AExp "+" AExp [strict] */

  symbol plusAExp{}(AExp{}, AExp{}) : AExp{}
  [#strict{}("plusAExp", one{}()) ,
   #strict{}("plusAExp", two{}())]

  /* (X + Y) = gamma HOLE . (HOLE + Y) [X] */

  axiom{R}
    \equals{AExp{},R}(
      plusAExp{}(X:AExp{}, Y:AExp{}),
      app{AExp{},AExp{}}(
        gamma{AExp{},AExp{}}(
          HOLE:AExp{},
          plusAExp{}(HOLE:AExp{}, Y:AExp{})),
        X:AExp{}))
  [#strict{}("plusAExp", one{}())]

  /* (X + Y) = gamma HOLE . (X + HOLE) [Y] */

  axiom{R}
    \equals{AExp{},R}(
      plusAExp{}(X:AExp{}, Y:AExp{}),
      app{AExp{},AExp{}}(
        gamma{AExp{},AExp{}}(
          HOLE:AExp{},
          plusAExp{}(X:AExp{}, HOLE:AExp{})),
        Y:AExp{}))
  [#strict{}("plusAExp", two{}())]

  /* syntax BExp ::= ... */

  sort BExp{} []

  /* syntax BExp ::= Bool */

  symbol boolAsBExp{}(Bool{}) : BExp{} []

  /* syntax BExp ::= AExp "<=" AExp [seqstrict] */

  symbol leqBExp{}(AExp{}, AExp{}) : BExp{}
  [#seqstrict{}("leqBExp")]

  axiom{R}
    \equals{BExp{},R}(
      leqBExp{}(X:AExp{}, Y:AExp{}),
      app{AExp{}, BExp{}}(
        gamma{AExp{}, BExp{}}(
          HOLE:AExp{},
          leqBExp{}(HOLE:AExp{}, Y:AExp{})),
        X:AExp{}))
  [#seqstrict{}("leqBExp")]

  /* X <= intAsAExp(Y) = (gamma HOLE . X <= intAsAExp(HOLE)) [Y] 
     where Y has sort Int.
     This is because Int is the only subsort of AExp that is a KResult.
     However, this information is not in the K module IMP-SYNTAX,
     but in the K module IMP.
   */

  axiom{R}
    \equals{BExp{},R}(
      leqBExp{}(X:AExp{}, intAsAExp{}(Y:Int{})),
      app{Int{}, BExp{}}(
        gamma{Int{}, BExp{}}(
          HOLE:Int{},
          leqBExp{}(X:AExp{}, intAsAExp{}(HOLE:Int{}))),
        Y:Int{}))
  [#seqstrict{}("leqBExp")]

  /* syntax BExp ::= "!" BExp [strict] */

  symbol notBExp{}(BExp{}) : BExp{}
  [#strict{}("notBExp", one{}())]
      
  axiom{R}
    \equals{BExp{},R}(
      notBExp{}(B:BExp{}),
      app{BExp{},BExp{}}(
        gamma{BExp{}, BExp{}}(
          HOLE:BExp{},
          notBExp{}(HOLE:BExp{})),
        B:BExp{}))
  [#strict{}("notBExp", one{}())]

  /* syntax BExp ::= BExp "&&" BExp [strict(1)] */

  symbol andBExp{}(BExp{}, BExp{}) : BExp{}
  [#strict{}("andBExp", one{}())]

  axiom{R}
    \equals{BExp{},R}(
      andBExp{}(X:BExp{}, Y:BExp{}),
      app{BExp{}, BExp{}}(
        gamma{BExp{}, BExp{}}(
          HOLE:BExp{},
          andBExp{}(HOLE:BExp{}, Y:BExp{})),
        X:BExp{}))
  [#strict{}("andBExp", one{}())]


  /* syntax Block ::= ... */

  sort Block{} []

  /* syntax Block ::= "{" "}" */

  symbol emptyBlock{}() : Block{} []

  /* syntax Block ::= "{" Stmt "}" */

  symbol block{}(Stmt{}) : Block{} []

  /* syntax Stmt ::= ... */

  sort Stmt{} []

  /* syntax Stmt ::= Block */

  symbol blockAsStmt{}(Block{}) : Stmt{} []

  /* syntax Stmt ::= Id "=" AExp ";" [strict(2)] */

  symbol asgn{}(Id{}, AExp{}) : Stmt{} [#strict{}("asgn", two{}())]

  axiom{R}
    \equals{Stmt{},R}(
      asgn{}(X:Id{}, E:AExp{}),
      app{AExp{},Stmt{}}(
        gamma{AExp{},Stmt{}}(
          HOLE:AExp{},
          asgn{}(X:Id{}, HOLE:AExp{})),
        E:AExp{}))
  [#strict{}("asgn", two{}())]

  /* syntax Stmt ::= "ite" "(" BExp ")" Block "else" Block [strict(1)] */

  symbol ite{}(BExp{}, Block{}, Block{}) : Stmt{}
  [#strict{}("ite", one{}())]

  axiom{R}
    \equals{Stmt{},R}(
      ite{}(B:BExp{}, S1:Block{}, S2:Block{}),
      app{BExp{},Stmt{}}(
        gamma{BExp{},Stmt{}}(
          HOLE:BExp{},
          ite{}(HOLE:BExp{}, S1:Block{}, S2:Block{})),
        B:BExp{}))
  [#strict{}("ite", one{}())]

  /* syntax Stmt ::= "while" "(" BExp ")" Block */

  symbol while{}(BExp{}, Block{}) : Stmt{} []

  /* syntax Stmt ::= Stmt Stmt */

  symbol seq{}(Stmt{}, Stmt{}) : Stmt{} []

  /* The symbol skip is not in imp.k. We introduced it here
   * to encode K rules that rewrite some computation
   * to "nothing". 
   * skip is the unit of seq.
   */

  symbol skip{}() : Stmt{} []

  /* syntax Pgm ::= ... */

  sort Pgm{} []

  /* syntax Pgm ::= "int" Ids ";" Stmt
     syntax Ids ::= List{Id, ","}
   */

  symbol pgm{}(List{Id{}}, Stmt{}) : Pgm{} []

endmodule []

module IMP

  import IMP-SYNTAX []

  /* syntax KResult ::= Int | Bool */

  /* KResult provides hints for applying heating and cooling rules.
     These hints are used when we translate seqstrict attributes
     to axioms in Kore.
     We don't need explicit axioms about KResult.
   */


  /* configuration <T> <k> $PGM:Pgm </k> <state> .Map </state> </T> */

  sort Configuration{} []

  symbol cfg{}(TopCell{}) : Configuration{} []

  sort TopCell{} []

  symbol topcell{}(KCell{}, StateCell{}) : TopCell{} []

  sort KCell{} []

  symbol kcell{}(Pgm{}) : KCell{} []

  sort StateCell{} []

  symbol statecell{}(Map{Id{}, Int{}}) : StateCell{} []


  /* In K:
   * rule <k> X:Id => I ... <k>
   *      <state> ... X |-> I ... </state>
   * 
   * In Kore (We need multi-hole contexts to write this rule.)
   * C[X:Id => I, X |-> I]
   */

  /* rule I1 / I2 => I1 /Int I2 requires I2 =/=Int 0 */

  axiom{S}
    \implies{S}(
      \equals{Bool{},S}(true{}(),
        neqInt{}(I2:Int{}, zero{}())),
      app{AExp{},S}(
        C:Ctxt{AExp{},S},
        \rewrites{AExp{}}(
          divAExp{}(intAsAExp{}(I1:Int{}), intAsAExp{}(I2:Int{})),
          intAsAExp{}(divInt{}(I1:Int{}, I2:Int{})))))
  []

  /* rule I1 + I2 => I1 +Int I2 */

  axiom{S}
    app{AExp{},S}(
      C:Ctxt{AExp{},S},
      \rewrites{AExp{}}(
        plusAExp{}(intAsAExp{}(I1:Int{}), intAsAExp{}(I2:Int{})),
        intAsAExp{}(plusInt{}(I1:Int{}, I2:Int{}))))
  []

  /* In K:
   *   rule -I1 => 0 -Int I1
   */ 

  axiom{S}
    app{AExp{},S}(
      C:Ctxt{AExp{},S},
      \rewrites{AExp{}}(
        minusAExp{}(I1:Int{}),
        intAsAExp{}(minusInt{}(zero{}(), I1:Int{}))))
  []

  /* In K:
   *   rule I1 <= I2 => I1 <=Int I2
   */

  axiom{S}
    app{BExp{},S}(
      C:Ctxt{BExp{},S},
      \rewrites{BExp{}}(
        leqBExp{}(intAsAExp{}(I1:Int{}), intAsAExp{}(I2:Int{})),
        boolAsBExp{}(leqInt{}(I1:Int{}, I2:Int{}))))
  []

  /* In K:
   *   rule ! T => notBool T
   */

  axiom{S}
    app{BExp{},S}(
      C:Ctxt{BExp{},S},
      \rewrites{BExp{}}(
        notBExp{}(boolAsBExp{}(T:Bool{})),
        boolAsBExp{}(notBool{}(T:Bool{}))))
  []

  /* rule true && B => B */

  axiom{S}
    app{BExp{},S}(
      C:Ctxt{BExp{},S},
      \rewrites{BExp{}}(
        andBExp{}(boolAsBExp{}(true{}()), B:BExp{}),
        B:BExp{}))
  []

  /* rule false && _ => false */
    
  axiom{S}
    app{BExp{},S}(
      C:Ctxt{BExp{},S},
      \rewrites{BExp{}}(
        andBExp{}(boolAsBExp{}(false{}()), UNDERSCORE:BExp{}),
        boolAsBExp{}(false{}())))
  []


  /* rule {} => . */

  // TODO

  /* rule {S} => S */

  axiom{S}
    app{Stmt{},S}(
      C:Ctxt{Stmt{},S},
      \rewrites{Stmt{}}(
        blockAsStmt{}(block{}(S:Stmt{})),
        S:Stmt{}))
  []

  /* rule <k> X = I:Int; => . ... </k>
          <state> ... X |-> (_ => I) ... </state>
   */

  /* rule S1:Stmt S2:Stmt => S1 ~> S2 */


  /* rule if (true) S else _ => S */

  /* rule if (false) _ else S => S */

  /* rule while (B) S => if (B) {S while (B) S} else {} */

  /* rule <k> int (X,Xs => Xs);_ </k>
          <state> Rho:Map (.Map => X |-> 0) </state>
     requires notBool (X in keys(Rho))
   */

  /* rule int .Ids; S => S */


endmodule []

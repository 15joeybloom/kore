\documentclass[UTF8,11pt]{article}

  % Package for using the full page.
  \usepackage{fullpage}
  
  % Package for writing algorithms (why do we need this one?).
  \usepackage[linesnumbered,ruled,vlined]{algorithm2e}

  
  \usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
  \usepackage{xargs}                      % Use more than one optional
                                          % parameter in a new commands

  % Select what to do with todonotes: 
  % \usepackage[disable]{todonotes} % notes not showed
  % \usepackage[draft]  {todonotes} % notes showed
  \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
  \newcommandx{\unsure}[2][1=]
    {\todo[linecolor=red,backgroundcolor=red!25,
    	   bordercolor=red,#1]
     {#2}\xspace{}}
  \newcommandx{\change}[2][1=]
    {\todo[linecolor=blue,backgroundcolor=blue!25,
    	   bordercolor=blue,#1]
     {#2}\xspace{}}
  \newcommandx{\info}[2][1=]
    {\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,
    	   bordercolor=OliveGreen,#1]
     {#2}}
  \newcommandx{\improvement}[2][1=]
    {\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]
     {#2}\xspace{}}
  \newcommandx{\thiswillnotshow}[2][1=]
    {\todo[disable,#1]
     {#2}\xspace{}}

  % Select what to do with command \comment:  
  % \newcommand{\comment}[1]
      {}                                    %comment not showed
  \newcommand{\comment}[1]
    {\par {\bfseries \color{blue} #1 \par}} %comment showed
  
  % Use AMS Math package.
  \usepackage{amsmath}
  \usepackage{amssymb}
  \usepackage{amsthm}
  
  % Declare a global counter for theorem environments:
  \newcounter{thmcounter}
  
  % Define new theorem styles and theorem environments.
  \theoremstyle{plain}
  
  \newtheorem{theorem}    [thmcounter]{Theorem}
  \newtheorem{corollary}  [thmcounter]{Corollary}
  \newtheorem{lemma}      [thmcounter]{Lemma}
  \newtheorem{proposition}[thmcounter]{Proposition}
  
  \theoremstyle{definition}
  
  \newtheorem{definition} [thmcounter]{Definition}
  \newtheorem{example}    [thmcounter]{Example}
  
  \theoremstyle{remark}
  
  \newtheorem{remark}     [thmcounter]{Remark}
  \newtheorem{notation}   [thmcounter]{Notation}
  
  
  % Package for changing fonts in the Verbatim environment:
  \usepackage{fancyvrb}
  
  % Package for writing captions for align environment:
  \usepackage{capt-of}
  
  % Package for URLs:
  \usepackage{hyperref}  
  
  % Package for tables:
  \usepackage[english]{babel}  
  
  % Define the colon ":" that is used in "x:s"
  % with less spacing around.
  \newcommand{\cln}{{:}}
 
  
  % Define ceiling and flooring symbols:
  \usepackage{mathtools}
  \DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
  \DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

  % Package for underlining and strikethrough texts.
  \usepackage[normalem]{ulem}
  
  % Package for display-mode quotations.
  \usepackage{csquotes}
  
  % Define double-bracket [[P]]
  \usepackage{stmaryrd}
  \newcommand{\Bracket}[1]{\llbracket#1\rrbracket}
    
  % Package for writing BNF syntax
  \usepackage{syntax}
  
  % Package for refering Section 3.1 as something like Section §3.1:
  \usepackage[utf8]{inputenc}
  \usepackage{cleveref}
  \crefname{section}{§}{§§}
  
  % Package for lstlisting and definition of Kore
  \usepackage{listings}
  % Define colors
  \definecolor{codegray}{rgb}{0.5,0.5,0.5}
  \definecolor{backgray}{RGB}{250,250,250}
  \definecolor{codegreen}{RGB}{50,205,50}
  \definecolor{codeblue}{RGB}{50,50,255}
  % Define Kore Language style
  \lstdefinelanguage{kore}
  {
  	% print whole listing small and in serif fonts
  	basicstyle=\ttfamily\footnotesize,
  	% use /* */ for comments
  	morecomment=[s]{/*}{*/},
  	% print white for comments
  	commentstyle=\color{codegray},
  	% print line number in the left, in tiny fonts
  	numbers=left,
  	numberstyle=\tiny,
  	% print all characters at their natural width
  	columns=fullflexible,
  	% print background color grey
  	backgroundcolor=\color{backgray},
  	% regard some characters as letters
  	alsoletter={-\\},
  	% list of declaration keywords
  	keywordstyle=[1]\color{codeblue},
  	morekeywords=[1]{
  		hooked-sort,
  		sort,
  		symbol,
  		hooked-symbol,
  		alias,
  		axiom
  	},
    % list of connectives
    keywordstyle=[2]\color{codegreen},
    morekeywords=[2]{
    	\\not,
    	\\or,
    	\\implies,
    	\\and,
    	\\equals,
    	\\exists,
    	\\forall,
    	\\iff
    }
  }

  % Define the curly K:
  \newcommand{\K}{\mbox{$\mathbb{K}$}\xspace}
  
  % Define commands that are used in Sec 2.  
  \newcommand{\Nat}{\textit{Nat}}
  \newcommand{\Int}{\textit{Int}}
  \newcommand{\Bool}{\textit{Bool}}
  \newcommand{\List}{\textit{List}}
  \newcommand{\nil}{\textit{nil}}
  \newcommand{\cons}{\textit{cons}}
  \newcommand{\append}{\textit{append}}
  \newcommand{\Bag}{\textit{Bag}}
  \newcommand{\Set}{\textit{Set}}
  \newcommand{\Map}{\textit{Map}}
  \newcommand{\parametric}[2]{{#1}\raisebox{.2ex}{\texttt{\footnotesize{\{}}}#2\raisebox{.2ex}{\texttt{\footnotesize{\}}}}}
  \newcommand{\parametricscript}[2]{{#1}\raisebox{.2ex}{\texttt{\tiny{\{}}}#2\raisebox{.2ex}{\texttt{\tiny{\}}}}}
  
  \newcommand{\Mod}{\textit{Mod}}
  \newcommand{\denote}[1]{\llbracket{#1}\rrbracket}
  \newcommand{\reduct}[2]{\mbox{${#1}\!\!\upharpoonright_{#2}$}}
  
  \newcommand{\builtin}{\textit{builtin}}
  
  % Define PATTERNS with ATTERNS are small capitals:
  \newcommand{\PATTERNS}{\text{P\textsc{atterns}}}
  
  % Define sorts and symbols in the calculus K.
  
  % Sec 3.1 Truth
  \newcommand{\KPred}{\mathit{KPred}}
  
  %% We shouldn't need the follows.
  \newcommand{\Ktrue}{\mathit{Ktrue}}
  \newcommand{\Kfalse}{\mathit{Kfalse}}
  \newcommand{\KandBool}{\mathit{KandBool}}
  \newcommand{\KorBool}{\mathit{KorBool}}
  \newcommand{\KnotBool}{\mathit{KnotBool}}
  \newcommand{\KimpliesBool}{\mathit{KimpliesBool}}
  
  % Sec 3.2 Strings
  \newcommand{\KChar}{\mathit{KChar}}
  \newcommand{\KCharList}{\mathit{KCharList}}
  \newcommand{\KString}{\mathit{KString}}
  \newcommand{\Kepsilon}{\mathit{Kepsilon}}
  \newcommand{\KconsKString}{\mathit{KconsKString}}
  
  %% We shouldn't need the follows.  
  \newcommand{\Kconcat}{\mathit{Kconcat}}
  
  % Sec 3.3 Sorts and Symbols
  \newcommand{\KSort}{\mathit{KSort}}
  \newcommand{\Ksort}{\mathit{Ksort}}
  \newcommand{\KSymbol}{\mathit{KSymbol}}
  \newcommand{\Ksymbol}{\mathit{Ksymbol}}
  \newcommand{\KgetArgumentSorts}{\mathit{KgetArgumentSorts}}
  \newcommand{\KgetReturnSort}{\mathit{KgetReturnSort}}
  
  % Sec 3.4 Finite Lists
  \newcommand{\XList}{\mathit{XList}}
  \newcommand{\KnilXList}{\mathit{KnilXList}}
  \newcommand{\KconsXList}{\mathit{KconsXList}}
  \newcommand{\KappendXList}{\mathit{KappendXList}}
  \newcommand{\KinXList}{\mathit{KinXList}}
  \newcommand{\KdeleteXList}{\mathit{KdeleteXList}}
  \newcommand{\KPatternList}{\mathit{KPatternList}}
  \newcommand{\KnilKPatternList}{\mathit{KnilKPatternList}}
  \newcommand{\KconsKPatternList}{\mathit{KconsKPatternList}}
  \newcommand{\KappendKPatternList}{\mathit{KappendKPatternList}}
  \newcommand{\KinKPatternList}{\mathit{KinKPatternList}}
  \newcommand{\KdeleteKPatternList}{\mathit{KdeleteKPatternList}}
  \newcommand{\KSortList}{\mathit{KSortList}}
  \newcommand{\KnilKSortList}{\mathit{KnilKSortList}}
  \newcommand{\KconsKSortList}{\mathit{KconsKSortList}}
  \newcommand{\KappendKSortList}{\mathit{KappendKSortList}}
  \newcommand{\KinKSortList}{\mathit{KinKSortList}}
  \newcommand{\KdeleteKSortList}{\mathit{KdeleteKSortList}}
  \newcommand{\KSymbolList}{\mathit{KSymbolList}}
  \newcommand{\KinKSymbolList}{\mathit{KinKSymbolList}}
  \newcommand{\KnilKCharList}{\mathit{KnilKCharList}}
  \newcommand{\KconsKCharList}{\mathit{KconsKCharList}}
  %% Define l1 @ l2 for list concatenation.
  \newcommand{\at}{@}
  
  
  \newcommand{\Kdelete}{\mathit{delete}} 


  
  
  \newcommand{\KPattern}{\mathit{KPattern}}
  \newcommand{\Kvariable}{\mathit{Kvariable}}
  \newcommand{\Kand}{\mathit{Kand}}
  \newcommand{\Kor}{\mathit{Kor}}
  \newcommand{\Kimplies}{\mathit{Kimplies}}
  \newcommand{\Kiff}{\mathit{Kiff}}
  \newcommand{\Knot}{\mathit{Knot}}
  \newcommand{\Kapplication}{\mathit{Kapplication}}
  \newcommand{\Kexists}{\mathit{Kexists}}
  \newcommand{\Kforall}{\mathit{Kforall}}
  \newcommand{\Kequals}{\mathit{Kequals}}
  \newcommand{\Kin}{\mathit{Kin}}
  \newcommand{\Kcontains}{\mathit{Kcontains}}
  \newcommand{\Ktop}{\mathit{Ktop}}
  \newcommand{\Kbottom}{\mathit{Kbottom}}
  \newcommand{\Kfloor}{\mathit{Kfloor}}
  \newcommand{\Kceil}{\mathit{Kceil}}
  
  \newcommand{\KgetFvs}{\mathit{KgetFvs}}
  \newcommand{\KgetFvsFromPatterns}{\mathit{KgetFvsFromPatterns}}
  \newcommand{\KfreshName}{\mathit{KfreshName}}
  
  \newcommand{\KSignature}{\mathit{KSignature}}
  \newcommand{\Ksignature}{\mathit{Ksignature}}
  \newcommand{\KgetSorts}{\mathit{KgetSorts}}
  \newcommand{\KgetSymbols}{\mathit{KgetSymbols}}
  \newcommand{\KsortDeclared}{\mathit{KsortDeclared}}
  \newcommand{\KsymbolDeclared}{\mathit{KsymbolDeclared}}
  
  \newcommand{\KwellFormed}{\mathit{KwellFormed}}
  \newcommand{\KwellFormedPatterns}{\mathit{KwellFormedPatterns}}
  \newcommand{\KMapReduceKwellFormed}{\mathit{KMapReduceKwellFormed}}
  \newcommand{\KgetSort}{\mathit{KgetSort}}
  \newcommand{\KgetSortsFromPatterns}{\mathit{KgetSortsFromPatterns}}
  \newcommand{\KisSort}{\mathit{KisSort}}
  \newcommand{\Ksubstitute}{\mathit{Ksubstitute}}
  \newcommand{\KsubstitutePatterns}{\mathit{KsubstitutePatterns}}
  
  \newcommand{\KTheory}{\mathit{KTheory}}
  \newcommand{\Ktheory}{\mathit{Ktheory}}
  \newcommand{\KwellFormedTheory}{\mathit{KwellFormedTheory}}
  
  \newcommand{\Kdeduce}{\mathit{Kdeduce}}
  
  % The italic font of "ceil" used in math mode.
  \newcommand{\cl}{\mathit{ceil}}
  
  % Use quotation marks "..." in math mode.
  \newcommand{\quot}[1]{\mathrm{``#1"}}



  % Title and authors
  \title{The Semantics of \K}
  \author{Formal Systems Laboratory \\
          University of Illinois at Urbana-Champaign}

\begin{document}

\maketitle

\info{Please feel free to contribute to this report in all ways.
You could add new contents, remove redundant ones, refactor and
organize the texts, and correct typos, but please follow the FSL
rules for editing, though; e.g., $<$80 characters per line,
each sentence on a new line, etc. }

\section{Introduction}
\label{sec:introduction}

\K is a best effort realization of matching logic~\cite{rosu-2017-lmcs}.
Matching logic allows us to mathematically define arbitrarily infinite
theories, which are not in general possible to describe finitely.
\K proposes a finitely describable subset of matching logic theories.
Since its inception in 2003 as a notation within
Maude~\cite{clavel-et-al99a} convenient for teaching programming
languages~\cite{rosu-2003-cs322}, until recently \K's semantics was explained
either by translation to rewriting logic \cite{meseguer-1992-tcs} or by
translation to some form of graph rewriting~\cite{serbanuta-rosu-2012-icgt}.
These translations not only added clutter and came at a loss of part of the
intended meaning of \K, but eventually turned out to be a serious limiting
factor in the types of theories and languages that could be defined.
Matching logic was specifically created and developed to serve as a
logical, semantic foundation for \K, after almost 15 years of experience
with using \K to define the formal semantics of real-life programming
languages, including
C~\cite{ellison-rosu-2012-popl,hathhorn-ellison-rosu-2015-pldi},
Java~\cite{bogdanas-rosu-2015-popl},
JavaScript~\cite{park-stefanescu-rosu-2015-pldi},
Python~\cite{guth-2013-thesis,pltredex-python},
PHP~\cite{k-php},
EVM~\cite{hiraidefining,hildenbrandt-saxena-zhu-rodrigues-daian-guth-rosu-2017-tr}.

Matching logic allows us to define \emph{theories} $(S,\Sigma,A)$ consisting
of potentially infinite sets of \emph{sorts} $S$, of \emph{symbols}
$\Sigma$ over sorts in $S$ (also called $S$-symbols), and of \emph{patterns}
$A$ built with symbols in $\Sigma$ (also called $\Sigma$-patterns),
respectively, and provides models that interpret the symbols
relationally, which in turn yield a \emph{semantic validity} relation
$(S,\Sigma,A)\models\varphi$ between theories $(S,\Sigma,A)$ and
$\Sigma$-patterns $\varphi$.
Matching logic also has a Hilbert-style complete proof system, which allows
us to derive new patterns $\varphi$ from given theories $(S,\Sigma,A)$,
written $(S,\Sigma,A)\vdash\varphi$.
When the sorts and signature are understood, we omit them; for example,
the completeness of matching logic then states that for any matching logic
theory $(S,\Sigma,A)$ and any $\Sigma$-pattern $\varphi$, we have
$A \models \varphi$ iff $A \vdash \varphi$.

...\improvement{Will add more here as we finalize the notation.
we need some convincing example.  Maybe parametric maps?}

\section{Matching Logic}
\label{sec:matching-logic}

\newcommand{\Var}{\textit{Var}}

In this section we first recall basic matching logic syntax and semantics
notions from~\cite{rosu-2017-lmcs} at a theoretical level.
\improvement{
We should make this paper self-contained in terms of definitions
and only refer to \cite{rosu-2017-lmcs} for details and proofs.
We want people who trust \cite{rosu-2017-lmcs} to not have to leave
this paper in order to understand the semantics of \K.
So we should define signatures, symbols, patterns, models,
satisfaction, proof system, etc.
}
Then we discuss schematic/parametric ways to finitely define infinite
matching logic theories.
Finally, we introduce theoretical foundations underlying the
notion of ``builtins''.

\subsection{Syntax}
\label{sec:ML-syntax}

Assume a matching logic \emph{signature} $(S, \Sigma)$, where $S$ is the
set of its \emph{sorts} $S$ and $\Sigma$ is the set of its \emph{symbols}.
When $S$ is understood, we write just $\Sigma$ for a signature instead of
$(S,\Sigma)$. 
For each sort $s \in S$, assume a set $\Var_s$ of \emph{variables} of
sort $s$.
We partition $\Sigma$ in sets $\Sigma_{s_1 \ldots s_n, s}$ of symbols
of \emph{arity} $s_1\ldots s_n,s$, where
$s_1,\ldots, s_n, s \in S$.
\emph{Patterns} of sort $s \in S$ are generated by the following grammar:
\begin{align*}
\varphi_s \Coloneqq\  &x \quad \text{where $x \in \Var_s$} 
\\
\mid\  &\sigma(\varphi_{s_1},...,\varphi_{s_n}) \quad\
\text{where $\sigma \in \Sigma_{s_1 \ldots s_n, s}$ and
$\varphi_{s_1},...,\varphi_{s_n}$ of appropriate sorts} \\
\mid\  &\varphi_s \wedge \varphi_s \\
\mid\  &\neg \varphi_s \\
\mid\  &\exists x \cln s' . \varphi_s \quad \text{where $x \in N$ and $s' \in S$}
\end{align*}
\begingroup\vspace*{-\baselineskip}
\captionof{figure}{The grammar of matching logic patterns.}
\label{ml-grammar}
\vspace*{\baselineskip}\endgroup

The grammar above only defines the syntax of (well-formed) patterns of sort
$s$.
It says nothing about their semantics.
For example, patterns $x\cln s \wedge y \cln s$ and
$y\cln s \wedge x \cln s$ are distinct elements in the language
of the grammar, in spite of them being semantically/provably equal
in matching logic.
Derived constructs like $\vee$, $\rightarrow$, $\leftrightarrow$,
$\forall$, etc., can be defined as aliases as usual; for example,
$\varphi_1 \vee \varphi_2 \equiv \neg(\neg \varphi_1 \wedge \neg\varphi_2)$.

For notational convenience, we take the liberty to use mix-fix syntax for
operators in $\Sigma$,
parentheses for grouping, and omit variable sorts when understood.
For example, if $\Nat \in S$ and
$\_+\_, \_*\_ \in \Sigma_{\Nat \times \Nat, \Nat}$
then we may write $(x + y)*z$ instead of
$\_*\_(\_+\_(x\cln\Nat,y\cln\Nat),z\cln\Nat)$.
More notational convenience and conventions will be introduced along the way
as we use them. 

A matching logic \emph{theory} is a triple $(S, \Sigma, A)$ where
$(S,\Sigma)$ is a signature and $A$ is a set of patterns called \emph{axioms}.
When $S$ is understood, we write $(\Sigma,A)$ instead of $(S,\Sigma,A)$.

...

\subsection{Semantics and Basic Properties}
\label{sec:semantics}

Models, satisfaction, some properties
\improvement{We should also add the semantics here: models, $M \models_{(S,\Sigma)} A$,
$(S,\Sigma,A) \models \varphi$.}

Let $(S,\Sigma)$ be a signature.

$\Mod(\Sigma)$

$M \models_{\Sigma} A$

$A \models_\Sigma \varphi$

$(\Sigma,A) \models \varphi$

$\Mod(\Sigma,A) =
\denote{(\Sigma,A)} =
\{M \ \mid \ M \in \Mod_{\Sigma},\ M \models_{\Sigma} A \}$

A signature $(S',\Sigma')$ is called a \emph{subsignature} of $(S,\Sigma)$, written
$(S',\Sigma') \hookrightarrow(S,\Sigma)$, if and only if $S' \subseteq S$ and
$\Sigma' \subseteq \Sigma$.
If $M \in \Mod(\Sigma)$ then we let
$\reduct{M}{\Sigma'} \in \Mod(\Sigma')$ denote its
\emph{$\Sigma'$-reduct}, or simply its \emph{reduct} when
$\Sigma'$ is understood, defined as follows: ...

We can think of signatures as interfaces and of models as
\emph{implementations}, or \emph{realizations}, of such interfaces.
Indeed, models provide concrete values for each sort, and concrete relations
for symbols.
Then the reduct $\reduct{M}{\Sigma'}$ can be regarded as a ``wrapper'' of
the implementation $M$ of $\Sigma$ turning it into an implementation of
$\Sigma'$, or a reuse of a richer implementation in a smaller context.

\subsection{Derived Symbols}

Definedness, membership, equality

\subsection{Sound and Complete Deduction}

Proof system, soundness and completeness

\subsection{Finite Mechanisms to Define Infinite Theories}

Note that all the theoretical results discussed so far imposed no finiteness
restrictions on the sets of sorts, symbols, or patterns that form a matching
logic theory.
In practice, however, like in many other logics or formalisms, we have to
limit ourselves to finitely describable theories.
The simplest approach to achieve that would be to require the theories to be
finite; however, like in many other logics and formalisms, such a requirement
would simply be too strong to be practical.
Instead, we have to adopt or develop conventions, mechanisms or languages that
allow us to describe potentially infinite theories using a finite amount of
resources (paper, space, characters, etc.).
For example, many logics allow \emph{axiom schemas} as a way to finitely
define infinite theories.

To prepare the ground for our proposal in Section~\ref{sec:syntax-of-kore},
we here discuss, informally, some ways to finitely describe infinite theories.
Let us start with sorts.
Suppose that we have a finite set of \emph{basic sorts}, e.g.,
$\Nat$, $\Int$, $\Bool$, etc.
Here are several \emph{sort schemas} that allow us to extend the set of sorts
with infinitely many new sorts:
$$
\begin{array}{rl}
\parametric{\List}{s} &
\textrm{for any sort $s$} \\
\parametric{\Set}{s} &
\textrm{for any sort $s$} \\
\parametric{\Bag}{s} &
\textrm{for any sort $s$} \\
\parametric{\Bag_p}{s} &
\textrm{for any sort $s$ which is not of the form $\parametric{\Bag_p}{\_}$} \\
\parametric{\Map}{s,s'} &
\textrm{for any sorts $s,s'$} \\
\parametric{\Map_p}{s,s'} &
\textrm{for any sorts $s,s'$ such that $s$ is not of the form $\parametric{\Map_p}{\_,\_}$}
\end{array}
$$

Here are several \emph{symbol schemas}, each adding now infinitely many symbols:

$$
\begin{array}{rl}
\parametric{\nil}{s} \in \Sigma_{*,\parametricscript{\List}{s}} &
\textrm{for any sort $s$} \\
\parametric{\cons}{s} \in \Sigma_{s\times\parametricscript{\List}{s},\parametricscript{\List}{s}} &
\textrm{for any sort $s$} \\
\parametric{\append}{s} \in \Sigma_{\parametricscript{\List}{s}\times\parametricscript{\List}{s},\parametricscript{\List}{s}} &
\textrm{for any sort $s$} \\
...
\end{array}
$$

Here are some \emph{pattern schemas}, each defining infinitely many patters:
$$
\begin{array}{rl}
\parametric{\append}{s}(\parametric{\nil}{s},l'\cln\parametric{\List}{s})
=_{\parametricscript{\List}{s}}^{s'} l'\cln\parametric{\List}{s}
& \textrm{for any sorts $s, s'$}
\\[2ex]
\begin{array}{@{}l@{}}
\parametric{\append}{s}(\parametric{\cons}{s}(x\cln s,l\cln\parametric{\List}{s}),l'\cln\parametric{\List}{s})
\ =_{\parametricscript{\List}{s}}^{s'} 
\\
\parametric{cons}{s}(x\cln s,\parametric{\append}{s}(l\cln\parametric{\List}{s},l'\cln\parametric{\List}{s})
\end{array}
& \textrm{for any sorts $s, s'$}
\\[3ex]
\varphi[\varphi_1/{x\cln s}] \wedge (\varphi_1 =_s^{s'} \varphi_2) \rightarrow \varphi[\varphi_2/{x\cln s}]
&\textrm{where $s,s'$ are any sorts, $\varphi$ any pattern of} \\
& \textrm{sort $s'$, and $\varphi_1,\varphi_2$ any patterns of sort $s$}
\\[2ex]
\textit{G: stopped here, we should add all sorts below}
\\[2ex]
\forall x . \varphi \rightarrow \varphi[t/x]
&\textrm{where $t$ is any \emph{syntactic pattern}, or \emph{term}}, \\
& \textrm{i.e., containing only variables and symbols}
\\[2ex]
(\lambda x . \varphi)\varphi' = \varphi[\varphi'/x]
& \textrm{where $\varphi$, $\varphi'$ are patterns containing only}
\\
& \textrm{variables, $\lambda$ binders and application symbols}
\\[2ex]
\varphi_1 \mathrel{\texttt{+}} \varphi_2 = \varphi_1 +_\Nat \varphi_2
& \textrm{where $\varphi$, $\varphi'$ are \emph{ground} syntactic patterns}
\\
&\textrm{of sort $\Nat$, that is, patterns built only}
\\
&\textrm{with symbols \texttt{zero} and \texttt{succ}}
\\[2ex]
(\varphi_1 \rightarrow \varphi_2) \rightarrow
(\varphi[\varphi_1 / x] \rightarrow \varphi[\varphi_2 / x])
& \textrm{where $\varphi$ is a \emph{positive context in $x$}, that is,}
\\
& \textrm{a pattern
containing only one occurrence}
\\
&\textrm{of $x$ with no negation ($\neg$) on the path to}
\\
&\textrm{$x$, and where $\varphi_1$, $\varphi_2$ are any patterns}
\\
&\textrm{having the same sort}
\end{array}
$$

One of the major goals of this paper is to propose a formal language,
and an implementation, that allow us to finitely specify potentially
infinite matching logic theories presented with finitely many pattern schemas.

\subsection{Built-ins}
\label{sec:builtins}

It is rarely the case in practice that a matching logic theory, for example
a programming language semantics, is defined from scratch.
Typically, it makes use of built-ins, such as natural/integer/real numbers.
While sometimes builtins can be defined themselves as matching logic theories,
for example Booleans, in general such definitions may require sets of axioms
which are not r.e., and thus may be hard or impossible to encode regardless
of the chosen formalism.
Additionally, different tools may need to regard or use the builtins
differently;
for example, an interpreter may prefer the builtins to be hooked to a
fast implementation as a library, a symbolic execution engine may prefer the
builtins to be hooked to an SMT solver like Z3, while a mechanical program
verifier may prefer a rigorous definition of builtins using Coq, Isabelle,
or Agda.

Recall from Section~\ref{sec:semantics} that the semantics of a matching
logic theory $(\Sigma,A)$ was loosely defined as the collection of all
$\Sigma$-models satisfying its axioms: $\denote{(\Sigma,A)} =
\{M \ \mid \ M \in \Mod_{\Sigma},\ M \models_{\Sigma} A \}$.
To allow all the builtin scenarios above and stay as abstract as possible
w.r.t.~builtins, we generalize matching logic theories and their semantics
as follows.

\begin{definition}
A \emph{matching logic theory with builtins}
$(S_\builtin,\Sigma_\builtin,S,\Sigma,A)$, written as a triple
$(\Sigma_\builtin,\Sigma,A)$ and
called just a \emph{matching logic theory} whenever there is no confusion,
is an ordinary matching logic theory together with a
\emph{subsignature of builtins}
$(S_\builtin,\Sigma_\builtin)\hookrightarrow(S,\Sigma)$.
Sorts in $S_\builtin \subseteq S$ are called \emph{builtin sorts} and symbols in
$\Sigma_\builtin \subseteq \Sigma$ are called \emph{builtin symbols}.
\end{definition}

Therefore, signatures identify a subset of sorts and symbols as builtin,
with the intuition that implementations are now \emph{parametric} in an
implementation of their builtins.
Or put differently, the semantics of a matching logic theory with builtins
is parametric in a model for its builtins:

\begin{definition}
Given a matching logic theory with builtins $(\Sigma_\builtin,\Sigma,A)$ and
a \emph{model of builtins} $B \in \Mod(\Sigma_\builtin)$, we define
the \emph{$B$-semantics} of $(\Sigma_\builtin,\Sigma,A)$ loosely as follows:
$$
\denote{(\Sigma_\builtin,\Sigma,A)}_B = 
\{M \ \mid \ M \in \Mod_{\Sigma},\ M \models_{\Sigma} A,\ \reduct{M}{\Sigma_\builtin} = B \}
$$
We may drop $B$ from $B$-semantics whenever the builtins model is
understood from context.
\end{definition}

Note that $A$ may contain axioms over $\Sigma_\builtin$, which play a dual
role: they filter out the candidates for the models of builtins on the one
hand, and they can be used in reasoning on the other hand\info{For this,
we may want to organize ML as an institution.}.
Theoretically, we can always enrich $A$ with the set of \emph{all} patterns
matched by $B$, and thus all the properties of the model of builtins are
available for reasoning in any context, but note that in practice there may
be no finite or algorithmic way to represent those
(e.g., the set of properties of the ``builtin'' model of natural numbers is
not r.e.).


\section{Meta-Theory of Matching Logic: Finite Case}

\newcommand{\Kfinite}{{K_\text{finite}}}

\todo[inline, author=Xiaohong]{I am working on this section, so please don't touch it to prevent conflicts.}

\emph{Finite matching logic theories} are theories that have a finite number of sorts, symbols, and axioms.
In this section, we present a matching logic theory $\Kfinite = ( S_\Kfinite, \Sigma_\Kfinite, F_\Kfinite )$ as \emph{the theory of finite matching logic theories}, in which $S_\Kfinite$ , $\Sigma_\Kfinite$, and $F_\Kfinite$ are finite sets of sorts, symbols, and axioms, respectively.

Finite theories are very common in practice.
Most theories for algebraic data structures introduced in~\cite{rosu-2017-lmcs} are finite. The theory $\Kfinite$ itself is a finite matching logic theory, too.

\subsection{Truth}
\improvement
{Xiaohong: This section needs improvement.}
A sort $\KPred$ is introduced to capture predicates and the predicate logic.
Patterns of sort $\KPred$ are called \emph{predicate patterns} or just \emph{predicates}, and symbols whose return sort are $\KPred$ are called \emph{predicate symbols}. 
Predicate symbols in $\Kfinite$ are defined in later sections when they firstly appear.
\begin{notation}
	If $b$ is a predicate pattern, we take the freedom to write $b$ instead of $b = \top_\KPred$, so that $\KPred$ patterns can be used in any sort context.
\end{notation}





\subsection{Characters and Strings}
The sort $\KChar$ is the sort for \emph{characters}. It has the following $26 + 26 + 10 = 62$ functional symbols as constructors:
\begin{center}
	\begin{tabular}{c c c}
		$\quot{a} \colon \to \KChar$ & $\quot{b} \colon \to \KChar$ & $\quot{c} \colon \to \KChar$ \\
		$\cdots$ & $\cdots$ & $\cdots$ \\
		$\quot{x} \colon \to \KChar$ & $\quot{y} \colon \to \KChar$ & $\quot{z} \colon \to \KChar$ \\
		$\quot{A} \colon \to \KChar$ & $\quot{B} \colon \to \KChar$ & $\quot{C} \colon \to \KChar$ \\
		$\cdots$ & $\cdots$ & $\cdots$ \\
		$\quot{X} \colon \to \KChar$ & $\quot{Y} \colon \to \KChar$ & $\quot{Z} \colon \to \KChar$ \\
		$\quot{0} \colon \to \KChar$ & $\cdots$ & $\quot{9} \colon \to \KChar$ 
	\end{tabular}
\end{center}

\paragraph{String as Finite Lists of Characters.}\quad
Characters are used to construct \emph{strings}, which will be formalized as finite lists of characters.
In Section~\cref{sec:finite-lists}, we will define a sort $\KCharList$ for finites lists of characters, and two functional constructors
\begin{align*}
 & \KnilKCharList \colon \to \KCharList \\
 & \KconsKCharList \colon \KChar \times \KCharList \to \KCharList
\end{align*}
that construct lists of characters.

\begin{notation}
	We write $\KString$ as an alias of the sort $\KCharList$, and we write $\Kepsilon$ as an alias of $\KnilKCharList$ which represents the empty string.
\end{notation}

\begin{notation}
	As a convention, strings are often represented by texts wrapped with quotation marks. 
	For example, instead of writing
	$$
	\KconsKCharList(\quot{a}, \KconsKCharList(\quot{b}, \KconsKCharList(\quot{c}, \Kepsilon)))
	$$
	we simply write $\quot{abc}$.
\end{notation}

\subsection{Matching Logic Sorts and Symbols}

The sort $\KSort$ is the sort for matching logic sorts.
The only constructor of the sort $\KSort$ is the functional symbol
\begin{equation*}
\Ksort \colon \KString \to \KSort
\end{equation*}
where the argument is called the \emph{name} of the sort. 

The sort $\KSymbol$ is the sort for matching logic symbols.
The only constructor of the sort $\KSymbol$ is the functional symbol
\begin{equation*}
\Ksymbol \colon \KString \times \KSortList\footnote{The sort $\KSortList$ is defined in Section~\cref{sec:finite-lists}} \times \KSort \to \KSymbol
\end{equation*}
where the first argument is called the \emph{name} of the symbol, and the rest arguments are called the \emph{argument sorts} and the \emph{return sort} of the symbol. 
Two getter functions, $\KgetArgumentSorts$ and $\KgetReturnSort$, are defined as functional symbols
\begin{align*}
 & \KgetArgumentSorts \colon \KSymbol \to \KSortList \\
 & \KgetReturnSort    \colon \KSymbol \to \KSort
\end{align*}
with axioms
\begin{align*}
 & \KgetArgumentSorts(\Ksymbol(f, S, s)) = S\\
 & \KgetReturnSort(\Ksymbol(f, S, s)) = s
\end{align*}
where $f$ is a $\KString$ variable, $S$ is a $\KSortList$ variable, and $s$ is a $\KSort$ variable.

\subsection{Finite Lists}
\label{sec:finite-lists}

For sorts $\KChar$, $\KSort$, $\KSymbol$, and $\KPattern$\footnote{The sort $\KPattern$ is defined in Section~\cref{sec:matching-logic-patterns}.}
in $S_\Kfinite$,
we define sorts $\KCharList$, $\KSortList$, $\KSymbolList$, and $\KPatternList$ to be the sorts of finite lists over them, respectively.
Formally, for any sort $X$ where
$$
X \in \{\KChar, \KSort, \KSymbol, \KPattern\}
$$
the sort $\XList$ is in $S_\Kfinite$, and the following functional constructors of the sort $\XList$ are in $\Sigma_\Kfinite$
\begin{align*}
  & \KnilXList \colon \to \XList
  \\
  & \KconsXList \colon \mathit{X} \times \XList \to \XList
\end{align*}

\begin{notation}
	To write lists expression more compactly, we adopt the following abbreviations
	\begin{equation*}
	  (x_1, x_2, \dots, x_n) \equiv \KconsXList(x_1, \KconsXList(x_2, \dots\KconsXList(x_n, \KnilXList)\dots))
	\end{equation*}
\end{notation}

Common operations on lists can be defined as functional symbols on $\XList$.
The symbol $$\KappendXList \colon \XList \times \XList \to \XList$$ 
takes two lists and returns the concatenation of them, with two axioms
\begin{align*}
  & \KappendXList(\KnilXList, L) = L
  \\
  & \KappendXList(\KconsXList(x, L_0), L) = \KconsXList(x, \KappendXList(L_0, L))
\end{align*}

The predicate symbol $$\KinXList \colon \mathit{X} \times \XList \to \KPred$$
takes an element and a list, and decides whether the element is a member of the list or not. The two axioms for $\KinXList$ are
\begin{align*}
  & \neg \KinXList(x, \KnilXList)
  \\
  & \KinXList(x, \KconsXList(y, L)) = (x = y) \vee \KinXList(x, L)
\end{align*}

The functional symbol $$\KdeleteXList \colon \mathit{X} \times \XList \to \XList$$
takes an element and a list, and returns the list in which all the occurrences
of the element have been deleted, and the order of the remaining elements does not
change.
It is axiomatized by the next two axioms
\begin{align*}
  & \KdeleteXList(x, \KnilXList) = \KnilXList
  \\
  & \KdeleteXList(x, \KconsXList(y, L))
  \\
  & = ((x = y) \wedge \KdeleteXList(x, L)) \vee ((x \neq y) \wedge \KconsXList(y, \KdeleteXList(x, L)))
\end{align*}


\subsection{Matching Logic Patterns}
\label{sec:matching-logic-patterns}

The sort $\KPattern$ is the sort for matching logic patterns.
It has five functional constructors
\begin{align*}
  & \Kvariable \colon \KString \times \KSort \to \KPattern
  \\
  & \Kapplication \colon \KSymbol \times \KPatternList \to \KPattern
  \\
  & \Kand  \colon \KPattern \times \KPattern \times \KSort \to \KPattern
  \\
  & \Knot \colon \KPattern \times \KSort \to \KPattern
  \\
  & \Kexists \colon \KString \times \KSort \times \KPattern \times \KSort \to \KPattern
\end{align*}
Apart from the five constructor symbols, the sort $\KPattern$ also has
the following functional symbols\info{Maybe use \textit{Kmembership} instead of $\Kin$?}
\begin{align*}
  & \Kor \colon \KPattern \times \KPattern \times \KSort \to \KPattern
  \\
  & \Kimplies \colon \KPattern \times \KPattern \times \KSort \to \KPattern
  \\
  & \Kiff \colon \KPattern \times \KPattern \times \KSort \to \KPattern
  \\
  & \Kforall \colon \KString \times \KSort \times \KPattern \times \KSort \to \KPattern
  \\
  & \Kceil \colon \KPattern \times \KSort \times \KSort \to \KPattern
  \\
  & \Kfloor \colon \KPattern \times \KSort \times \KSort \to \KPattern
  \\
  & \Kequals \colon \KPattern \times \KPattern \times \KSort \times \KSort \to \KPattern
  \\
  & \Kin \colon \KPattern \times \KPattern \times \KSort \times \KSort \to \KPattern
  \\
  & \Ktop \colon \KSort \to \KPattern
  \\
  & \Kbottom \colon \KSort \to \KPattern
\end{align*}



\begin{notation}\label{notation:variables-about-KPattern}
	As a convention, we use $\varphi$ and $\psi$ for $\KPattern$ variables, $x$, $y$, and $z$ for $\KString$ variables, $s$ for $\KSort$ variables, and $\sigma$ for $\KSymbol$ variables. 
\end{notation}

Functional symbols that do not belong to the five constructors of $\KPattern$ are called \emph{derived connectives of $\KPattern$}, and they are axiomatized by the following axioms
\begin{align*}
  & \Kor(\varphi, \psi, s) = \Knot(\Kand(\Knot(\varphi, s), \Knot(\psi, s), s), s)
  \\
  & \Kimplies(\varphi, \psi, s) = \Kor(\Knot(\varphi, s), \psi, s)
  \\
  & \Kiff(\varphi, \psi, s) = \Kand(\Kimplies(\varphi, \psi, s), \Kimplies(\psi, \varphi, s), s)
  \\
  & \Kforall(x, s_1, \varphi, s_2) = \Knot(\Kexists(x, s_1, \Knot(\varphi, s_2), s_2), s_2)
  \\
  & \Kceil(\varphi, s_1, s_2) =
    \Kapplication(\Ksymbol(\quot{ceil}, \KconsKSortList(s_1, \KnilKSortList), s_2), \varphi)
  \\
  & \Kfloor(\varphi, s_1, s_2) = \Knot(\Kceil(\Knot(\varphi, s_1), s_1, s_2), s_2)
  \\
  & \Kequals(\varphi, \psi, s_1, s_2) = \Kfloor(\Kiff(\varphi, \psi, s_1), s_1, s_2)
  \\
  & \Kin(\varphi, \psi, s_1, s_2) = \Kfloor(\Kimplies(\varphi, \psi, s_1), s_1, s_2)
  \\
  & \Ktop(s) = \Kexists(x, s, \Kvariable(x, s), s)
  \\
  & \Kbottom(s) = \Knot(\Ktop(s), s)
\end{align*}

\begin{notation}
	As one may have already noticed, patterns of sort $\KPattern$ get huge rather quickly.
	The following notation conventions are adopted to write $\KPattern$ patterns in a more compact way, by putting a bar upon their normal mixfix forms
	\begin{align*}
	  & \overline{x \cln s} \equiv \Kvariable(x, s)
	  \\
	  & \overline{\sigma(\varphi_1, \dots, \varphi_n)} \equiv \Kapplication(\sigma, (\varphi_1, \dots, \varphi_n))
	  \\
	  & \overline{\varphi \wedge_s \psi} \equiv \Kand(\varphi, \psi, s)
	  \\
	  & \overline{\neg_s \varphi} \equiv \Knot(\varphi, s)
	  \\
	  & \overline{\exists_{s_1}^{s_2} x . \varphi} \equiv \Kexists(x, s_1, \varphi, s_2)
	  \\
	  & \overline{\varphi \vee_s \psi} \equiv \Kor(\varphi, \psi, s)
	  \\
	  & \overline{\varphi \to_s \psi} \equiv \Kimplies(\varphi, \psi, s)
	  \\
	  & \overline{\varphi \leftrightarrow_s \psi} \equiv \Kiff(\varphi, \psi, s)
	  \\
	  & \overline{\forall_{s_1}^{s_2} x . \varphi} \equiv \Kforall(x, s_1, \varphi, s_2)
      \\
      & \overline{\ceil{\varphi}_{s_1}^{s_2}} \equiv \Kceil(\varphi, s_1, s_2)
      \\
      & \overline{\floor{\varphi}_{s_1}^{s_2}} \equiv \Kfloor(\varphi, s_1, s_2)
      \\
      & \overline{\varphi =_{s_1}^{s_2} \psi} \equiv \Kequals(\varphi, \psi, s_1, s_2)
      \\
      & \overline{\varphi \in_{s_1}^{s_2} \psi} \equiv \Kin(\varphi, \psi, s_1, s_2)
      \\
      & \overline{\top_s} \equiv \Ktop(s)
      \\
      & \overline{\bot_s} \equiv \Kbottom(s)
	\end{align*}
\end{notation}

Apart from the five constructors and ten derived connectives introduced above, the sort $\KPattern$ also gets some common operators defined as functional symbols.
Those functional symbols are defined and axiomatized in this section, too.

\paragraph{Free Variable Collection.}
The functional symbol 
$$\KgetFvs \colon \KPattern \to \KPatternList$$
traverses the argument pattern and collects all its free variables.
If a variable has multiple occurrences in the pattern, it will has the same number of occurrences in the result list.
A related functional symbol is 
$$ \KgetFvsFromPatterns \colon \KPatternList \to \KPatternList $$
which takes a list of patterns and applies $\KgetFvs$ on each of them, and returns the concatenation of the results.
\begin{notation}
	As a naming convention, we use $L$ and $R$ for $\KPatternList$ variables. 
\end{notation}
The next seven axioms define $\KgetFvs$ and $\KgetFvsFromPatterns$, with the first five of them defining $\KgetFvs$ and the last two defining $\KgetFvsFromPatterns$
\begin{align*}
& \KgetFvs(\overline{x \cln s}) = \overline{x \cln s}
\\
& \KgetFvs(\overline{\sigma(L)}) = \KgetFvsFromPatterns(L)
\\
& \KgetFvs(\overline{\varphi \wedge_s \psi}) = \KappendKPatternList(\KgetFvs(\varphi), \KgetFvs(\psi))
\\
& \KgetFvs(\overline{\neg_s \varphi}) = \KgetFvs(\varphi)
\\
& \KgetFvs(\overline{\exists_{s_1}^{s_2} x . \varphi}) = \KdeleteKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi))
\\
& \KgetFvsFromPatterns(\KnilKPatternList) = \KnilKPatternList
\\
& \KgetFvsFromPatterns(\KconsKPatternList(\varphi, L))
\\
& = \KappendKPatternList(\KgetFvs(\varphi), \KgetFvsFromPatterns(L))
\end{align*}

\paragraph{Fresh Variable Generation.}
The functional symbol
$$\KfreshName \colon \KPatternList \to \KString$$ 
generates a fresh variable name that does not occur free in the argument list of patterns.
It has the following axiom
\begin{align*}
\neg(\KinKPatternList(\Kvariable(\KfreshName(L), s), \KgetFvsFromPatterns(L)))
\end{align*}

\paragraph{Substitution.}
The functional symbol
$$\Ksubstitute \colon \KPattern \times \KPattern \times \KString \times \KSort \to \KPattern$$
takes a target pattern $\varphi$, a ``replace''-pattern $\psi$, and a ``find''-variable (given as its name $z$ and sort $s$), and returns $\varphi[\psi / z \cln s]$, the pattern in which all free occurrences of variable ${z \cln s}$ are placed with $\psi$, with respect to alpha-renaming.

A related function is 
$$\KsubstitutePatterns \colon \KPatternList \times \KPattern \times \KString \times \KSort \to \KPatternList$$
which takes a list of patterns and applies $\Ksubstitute$ on each of them, and finally returns the list of all the results.

\begin{notation}
	We abbreviate 
	$$\Ksubstitute(\varphi, \psi, z \cln s) \equiv \overline{\varphi[\psi / z \cln s]}$$
	and 
	$$\KsubstitutePatterns(L, \psi, z \cln s) \equiv \overline{L[\psi / z \cln s]}$$
	in which $L$ is a $\KPatternList$ variable.
\end{notation}

The functional symbols $\Ksubstitute$ and $\KsubstitutePatterns$ have the following axioms
\begin{align*}
  & \overline{x \cln s' [\psi / z \cln s]} = ((\overline{x \cln s'} = \overline{z \cln s}) \wedge \psi) \vee ((\overline{x \cln s'} \neq \overline{z \cln s}) \wedge \overline{x \cln s'})
  \\
  & \overline{\sigma(L) [\psi / z \cln s]} = \overline{\sigma(L[\psi / z \cln s])}
  \\
  & \overline{(\varphi_1 \wedge_{s'} \varphi_2) [\psi / z \cln s]} = \overline{\varphi_1[\psi / z \cln s] \wedge_{s'} \varphi_2[\psi / z \cln s]}
  \\
  & \overline{(\neg_{s'} \varphi)[\psi / z \cln s]} = \overline{\neg_{s'} \varphi[\psi / z \cln s]}
  \\
  & \overline{(\exists_{s_1}^{s_2}x . \varphi)[\psi/z \cln s]} = \exists y . (y = \KfreshName(\varphi, \psi, \overline{x \cln s_1})) \wedge \overline{\exists_{s_1}^{s_2} y . (\varphi[y/x \cln s_1][\psi/z \cln s])}
  \\
  & \overline{\KnilKPatternList[\psi / z \cln s]} = \KnilKPatternList
  \\
  & \overline{\KconsKPatternList(\varphi, L)[\psi / z \cln s]} = \KconsKPatternList(\overline{\varphi[\psi / z \cln s]}, \overline{L[\psi / z \cln s]})
\end{align*}

\paragraph{Alpha-Renaming and Alpha-Equivalence.}
In matching logic, alpha-renaming is always assumed.
This means that the pattern set of a matching logic theory is the one that is generated by the grammar of matching logic patterns in Figure~\ref{ml-grammar}, \emph{modulo alpha-renaming}.
In other words, matching logic patterns are equivalence classes with respect to alpha-equivalence.
This fact is captured in $\Kfinite$ by the next axiom
$$
\overline{\exists_{s_1}^{s_2} x . \varphi} = \overline{\exists_{s_1}^{s_2} y . \varphi[y \cln s_1 / x \cln s_1]}
$$

\subsection{Finite Matching Logic Signatures}

The sort $\KSignature$ is the sort for finite matching logic signatures, and it has only one functional constructor
\begin{equation*}
\Ksignature \colon \KSortList \times \KSymbolList \to \KSignature
\end{equation*}
which takes a finite list of sorts and a finite list of symbols as arguments, and returns the corresponding finite signature.
\begin{notation}
	As a convention, we use $\Sigma$ for $\KSignature$ variables.\improvement{I found it sometimes confusing to use the same letter $\Sigma$ for both $\KSymbolList$ variables and $\KSignature$ variables. We should use $\Sigma$ only for $\KSymbolList$ variables, and find a new letter for $\KSignature$ variables.} 
	We use~$S$ for~$\KSortList$ variables and $\Sigma$ for $\KSymbolList$ variables if they appear as in~$\Ksignature(S, \Sigma)$.
	We often abbreviate $\Ksignature(S, \Sigma)$ as $( S, \Sigma )$. 
\end{notation}
Two getter functions, $\KgetSorts$ and $\KgetSymbols$, are defined as functional symbols
\begin{align*}
  & \KgetSorts \colon \KSignature \to \KSortList
  \\
  & \KgetSymbols \colon \KSignature \to \KSymbolList
\end{align*}
with axioms
\begin{align*}
  & \KgetSorts(\Ksignature(S, \Sigma)) = S
  \\
  & \KgetSymbols(\Ksignature(S, \Sigma)) = \Sigma
\end{align*}



Common operators on $\KSignature$ and $\KPattern$ can then be easily defined.
Two basic ones are predicate symbols $\KsortDeclared$ and $\KsymbolDeclared$
\begin{align*}
 & \KsortDeclared \colon \KSort \times \KSignature \to \KPred \\
 & \KsymbolDeclared \colon \KSymbol \times \KSignature \to \KPred
\end{align*}
that decide whether sorts and symbols are declared in the given signature.
They are axiomatized by the next two axioms
\begin{align*}
 & \KsortDeclared(s, \Sigma) = \KinKSortList(s, \KgetSorts(\Sigma)) \\
 & \KsymbolDeclared(\sigma, \Sigma) = \KinKSymbolList(\sigma, \KgetSymbols(\Sigma))
\end{align*}

\paragraph{Well-formedness.}
\improvement{Cite something here.}
The predicate symbol
$$\KwellFormed \colon \KPattern \times \KSignature \to \KPred$$ 
takes a pattern and a finite signature, and decides whether the pattern is a \emph{well-formed pattern} in the given signature.

The partial function
$$\KgetSort \colon \KPattern \times \KSignature \rightharpoonup \KSort$$
takes a pattern and a finite signature, and returns the sort of the pattern in the given signature if the pattern is well-formed.
Otherwise, it returns $\bot_\KSort$.

A related partial function is 
$$ \KgetSortsFromPatterns \colon \KPatternList \times \KSignature \rightharpoonup \KSortList
$$
that takes a pattern lists and applies $\KgetSort$ on each element, and finally returns the list of results.
It has two straightforward axioms
\begin{align*}
  & \KgetSortsFromPatterns(\KnilKPatternList, \Sigma) = \KnilKSortList
  \\
  & \KgetSortsFromPatterns((\varphi, L), \Sigma) = (\KgetSort(\varphi, \Sigma), \KgetSortsFromPatterns(L, \Sigma))
\end{align*}

The partial functions $\KwellFormed$ and $\KgetSort$ are defined by the following axioms
\begin{align*}
  &\KwellFormed(\overline{x \cln s}, \Sigma) = \KsortDeclared(s, \Sigma)
  \\
  & \KwellFormed(\overline{\sigma(L)}, \Sigma) 
  \\
  & = \KsymbolDeclared(\sigma, \Sigma) \wedge (\KgetSortsFromPatterns(L, \Sigma) = \KgetArgumentSorts(\sigma))
  \\
  & \KwellFormed(\overline{\varphi \wedge_s \psi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s) \wedge (\KgetSort(\psi, \Sigma) = s)
  \\
  & \KwellFormed(\overline{\neg_s \varphi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s)
  \\
  & \KwellFormed(\overline{\exists_{s_1}^{s_2} x . \varphi}, \Sigma) = \KsortDeclared(s_1, \Sigma) \wedge (\KgetSort(\varphi, \Sigma) = s_2)
  \\
  & \KgetSort(\overline{x \cln s}, \Sigma) = \KsortDeclared(s, \Sigma) \wedge s
  \\
  & \KgetSort(\overline{\sigma(L)}, \Sigma) = \KwellFormed(\overline{\sigma(L)}, \Sigma) \wedge \KgetReturnSort(\sigma)
  \\
  & \KgetSort(\overline{\varphi \wedge_s \psi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s) \wedge (\KgetSort(\psi, \Sigma) = s) \wedge s
  \\
  & \KgetSort(\overline{\neg_s \varphi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s) \wedge s
  \\
  & \KgetSort(\overline{\exists_{s_1}^{s_2} x . \varphi}, \Sigma) = \KsortDeclared(s_1, \Sigma) \wedge (\KgetSort(\varphi, \Sigma) = s_2) \wedge s_2
\end{align*}

It is often useful to check whether multiple patterns are all well-formed in a given signature.
The predicate symbol
$$ \KwellFormedPatterns \colon \KPatternList \times \KSignature \to \KPred$$
does that.
It applies $\KwellFormed$ on each pattern and returns $\bot_\KPred$ if one of the applications returns $\bot_\KPred$.
It has two axioms
\begin{align*}
 & \KwellFormedPatterns(\KnilKPatternList, \Sigma) \\
 & \KwellFormedPatterns((\varphi, L), \Sigma) = \KwellFormed(\varphi, \Sigma) \wedge \KwellFormedPatterns(L, \Sigma)
\end{align*}

\subsection{Finite Matching Logic Theories}

The sort $\KTheory$ is the sort of finite matching logic theories. The only constructor symbol is 
$$\Ktheory \colon \KSignature \times \KPatternList \to \KTheory$$
which takes a finite signature and a finite list of patterns as axioms, and returns the finite matching logic theory. 

\begin{notation}
	As a convention, we use $A$ for $\KPatternList$ variables as it appears in $\Ktheory(\Sigma, A)$, which is often abbreviated as $( \Sigma, A )$. The theory $( ( S, \Sigma ), A )$ is often abbreviated to $( S, \Sigma, A )$. We use $T$ for $\KTheory$ variables.  
\end{notation}

Common operations on theories can be defined as functional symbols.
The predicate symbol
\begin{equation*}
  \KwellFormedTheory \colon \KTheory \to \KPred
\end{equation*}
takes a theory and decides whether the theory is well-formed, in the sense that every axioms of the theory are well-formed with respect to the theory's signature
\begin{equation*}
\KwellFormedTheory(\Ktheory(\Sigma, A)) = \KwellFormedPatterns(A, \Sigma)
\end{equation*}

\subsection{Matching Logic Proof System}
\label{sec:ml-proof-system-finite-case}

A sound and complete proof system has been introduced in~\cite{rosu-2017-lmcs}.
In this section we define the predicate symbol $\Kdeduce$ that captures the sound and complete proof system of matching logic.
The predicate symbol
$$
\Kdeduce \colon \KTheory \times \KPattern \to \KPred
$$
takes a finite theory and a pattern as proof obligation, and decides if the obligation pattern is deducible in the given theory.
The symbol $\Kdeduce$ has axioms in correspondence to the inference rules\footnote{Axioms are considered as inference rules with zero premises, so we do not distinguish axioms from inference rules.} 
of the matching logic proof system in~\cite{rosu-2017-lmcs}.

In the following, we list all the inference rules of the matching logic proof system and the correspondent axioms of $\Kdeduce$. \improvement{We should mention here that all the subterms / subpatterns that appear in the axioms are assumed to be well-formed. Also, the theory $T$ itself must be well-formed, in the sense that all axioms in $T$ are well-formed. We omit those premises when writing the axioms because writing all of them down need a lot of space, and will make the axioms less readable.}

We recall the readers our conventions of choosing variable names. 
We use 
$x$ and $y$ for $\KString$ variables,
$s$ for $\KSort$ variables,
$\varphi$ and $\psi$ for $\KPattern$ variables,
$l$ and $r$ for $\KPatternList$ variables~(in \textbf{Rule~(M5)}),
$\Sigma$ for $\KSignature$ variables, 
$A$ for $\KPatternList$ variables~(in \textbf{Rule~(Axiom)}),
and $T$ for $\KTheory$ variables.

\paragraph{Rule (Axiom).}
$A \vdash \varphi$ if $\varphi \in A$.
\begin{equation*}
\KinKPatternList(\varphi, A) \to \Kdeduce(( \Sigma, A ), \varphi).
\end{equation*}

\paragraph{Rule (K1).}
$\vdash \varphi \to (\psi \to \varphi)$.
\begin{equation*}
\Kdeduce(T, \overline{\varphi \leftrightarrow (\psi \leftrightarrow_s  \varphi)}).
\end{equation*}

\paragraph{Rule (K2).}
$\vdash (\varphi_1 \to (\varphi_2 \to \varphi_3)) \to ((\varphi_1 \to \varphi_2) \to (\varphi_1 \to \varphi_3))$.
\begin{equation*}
\Kdeduce(T, 
\overline{(\varphi_1 \leftrightarrow_s (\varphi_2 \leftrightarrow_s \varphi_3)) \leftrightarrow_s ((\varphi_1 \leftrightarrow_s \varphi_2) \leftrightarrow_s (\varphi_1 \leftrightarrow_s \varphi_3))}).
\end{equation*}

\paragraph{Rule (K3).}
$\vdash (\neg \psi \to \neg \varphi) \to (\varphi \to \psi)$.
\begin{equation*}
\Kdeduce(T, \overline{(\neg_s \psi \leftrightarrow_s \neg_s \varphi) \leftrightarrow_s (\varphi 
\leftrightarrow_s \psi)}).
\end{equation*}

\paragraph{Rule (K4).}
$\vdash \forall x . \varphi \to \varphi[y/x]$.
\begin{equation*}
\Kdeduce(T, \overline{\forall_{s_1}^{s_2}  x . \varphi \leftrightarrow_{s_2} \varphi[y \cln s_1 / x \cln s_1]}).
\end{equation*}

\paragraph{Rule (K5).}
$\vdash \forall x . (\varphi \to \psi) \to (\varphi \to \forall x . \psi)$ if $x$ does not occur free in $\varphi$. 
\begin{equation*}
\neg\KinKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi))
\to \Kdeduce(T, \overline{\forall_{s_1}^{s_2} x . (\varphi \leftrightarrow_{s_2} \psi) \leftrightarrow_{s_2} (\varphi \leftrightarrow_{s_2} \forall_{s_1}^{s_2} x . \psi)}).
\end{equation*}

\paragraph{Rule (K6).}
$\vdash (\varphi_1 = \varphi_2) \to (\psi[\varphi_1/x] \to \psi[\varphi_2/x])$.
\begin{equation*}
\Kdeduce(T, \overline{(\varphi_1 =_{s_1}^{s_2} \varphi_2) \leftrightarrow_{s_2} (\psi[\varphi_1/x \cln s] \leftrightarrow_{s_2} \psi[\varphi_2/x \cln s])}).
\end{equation*}

\paragraph{Rule (Df).}
$\vdash \ceil{x}$.
\begin{equation*}
\Kdeduce(T, \Kapplication(\Ksymbol(\quot{ceil}, \KconsKSortList(s_1, \KnilKPatternList), s_2), \overline{x \cln s_1})).
\end{equation*}

\paragraph{Rule (M1).}
$\vdash (x \in y) = (x = y)$.
\begin{equation*}
\Kdeduce(T, \overline{(x \in_{s_1}^{s_2} y) =_{s_2}^{s_3} (x =_{s_1}^{s_2} y)}).
\end{equation*}

\paragraph{Rule (M2).}
$\vdash x \in (\varphi \wedge \psi) = (x \in \varphi) \wedge (x \in \psi).$
\begin{equation*}
\Kdeduce(T, \overline{x \in_{s_1}^{s_2} (\varphi \wedge_{s_1} \psi) =_{s_2}^{s_3} (x \in_{s_1}^{s_2} \varphi) \wedge_{s_2} (x \in_{s_1}^{s_2} \psi)}).
\end{equation*}

\paragraph{Rule (M3).}
$\vdash x \in \neg \varphi = \neg (x \in \varphi)$.
\begin{equation*}
\Kdeduce(T, \overline{x \in_{s_1}^{s_2} \neg_{s_1} \varphi =_{s_2}^{s_3} \neg_{s_2} (x \in_{s_1}^{s_2} \varphi)}).
\end{equation*}

\paragraph{Rule (M4).}
$\vdash x \in \forall y . \varphi = \forall y . x \in \varphi$ if $x$ is distinct from $y$.
\begin{equation*}
(\overline{x \cln s_1} \neq \overline{y \cln s_2})  \to \Kdeduce(T, \overline{(x \in_{s_1}^{s_3} \forall_{s_2}^{s_1} y . \varphi) =_{s_3}^{s_4} (\forall_{s_2}^{s_3} y . (x \in_{s_1}^{s_3} \varphi))}).
\end{equation*}

\paragraph{Rule (M5).}
$\vdash x \in \sigma(\dots \varphi_i \dots) = \exists y . y \in \varphi_i \wedge x \in \sigma(\dots y \dots)$ where $y$ is distinct from $x$ and it does not occur free in $\sigma(\dots \varphi_i \dots)$.
\begin{align*}
& (\overline{x \cln s_1} \neq \overline{y \cln s_2}) 
  \wedge \neg \KinKPatternList(\overline{y \cln s_2}, \KgetFvs(\overline{\sigma(L, \varphi_i, R)}))
\\
\to & \Kdeduce(T, \overline{x \cln s_1 \in_{s_1}^{s_3} \sigma(L, 
\varphi_i, R) =_{s_3}^{s_4} \exists_{s_2}^{s_4} y . (y \cln s_2 \in_{s_2}^{s_3} \varphi_i \wedge x \cln s_1 \in_{s_1}^{s_3} \sigma(L, y, R))}),
\end{align*}
where $L$ and $R$ are $\KPatternList$ variables, and we write $(L, \varphi, R)$ as a shorthand of
$$(L, \varphi, R) \equiv \KappendKPatternList(L, \KconsKPatternList(\varphi, R)).$$

\paragraph{Rule (Modus Ponens).}
If $\vdash \varphi$ and $\vdash \varphi \to \psi$, then $\vdash \psi$.
\begin{equation*}
\Kdeduce(T, \varphi) \wedge \Kdeduce(T, \overline{\varphi \leftrightarrow_s \psi}) \to 
\Kdeduce(T, \psi).
\end{equation*}

\paragraph{Rule (Universal Generalization).}
If $\vdash \varphi$, then $\vdash \forall x . \varphi$.
\begin{equation*}
\Kdeduce(T, \varphi) \to \Kdeduce(T, \overline{\forall_{s_1}^{s_2} x . \varphi}).
\end{equation*}

\paragraph{Rule (Membership Introduction).}
If $\vdash \varphi$ and $x$ does not occur free in $\varphi$, then $\vdash x \in \varphi$.
\begin{equation*}
\Kdeduce(T, \varphi) \wedge \neg \KinKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi)) \to \Kdeduce(T, \overline{x \cln s_1 \in_{s_1}^{s_2} \varphi}).
\end{equation*}

\paragraph{Rule (Membership Elimination).}
If $\vdash x \in \varphi$ and $x$ does not occur free in $\varphi$, then $\vdash \varphi$.
\begin{equation*}
\Kdeduce(T, \overline{x \cln s_1 \in_{s_1}^{s_2} \varphi}) \wedge\neg \KinKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi)) \to \Kdeduce(T, \varphi).
\end{equation*}

\subsection{Faithfulness: Finite Case}

\begin{theorem}[Faithfulness Theorem]\label{thm:faithfulness-finite}
	For any finite matching logic theory $T = (S, \Sigma, A)$ and a $\Sigma$-pattern $\varphi$, let us use $\hat{T}$ to denote the corresponding $\Sigma_\Kfinite$-pattern of the sort $\KTheory$ that represents the theory $T$, and use $\hat{\varphi}$ to denote the corresponding $\Sigma_\Kfinite$-pattern of the sort $\KPattern$ that represents the pattern $\varphi$, then
	$$T \vdash \varphi \quad \text{iff} \quad \Kfinite \vdash \Kdeduce(\hat{T}, \hat{\varphi}).$$
\end{theorem}

Theorem~\ref{thm:faithfulness-finite} is an important theorem that justifies the design and usage of the theory $\Kfinite$. 
It guarantees that the theory $\Kfinite$ does faithfully capture the matching logic reasoning in finite theories.
Before we start to prove the theorem, we need to explain what ``the corresponding patterns'' $\hat{T}$ and $\hat{\varphi}$ are, as they appear in the theorem.
For that reason, we introduce the next definition.

\begin{definition}[Naming and Lifting]
	Suppose $T = (S, \Sigma, A)$ is a finite matching logic theory, with $\Var = \bigcup_{s \in S} \Var_s$ is the set of all variables of $T$.
	\emph{A naming of $T$}, denoted as $e$, consists of the following three naming functions
	\begin{itemize}
		\item A sort-naming function $e_S \colon S \to \PATTERNS_\KString$ that maps each sort in $S$ to a syntactic $\KString$ pattern such that $K \vdash e_S(s_1) \neq e_S(s_2)$ for any distinct sorts $s_1$ and $s_2$;
		\item A symbol-naming function $e_\Sigma \colon \Sigma \to \PATTERNS_\KString$ that maps each symbol in $\Sigma$ to a syntactic $\KString$ pattern such that $K \vdash e_\Sigma(\sigma_1) \neq e_\Sigma(\sigma_2)$ for any distinct symbols $\sigma_1$ and $\sigma_2$;
		\item A variable-naming function $e_\Var \colon \Var \to \PATTERNS_\KString$ that maps each variable in $T$ to a syntactic $\KString$ pattern in $K$, such that $K \vdash e_\Var(x) \neq e_\Var(y)$ for any distinct variables $x$ and $y$.
	\end{itemize}

    Given $e = \{e_S, e_\Sigma, e_\Var \}$ is a naming of theory $T$, the \emph{lift of $T$ with respect to $e$} consists of the following lifting functions.
    
    (Sort-lifting).
    For each sort $s$ in theory $T$, the lift of $s$ is a $\KSort$ pattern
    $$ \hat{s} = \Ksort(e_S(s))$$
    
    (Symbol-lifting).
    For each symbol $\sigma \in \Sigma_{s_1 \dots s_n, s}$, the lift of $\sigma$ is a $\KSymbol$ pattern 
    $$ \hat{\sigma} = \Ksymbol(e_\Sigma(\sigma), (\hat{s_1}, \dots, \hat{s_n}), \hat{s})$$
    
    (Pattern-lifting).
    For each $\Sigma$-pattern $\varphi$, the lift of $\varphi$ is a $\KPattern$ pattern inductively defined as follows
    \begin{equation*}
      \hat{\varphi} =
      \begin{cases*}
        \Kvariable(e_\Var(x), \hat{s}) & if $\varphi$ is a variable $x \in \Var_s \subseteq \PATTERNS_s$
        \\
        \Kapplication(\hat{\sigma}, (\hat{\psi_1}, \dots, \hat{\psi_n})) & if $\varphi$ is $\sigma(\psi_1,\dots,\psi_n) \in \PATTERNS_s$
        \\
        \Kand(\hat{\psi_1}, \hat{\psi_2}, \hat{s}) & if $\varphi$ is $\psi_1 \wedge \psi_2 \in \PATTERNS_s$
        \\
        \Knot(\hat{\psi}, \hat{s}) & if $\varphi$ is $\neg \psi \in \PATTERNS_s$
        \\
        \Kexists(e_\Var(x), \hat{s_1}, \hat{\psi}, \hat{s_2}) & if $\varphi$ is $\exists x . \psi \in \PATTERNS_{s_2}$ and $x \in \Var_{s_1}$
      \end{cases*}
    \end{equation*}
    
    (Theory-lifting). Since $T = (S, \Sigma, A)$ is a finite theory, let us suppose
    \begin{equation*}
       S = \{ s_1, \dots, s_n \}, 
       \Sigma = \{ \sigma_1, \dots, \sigma_m \}, 
       A = \{ \varphi_1, \dots, \varphi_k \},
    \end{equation*}
    are three finite sets. The lift of theory $T$ is a $\KTheory$ pattern 
    $$ \hat{T} = \Ktheory(\Ksignature(\hat{S}, \hat{\Sigma}), \hat{A}),$$
    where the lifts of $S$, $\Sigma$, and $A$ are respectively defined as
    \begin{align*}
    & \hat{S} = \hat{s_1},\dots,\hat{s_n} 
      \quad \text{is a $\KSortList$ pattern}
    \\
    & \hat{\Sigma} = \hat{\sigma_1},\dots,\hat{\sigma_m}
      \quad \text{is a $\KSymbolList$ pattern}
    \\
    & \hat{A} = \hat{\varphi_1}, \dots, \hat{\varphi_k}
      \quad \text{is a $\KPatternList$ pattern}
    \end{align*}
\end{definition}

In order to prove Theorem~\ref{thm:faithfulness-finite}, we introduce a canonical model of $\Kfinite$.

\begin{definition}[Canonical model of $\Kfinite$]
	The canonical model of $\Kfinite$, denoted as $M_\Kfinite$, contains  carrier sets (for each sort in $S_\Kfinite$) and relations (for each symbols in $\Sigma_\Kfinite$) that are defined in the following.
	
	The carrier set for the sort $\KPred$ is a singleton set $M_\KPred = \{ \star \}$. 
	
	The carrier set for the sort $\KChar$ is the set of all 62 constructors of the sort $\KChar$, denoted as $M_\KChar$.
	
	The carrier set for the sort $\KString$ is the set of all syntactic patterns of the sort $\KString$, denoted as $M_\KString$.
	
	The carrier set for the sort $\KSort$ is the set of all syntactic patterns of the sort $\KSort$ 
	$$M_\KSort = \{ \Ksort(str) \mid str \in M_\KString \}.$$
	
	The carrier set for the sort $\KSortList$ is the set of all finite lists of $M_\KSort$:
	$$M_\KSortList = (M_\KSort)^*.$$
	
	The carrier set for the sort $\KSymbol$ is the set of all syntactic patterns of the sort $\KSymbol$
	$$M_\KSymbol = \{ \Ksymbol(str, l, s) \mid str \in M_\KString, l \in M_\KSortList, s \in M_\KSort \}.$$
	
	The carrier set for the sort $\KSymbolList$ is the set of all finite lists over $M_\KSymbol$:
	$$M_\KSymbolList = (M_\KSymbol)^* .$$
	
	The carrier set for the sort $\KPattern$ is the set of all syntactic patterns of the sort $\KPattern$, denoted as $M_\KPattern$.
	
	The carrier set for the sort $\KPatternList$ is the set of all finite lists over $M_\KPattern$:
	$$M_\KPatternList = (M_\KPattern)^*.$$
	
	The carrier set for the sort $\KSignature$ is a product set
	$$ M_\KSignature = M_\KSortList \times M_\KSymbolList.$$
	
	The carrier set for the sort $\KTheory$ is a product set
	$$ M_\KTheory = M_\KSignature \times M_\KPattern. $$
	
	The interpretations of most symbols (except $\Kdeduce$) in $\Kfinite$ are so straightforward that they are trivial.\improvement{Basically I want to say that $M_K$ is almost (except $\Kdeduce$) the initial algebra of $\Kfinite$.}
	For example, $\KconsKSortList$ is interpreted as the cons function on $M_\KSortList$, and $\KdeleteKPatternList$ is interpreted as a function on $M_\KPattern \times M_\KPatternList$ that deletes the first argument from the second, etc.
	
	The only nontrivial interpretation is the one for $\Kdeduce$, as we would like to interpret it \emph{in terms of} matching logic reasoning.
	The interpretation of $\Kdeduce$ in the canonical model is a predicate on $M_\KTheory$ and $M_\KPattern$.
	Intuitively, $\Kdeduce_M(T, \varphi)$ holds if both $T$ and $\varphi$ are well-formed and $\varphi$ is deducible in the finite matching logic theory $T$.
	This intuition is captured by the next formal definition.
	
	For any $T = (\Sigma, A) \in M_\KTheory$ and $\varphi \in M_\KPattern$, we define
	\begin{equation*}
	  \Kdeduce_M(T, \varphi) =
	  \begin{cases*}
	    \emptyset & if $\KwellFormed_M(\Sigma, \varphi) = \emptyset$
	    \\
	    \{ \star \} & if $\Bracket{T} \vdash \Bracket{\varphi}$
	    \\
	    \emptyset & if $\Bracket{T} \not\vdash \Bracket{\varphi}$
	  \end{cases*}
	\end{equation*}
	where the \emph{semantics bracket} $\Bracket{\_}$ is defined (only on well-formed $T$ and $\varphi$) as follows:
	\begin{center}\begin{tabular}{l}
		$\Bracket{T}$ is the matching logic theory $(\Sigma, \Bracket{A})$ \\
		$\Bracket{A} = \{ \Bracket{\psi} | \mid \psi \in A \}$ \\
		$\Bracket{\varphi} =
		 \begin{cases*}
		   x \cln s & if $\varphi$ is $\Kvariable(x, s)$ \\
		   \sigma(\Bracket{\varphi_1},\dots,\Bracket{\varphi_n}) & if $\varphi$ is $\Kapplication(\sigma, (\varphi_1,\dots,\varphi_n))$\\
		   \Bracket{\varphi_1} \wedge \Bracket{\varphi_2} & if $\varphi$ is $\Kand(\varphi_1,\varphi_2,s)$,\\
		   \neg \Bracket{\varphi_1} & if $\varphi$ is $\Knot(\varphi_1, s)$\\
		   \exists x . \Bracket{\varphi_1} & if $\varphi$ is $\Kexists(x, s_1, \varphi_1, s_2)$
		 \end{cases*}$
	\end{tabular}\end{center}

    It is tedious but straightforward to verify that $\Kdeduce_M$ satisfies all axioms about $\Kdeduce$ that we introduced in Section~\cref{sec:ml-proof-system-finite-case}.
    For example, the Rule (K1)
    \begin{equation*}
    \Kdeduce(T, \overline{\varphi \leftrightarrow_s (\psi \leftrightarrow_s \varphi)})
    \end{equation*}
    holds in $\Kfinite$ because
    $$\Bracket{T} \vdash \Bracket{\varphi} \to (\Bracket{\psi} \to \Bracket{\varphi})$$
    The Rule (Modus Ponens)
    \begin{equation*}
    \Kdeduce(T, \varphi) \wedge \Kdeduce(T, \overline{\varphi \leftrightarrow_s \psi}) \to 
    \Kdeduce(T, \psi)
    \end{equation*}
    holds in $\Kfinite$ because
    $$\text{if $\Bracket{T} \vdash \Bracket{\varphi}$ and $\Bracket{T} \vdash \Bracket{\varphi} \to \Bracket{\psi}$, then $\Bracket{T} \vdash \Bracket{\psi}$}.$$
    
    Readers are welcomed to verify the remaining axioms in $\Kfinite$ also hold in $M_K$.
    We omit them here.
    

\end{definition}


Now we are in a good shape to prove Theorem~\ref{thm:faithfulness-finite}.

\begin{proof}[Proof Sketch of Theorem~\ref{thm:faithfulness-finite}]\quad
	
	Step 1 (The ``$\Rightarrow$'' part). 
	
	We prove this by simply mimicking the proof of $T \vdash \varphi$ in $\Kfinite$.
	
	Step 2 (The ``$\Leftarrow$'' part).
	
	Let us fix a finite matching logic theory $T = (S, \Sigma, A)$, a $\Sigma$-pattern $\varphi$, and an encoding $e$, and assume that $\Kfinite \vdash \Kdeduce(\hat{T}, \hat{\varphi})$.
	Since the matching logic proof system is sound, the interpretation of $\Kdeduce(\hat{T}, \hat{\varphi})$ should hold in the canonical model $M_K$:
	$$ \Kdeduce_M(\hat{T}, \hat{\varphi}) = \{ \star \}. $$
	By definition, this means that
	$$\Bracket{\hat{T}} \vdash \Bracket{\hat{\varphi}}.$$
	
	Finally notice that by construction of encoding, lifting, and the semantics bracket, there is an isomorphism between $T$ and  $\Bracket{\hat{T}}$, so from $\Bracket{\hat{T}} \vdash \Bracket{\hat{\varphi}}$ we have
	$$T \vdash \varphi.$$
	
	\fbox{\begin{minipage}{35em}\color{blue}\small
	The following a snapshot of what we had on the board:
	
	Step 2.1. Fix a finite matching logic theory $T = (S, \Sigma, A)$ and a $\Sigma$-pattern $\varphi$. 
	
	Step 2.2. Build a model $M_{T}$ based on $T = (S, \Sigma, A)$.
	
	Step 2.3. Show that $M_T$ is a model of $\Kfinite$.
	
	
	
	Step 2.5. Interpret $\Kdeduce(\hat{T}, \hat{\varphi})$ in $M_T$ and get $T \vDash \varphi$.
    \end{minipage}}
\end{proof}

\section{Matching Logic Theory of Matching Logic: With Meta-Variables}

\section{Matching Logic Theory of Matching Logic: With Parameters}

\section{Get Material From Here}

Matching logic imposes no restrictions on the cardinality of the set of
sorts $S$, of the set of symbols $\Sigma$, or of the set of patterns $A$
in a theory $(S,\Sigma,A)$.
In practice, however, we need a finite mechanism to describe such theories
in order to mechanically reason about them using a computer.
In the vast universe of possibilities, we here propose one particular approach
that we found useful, convenient and sufficient in our semantics engineering
efforts.
Specifically:
\begin{itemize}
\item
We restrict the infinite sets of sorts to ones which can be described with
a finite set of \emph{parametric} sorts, where the parameters range over
other sorts.
For example, $S=\{\Nat,\parametric{\List}{X}\}$ describes the infinite set
of sorts
$S=\{\Nat, \parametric{\List}{\Nat}, \parametric{\List}{\parametric{\List}{\Nat}}, ...\}$.

\end{itemize}

From here on, unless otherwise specified, when we say \emph{set} we mean
a \emph{recursively enumerable set}, i.e., a set that can be generated
algorithmically (not to be confused with the weaker notion of a
countable\unsure{countable may suffice, we'll need to understand how it is in FOL}
set, which only means that it has a cardinal no larger than
$\aleph_0$---either finite or in bijection with the set
of natural numbers).


In this section, we define a matching logic theory $K = (S_K, \Sigma_K, A_K)$ 
as \emph{the (reflective) calculus of matching logic},
where $S_K, \Sigma_K$, and $A_K$ are \emph{finite} sets of sorts,
symbols, and axioms,  respectively.



\section{The Kore Syntax}

We propose a language called Kore to specify matching logic theories.
The following is a list of a few features of Kore:
\begin{itemize}
	\item Kore does not support module-level operations such as module importation, 
	signature hiding, symbol renaming;
	\item Kore supports only the five basic matching logic constructors 
	(variables, symbol applications, conjunction, negation, and existential 
	quantifications), while it provides a keyword \textsf{alias} that allows to define other derivative connectives as syntactic sugar;
	\item Kore supports sort parametricity;
	\item more ...
\end{itemize}

The following is the grammar of the Kore language for finite theories:

\begin{grammar}\small
	<definition>    ::= \quad
	\alt `module' <module-expression> <declaration>$^*$ `endmodule'
	
	<declaration>   ::= \quad
	\alt <sort-declaration> 
	\alt <symbol-declaration> 
	\alt <axiom-declaration>
	\alt <alias-declaration>
	
	<sort-declaration> ::= \quad
	\alt `sort' <sort>
	\alt `hooked-sort' <sort> 
	
	<sort> ::= \quad
	\alt <atomic-sort> 
	\alt <parametric-sort>
	
	<parametric-sort> ::= \quad
	\alt <parametric-sort-constructor> `{' <sort-list> `}'
	
	<sort-list> ::= \quad 
	\alt <sort> 
	\alt <sort> `,' <sort-list>
	
	<atomic-sort> ::= "[A-Z][a-zA-Z0-9]"$^+$
	
	<sort-variable> ::= "[A-Z0-9]"$^+$
	
	<parametric-sort-constructor> ::= "[A-Z][a-zA-Z0-9]"$^+$
	
	<symbol-declaration> ::= \quad
    \alt `symbol' <symbol> <symbol-signature>
    \alt `hooked-symbol' <symbol> <symbol-signature>
    
    <symbol> ::= \quad
    \alt <nonparametric-symbol>
    \alt <parametric-symbol>
    
    <nonparametric-symbol> ::= "[a-zA-Z0-9]"$^+$
    
    <parametric-symbol> ::= \quad
    \alt <parametric-symbol-name> `{' <sort-list> `}'
    
    <parametric-symbol-name> ::= "[a-zA-Z0-9]"$^+$
	
	<symbol-signature> ::= \quad
	\alt `(' <sort-list> `)' `:' <sort>
	
	<axiom-declaration> ::= \quad
	\alt `axiom' <pattern>
	
	<pattern> ::= \quad
	\alt <variable-name> `:' <sort>
	\alt <symbol> `(' <pattern-list> `)'
	\alt `\\and' `(' <pattern> `,' <pattern> `,' <sort> `)'
	\alt `\\not' `(' <pattern> `,' <sort> `)' 
	\alt `\\exists' `(' <variable-name> `:' <sort> `,' <pattern> `,' <sort> `)'
	\alt "how to denote meta-variables?"
	
	<pattern-list> ::= \quad
	\alt `' 
	\alt <pattern> 
	\alt <pattern> `,' <pattern-list>
	
	<alias-declaration> ::= \quad
	\alt `alias' "todo here, check the following example of IMP."
\end{grammar}

The IMP programming language defined in Kore:

\begin{lstlisting}[language=kore]
    /* Define the definedness symbol ceil(),
     * which is parametric on sorts S1 and S2 */
    symbol ceil{S1, S2}({S1}) : {S2}
    
    /* Declare ceil(X) is an axiom, 
     * where X is a variable (of any sort) */
    axiom  ceil{S1, S2}(X:{S1})
    
    /* Define floor(P) as an alias of \not ceil(\not P) */
    alias  floor{_,_}(_) := \not(ceil{#1, #2}(\not(#3, #1), #2)
    
    /* Define \or(P, Q) as an alias */
    alias  \or(_,_,_) := \not(\and(\not(#1, #3), \not(#2, #3), #3), #3)
    
    /* Define \implies(P, Q) as an alias */
    alias  \implies(_,_,_) := \or(\not(#1, #3), #2, #3)
    
    /* Define \iff(P, Q) as an alias */
    alias  \iff(_,_,_) := \and(\implies(#1, #2, #3), \implies(#2, #1, #3), #3)
    
    /* Define P = Q as an alias of floor(P iff Q) */
    alias  \equals(_,_,_,_) := floor{#3,#4}(\iff(#1,#2,#3))
    
    /* Define universal quantification as an alias */
    alias  \forall(_:_,_,_) := \not(\exists(#1:#2,\not(#3,#4),#4), #4)
    
    /* Define Boolean algebra */
    hooked-sort   Bool
    hooked-symbol true()              : Bool
    hooked-symbol false()             : Bool
    hooked-symbol notBool(Bool)       : Bool
    hooked-symbol andBool(Bool, Bool) : Bool
    
    /* Symbol true() is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, true(), Bool, {S}), {S})
    
    /* Symbol false() is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, false(), Bool, {S}), {S})
    
    /* Symbol notBool is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, notBool(C:Bool), Bool, {S}), {S})
    
    /* Symbol andBool is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, andBool(C1:Bool, C2:Bool), Bool, {S}), {S})
    
    /* No-Junk axiom */
    axiom  \or(true(), false(), Bool)
    
    /* No-Overlap axiom */
    axiom  \not(\and(true(), false(), Bool), Bool)
    
    /* notBool(B) = not B */
    axiom  \equals(notBool(B:Bool), \not(B:Bool, Bool), Bool, {S})
    
    /* andBool(B, true) = B */
    axiom  \equals(andBool(B:Bool, true()), B:Bool, Bool, {S})
    
    /* andBool(B, false) = false */
    axiom  \equals(andBool(B:Bool, false()), false(), Bool, {S})
    
    /* Define Presburger arithmetic */
    hooked-sort   Nat
    hooked-symbol zero()         : Nat
    hooked-symbol succ(Nat)      : Nat
    hooked-symbol plus(Nat, Nat) : Nat
    hooked-symbol gte(Nat, Nat)  : Bool /* greater-than-or-equal-to */
    
    /* Symbol zero() is functional */
    axiom  \exists(X:Nat, \equals(X:Nat, zero(), Nat, {S}), {S})
    
    /* Symbol succ is functional */
    axiom  \exists(X:Nat, \equals(X:Nat, succ(Y:Nat), Nat, {S}), {S})
    
    /* Symbol plus is functional */
    axiom  \exists(X:Nat, \equals(X:Nat, plus(Y:Nat, Z:Nat), Nat, {S}), {S})
    
    /* Symbol gte is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, gte(Y:Nat, Z:Nat), Bool, {S}), {S})
    
    /* No-Junk axiom */
    axiom  \or(zero(), \exists(X:Nat, succ(X:Nat), Nat), Nat)
    
    /* No-Overlap axiom */
    axiom  \not(\and(zero(), \exists(X:Nat, succ(X:Nat), Nat), Nat), Nat)
    
    /* X + 0 = X */
    axiom  \equals(plus(X:Nat, zero()), zero(), Nat, {S})
    
    /* X + succ(Y) = succ(X + Y) */
    axiom  \equals(plus(X:Nat, succ(Y:Nat),
                   succ(plus(X:Nat, Y:Nat)),
                   Nat, {S})
                   
    /* Define parametric cons-lists */
    sort   List{S}
    symbol nil{S}()              : List{S}
    symbol cons{S}({S}, List{S}) : List{S}
    
    /* Axioms of functional symbols: nil and cons */
    axiom  \exists(L:List{S}, \equals(L:List{S}, nil{S}(), List{S}, {S1}), {S1})
    axiom  \exists(L:List{S}, \equals(L:List{S}, cons{S}(X:S, L0:List{S}), List{S}, {S1}), {S1})
    
    /* No-Junk and No-Overlap axioms */
    axiom  \or(nil{S}, \exists(X:S, \exists(L:List{S}, 
                       cons{S}(X:S, L:List{S}), List{S}), List{S}), List{S})
    axiom  \not(\and(nil{S}, \exists(X:S, \exists(L:List{S}, 
                             cons{S}(X:S, L:List{S}), List{S}), List{S}), List{S}), List{S})
    
    /* In the following we show how to define the semantics of IMP */
    
    /* Define all IMP program variables */
    sort   Id
    symbol a() : Id
    symbol b() : Id
    ... ...
    symbol z() : Id
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms */
    ... ...
                   
    /* Define the sort AExp of arithmetic expressions */
    sort   AExp
    
    /* syntax AExp  ::= Nat                    <---- NatToAExp    
     *                | Id                     <---- IdToAExp
     *                | AExp "+" AExp [strict] <---- plusAExp
     */
    symbol NatToAExp(Nat)       : AExp
    symbol IdToAExp(Nat)        : AExp
    symbol plusAExp(AExp, AExp) : AExp
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms:
       NatToAExp, IdToAExp, and plusAExp are constructors */
    ... ...
    
    /* Injection from Nat to AExp
     * NatToAExp(X) = NatToAExp(Y) implies X = Y */
    axiom  \implies(\equals(NatToAExp(X:Nat), NatToAExp(Y:Nat), AExp, {S}),
                    \equals(X:Nat, Y:Nat, Nat, {S}), 
                    {S})
   
    /* Injection from Id to AExp */
    axiom  \implies(\equals(IdToAExp(X:Id), IdToAExp(Y:Id), AExp, {S}),
                    \equals(X:Id, Y:Id, Id, {S}),
                    {S})

    /* Axiom of strictness: AExp "+" AExp [strict] */
    ??? ???
    
    /* Define Boolean expressions */
    sort   BExp
    
   /* syntax BExp  ::= Bool                       <---- BoolToBExp    
    *                | "!" BExp       [strict]    <---- notBExp
    *                | AExp ">=" AExp [seqstrict] <---- gteBExp
    */
    symbol BoolToBExp(Bool)     : BExp
    symbol notBExp(BExp)       : BExp
    symbol gteBExp(AExp, AExp) : BExp
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms:
       BoolToBExp, notBExp, and gteBExp are constructors. */
    ... ...
    
    /* Injection axioms */
    ... ...
    
    /* Axiom of strictness: "!" BExp       [strict] */
    ??? ???
    
    /* Axiom of strictness: AExp ">=" AExp [seqstrict] */
    ??? ???
    
    /* Define Block and Stmt */
    sort   Block
    sort   Stmt
    
    /* syntax Block ::= "{" "}"      <---- emptyBlock()
     *                | "{" Stmt "}" <---- CurlyBracket(Stmt)
     */
    symbol emptyBlock()       : Block
    symbol CurlyBracket(Stmt) : Block
    
    /* syntax Stmt  ::= Block
     *                | Id "=" AExp ";"            [strict(2)]
     *                | "if" "(" BExp ")"
     *                  Block "else" Block         [strict(1)]
     *                | "while" "(" BExp ")" Block
     *                | Stmt Stmt
     */
     
    symbol BlockToStmt(Block)      : Stmt
    symbol asgn(Id, AExp)          : Stmt
    symbol ite(BExp, Block, Block) : Stmt
    symbol while(BExp, Block)      : Stmt
    symbol seq(Stmt, Stmt)         : Stmt
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms of constuctors */
    ... ...
    
    /* Axiom of strictness: Id "=" AExp ";" [strict(2)] */
    ??? ???
    
    /* Axiom of strictness: "if" "(" BExp ")" Block "else" Block [strict(1)] */
    ??? ???
    
\end{lstlisting}

\subsection{Ignore Me}

\newcommand{\smalltt}[1]{\texttt{\small #1} }
\newcommand{\sort}{\smalltt{sort}}
\newcommand{\symb}{\smalltt{symbol}}
\newcommand{\axiom}{\smalltt{axiom}}

Sorts are declared using the \sort keyword, symbols are declared using the \symb keyword, and axioms are defined using the \axiom keyword.

\begin{Verbatim}[fontsize=\small]
    /* Example 1: One-Element */
    sort Element1
    symbol e() : Element1
    axiom  e()
\end{Verbatim}

\begin{Verbatim}[fontsize=\small]
    /* Example 2: Two-Element */
    sort Element2
    symbol e1() : Element2
    symbol e2() : Element2
    axiom  \not(\and(\not(e1()), \not(e2())))
    axiom  \not(\and(e1(), e2()))
\end{Verbatim}

Symbols can be parametric on sort variables, which are wrapped by curly brackets. 
Sort variables can be instantiated by any sort.

\begin{Verbatim}[fontsize=\small]
    /* Example 3: Identity-Function */
    symbol id({S}) : {S}
    axiom  \not(\and(X:{S},     \not(id(X:{S}))))
    axiom  \not(\and(id(X:{S}), \not(X:{S})))
\end{Verbatim}

Given the context where two sorts \smalltt{Element1} and \smalltt{Element2} are declared, the above is just a shorthand of

\begin{Verbatim}[fontsize=\small]
    /* Example 3': Identity-Function */
    symbol id(Element1) : Element1
    symbol id(Element2) : Element2
    axiom  \not(\and(X:Element1,     \not(id(X:Element1))))
    axiom  \not(\and(id(X:Element1), \not(X:Element1)))
    axiom  \not(\and(X:Element2,     \not(id(X:Element2))))
    axiom  \not(\and(id(X:Element1), \not(X:Element1)))
\end{Verbatim}

If a sort variable appears multiple times in a statement, only one of the appearances needs curly brackets.
Therefore, an alternative way to write Example~3 is
\begin{Verbatim}[fontsize=\small]
    /* Example 3'': Identity-Function */
    symbol id({S}) : S
    axiom  \not(\and(X:{S},     \not(id(X:S))))
    axiom  \not(\and(id(X:{S}), \not(X:S)))
\end{Verbatim}

If a variable is decorated with a sort variable, as in {\small\verb|X:{S}|}, the sort decoration can be omitted. Therefore, an alternative way to write Example 3 is
\begin{Verbatim}[fontsize=\small]
    /* Example 3''': Identity-Function */
    symbol id({S}) : S
    axiom  \not(\and(X,     \not(id(X))))
    axiom  \not(\and(id(X), \not(X)))
\end{Verbatim}

Symbols can be parametric on more than one sort variables.
\begin{Verbatim}[fontsize=\small]
    /* Example 4: Definedness */
    symbol ceil({S}) : {S'}
    axiom  ceil(X)
\end{Verbatim}

Use sort constructors and sort variables to declare parametric sorts.
\begin{Verbatim}[fontsize=\small]
    /* Example 5: Lists */
    sort List{S}
    symbol nil() : List{S}
    symbol cons(S, List{S}) : List{S}
    symbol length(List{S}) : Nat
\end{Verbatim}

Parametric sorts can take multiple sort variables.
\begin{Verbatim}[fontsize=\small]
    /* Example 6: Pairs */
    sort Pair{S, S'}
    symbol pairOf(S, S') : Pair{S, S'}
    symbol fst(Pair{S, S'}) : S
    symbol snd(Pair{S, S'}) : S'  
\end{Verbatim}

\paragraph{Example (Boolean Algebra).}
\begin{Verbatim}[fontsize=\small]
    sort Bool
    symbol true() : Bool
    symbol false() : Bool
    axiom  \or(true(), false())
    axiom  \not(\and(true(), false()))
    symbol andBool(Bool, Bool) : Bool
    axiom  \equals(andBool(true(), B), B)
    axiom  \equals(andBool(false(), B), false())
\end{Verbatim}



\section{Ignore Me}

\subsection{Syntax and Semantics of Kore}
\label{sec:syntax-of-kore}

\begin{Verbatim}[fontsize=\small]
// Namespaces for sorts, variables, metavariables,
// symbols, and Kore modules.
Sort           = String
VariableId     = String
MetaVariableId = String
Symbol         = String
ModuleId       = String

Variable       = VariableId:Sort
MetaVariable   = MetaVariableId::Sort

Pattern        = Variable | MetaVariable
               | \and(Pattern, Pattern)
               | \not(Pattern)
               | \exists(Variable, Pattern)
               | Symbol(PatternList)

Sentence       = import ModuleId
               | syntax Sort
               | syntax Sort ::= Symbol(SortList)
               | axiom Pattern
Sentences      = Sentence | Sentences Sentences

Module         = module ModuleId
                   Sentences
                 endmodule
\end{Verbatim}

In Kore syntax, the backslash ``\verb|\|'' is reserved for matching logic connectives and the sharp ``\verb|#|'' is reserved for the meta-level, i.e., the $K$ sorts and symbols. 
Therefore, the sorts $\KPred$, $\KString$, $\KSymbol$, $\KSort$, and 
$\KPattern$ in the calculus $K$ are denoted as \verb|#Bool|, \verb|#String|, 
\verb|#Symbol|, \verb|#Sort|, and \verb|#Pattern| in Kore respectively.
Symbols in $K$ are denoted in the similar way, too. 
For example, the constructor symbol $\Kvariable \colon \KString \times \KSort \to \KPattern$ is denoted as \verb|#variable| in Kore. 

A Kore module definition begins with the keyword \verb|module| followed by the name of the module-being-defined, and ends with the keyword \verb|endmodule|. The body of the definition consists of some \emph{sentences}, whose meaning are introduced in the following.

The keyword \verb|import| takes an argument as the name of the module-being-imported, and looks for that module in previous definitions. 
If the module is found, the body of that module is copied to the current module.
Otherwise, nothing happens. 
The keyword \verb|syntax| leads a \emph{syntax declaration}, which can be either a \emph{sort declaration} or a \emph{symbol declaration}.
Sorts declared by sort declarations are called \emph{object-sorts}, in comparison to the five \emph{meta-sorts}, \verb|#Bool|, \verb|#String|, \verb|#Symbol|, \verb|#Sort|, and \verb|#Pattern|, in $K$. 
Symbols whose argument sorts and return sort are all object-sorts (meta-sorts) are called \emph{object-symbols} (\emph{meta-sorts}).

Patterns are written in prefix forms. 
A pattern is called an \emph{object-pattern} (\emph{meta-pattern}) if all sorts and symbols in it are object (meta) ones.
Meta-symbols will be added to the calculus $K$, while object-sorts and object-symbols will not.
They only serve for the purpose to parse an object pattern. 

The keyword \verb|axiom| takes a pattern and adds an axiom to the calculus $K$.
If the pattern is a meta-pattern, it adds the pattern itself as an axiom.
If the pattern $\varphi$ is an object-pattern, it adds $\Bracket{\varphi}$ as an axiom to the calculus $K$.

Recall that we have defined the semantics bracket as
\begin{equation*}
\Bracket{\varphi} \equiv 
\left(\textit{deducible}\left(\mathit{lift}[\varphi]\right) = true\right),
\end{equation*}
where $\varphi$ is a pattern of the grammar in Figure~\ref{ml-grammar}.
However, here in Kore we allow $\varphi$ containing \emph{meta-variables}.
As a result, we modify the definition of the semantics bracket as $$\Bracket{\varphi} \equiv \mathit{mvsc}[\varphi] \to (deducible\left(\mathit{lift}[\varphi]\right) = true),$$
where the lifting function $\mathit{lift}[\_]$ and the meta-variable sort constraint $\mathit{mvsc}[\_]$ are defined in Algorithm~\ref{alg:liftingfunction} and~\ref{alg:mvsc}, respectively.
Intuitively, meta-variables in an object-pattern $\varphi$ are lifted to variables of the sort $\KPattern$ with the corresponding sort constraints. 
For example, the meta-variable $x \cln\cln s$ is lifted to a variable $x \cln \KPattern$ in $K$ with the constraint that $\KgetSort(x \cln \KPattern) = sort(s)$. The function $\mathit{mvsc}[\_]$ collects all such meta-variable sort constraint in an object-pattern is implemented in Algorithm~\ref{alg:mvsc}.

\begin{algorithm}
	\KwIn{An object-pattern $\varphi$.}
	\KwOut{The meta-representation (ASTs) of $\varphi$ in $K$}
	\uIf{$\varphi$ is $x \cln s$}{Return $\mathit{variable(x, sort(s))}$}
	\uElseIf{$\varphi$ is $x \cln \cln s$}{Return $x \cln \KPattern {\ \wedge\ } (\mathit{sort(s)} = \KgetSort(x \cln \KPattern)) $}
	\uElseIf{$\varphi$ is $\varphi_1 \wedge \varphi_2$}
	{Return $\Kand(\mathit{lift}[\varphi_1], \mathit{lift}[\varphi_2]$}
	\uElseIf{$\varphi$ is $\neg \varphi_1$}
	{Return $\Knot(\mathit{lift}[\varphi_1])$}
	\uElseIf{$\varphi$ is $\exists x \cln s . \varphi_1$}
	{Return $\Kexists(x, \mathit{sort(s)}, \mathit{lift}[\varphi_1])$}
	\uElseIf{$\varphi$ is $\sigma(\varphi_1,\dots,\varphi_n)$ and $\sigma \in \Sigma_{s_1,\dots,s_n,s}$}
	{Return $\Kapplication(\mathit{symbol}(\sigma, (\Ksort(s_1), \dots, \Ksort(s_n)), \Ksort(s)),$
	$\mathit{lift}[\varphi_1],\dots,\mathit{lift}[\varphi_n])$}
	\caption{Lifting Function $\mathit{lift}[\_]$}
	\label{alg:liftingfunction}
\end{algorithm}

\begin{algorithm}
	\KwIn{An object-pattern $\varphi$}
	\KwOut{The meta-variable sort constraint of $\varphi$}
	Collect in set $W$ all meta-variables appearing in $\varphi$\;
	Let $C = \emptyset$\;
	\ForEach{$x \cln \cln s \in W$}
	{$C = C \cup (\mathit{sort(s)} = \KgetSort(x \cln \KPattern))$}
	Return $\bigwedge C$\;
	\caption{Meta-Variable Sort Constraint Collection $\mathit{mvsc}$}
	\label{alg:mvsc}
\end{algorithm}


\subsection{Examples of Kore}
\label{sec:examples-of-kore}

\todo[inline, author=Xiaohong]{Add more examples and texts here.}

\paragraph{The {\small BOOL} module.}\quad
\begin{Verbatim}[fontsize=\small]
module BOOL
  syntax Bool
  syntax Bool ::= true | false | notBool(Bool)
                | andBool(Bool, Bool) | orBool(Bool, Bool)
  axiom \or(true(), false())
  axiom \exists(X:Bool, \equals(X:Bool, true()))
  axiom \equals(andBool(B1::Bool, B2::Bool), 
                andBool(B2::Bool, B1::Bool))
  axiom ... ...
endmodule
\end{Verbatim}

\paragraph{The {\small BOOL} module (desugared).}\quad
\begin{Verbatim}[fontsize=\small]
module BOOL
  axiom \equals(
    #true,
    #deducible(#or(#application(#symbol("true", #nilSort, #sort("Bool")),
                                #nilPattern), 
                   #application(#symbol("false", #nilSort, #sort("Bool")),
                                #nilPattern))))
  axiom \equals(
    #true,
    #deducible(#exists("X", #sort("Bool"), 
               #equals(#variable("X", #sort("Bool")), 
                       #application(#symbol("true", #nilSort, #sort("Bool")),
                                    #nilPattern)))))
  axiom \leftrightarrow(
    \and(\equals(#getSort(B1:Pattern), #sort("Bool")), 
         \equals(#getSort(B2:Pattern), #sort("Bool"))),
    \equals(
      #true,
      #deducible(#equals(#application(#symbol("andBool", 
                                              (#sort("Bool"), #sort("Bool"))
                                              #sort("Bool")), 
                                      (B1:Patern, B2:Pattern)), ---- TODO
                         #application(#symbol("andBool", 
                                              (#sort("Bool"), #sort("Bool"))
                                              #sort("Bool")), 
                                      (B2:Patern, B1:Pattern))))))
  axiom ... ...
endmodule
\end{Verbatim}

\paragraph{The {\small LAMBDA} module}\quad
\begin{Verbatim}[fontsize=\small]
module LAMBDA
  syntax Exp
  syntax Exp ::= app(Exp, Exp) | lambda0(Exp, Exp)
  syntax #Bool ::= isLTerm(#Pattern)

  axiom \equals(
    isLTerm(#variable(X:String, #sort("Exp"))), 
    true)
  axiom \equals(
    isLTerm(#application(
              #symbol("app", (#sort("Exp"), #sort("Exp")), #sort("Exp")),
              (E:Pattern, E':Pattern))),
    andBool(isLTerm(E:Pattern), isLTerm(E':Pattern)))
  axiom \equals(
    isLTerm(#exists(X:String, #sort("Exp"),
                    #application(#symbol("lambda0",
                                         (#sort("Exp"), #sort("Exp")),
                                         #sort("Exp")),
                                 (#variable(X:String, #sort("Exp")),
                                  E:Pattern))),
    isLTerm(E:Pattern))
  axiom \leftrightarrow(\equals(true, 
                         andBool(isLTerm(E:Pattern), 
                                 isLTerm(E':Pattern))),
                 \equals(true,
                         deducible(#equals(...1,
                                           ...2)))) 
endmodule
\end{Verbatim}


\bibliographystyle{abbrv}
\bibliography{refs}

\end{document}

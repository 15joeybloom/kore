\documentclass[UTF8,11pt]{article}

  \usepackage{fullpage}
  \usepackage[linesnumbered,ruled,vlined]{algorithm2e}

  %\usepackage{xcolor}
  \usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
  \usepackage{xargs}                      % Use more than one optional
                                          % parameter in a new commands

  % Select what to do with todonotes: 
  % \usepackage[disable]{todonotes} % notes not showed
  %  \usepackage[draft]{todonotes} % notes showed
  \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
  \newcommandx{\unsure}[2][1=]
    {\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}\xspace{}}
  \newcommandx{\change}[2][1=]
    {\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}\xspace{}}
  \newcommandx{\info}[2][1=]
    {\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
  \newcommandx{\improvement}[2][1=]
    {\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}\xspace{}}
  \newcommandx{\thiswillnotshow}[2][1=]
    {\todo[disable,#1]{#2}\xspace{}}

  % Select what to do with command \comment:  
  % \newcommand{\comment}[1]
      {}                                    %comment not showed
  \newcommand{\comment}[1]
    {\par {\bfseries \color{blue} #1 \par}} %comment showed
    
  \usepackage{amsmath}
  \usepackage{amssymb}
  
  \usepackage{amsthm}
  \usepackage{xspace}
  
  % Declare a global counter for theorem environments:
  \newcounter{thmcounter}
  
  % Define new theorem styles:
  \theoremstyle{plain}
  \newtheorem{theorem}[thmcounter]{Theorem}
  \newtheorem{corollary}[thmcounter]{Corollary}
  \newtheorem{lemma}[thmcounter]{Lemma}
  \newtheorem{proposition}[thmcounter]{Proposition}
  \theoremstyle{definition}
  \newtheorem{definition}[thmcounter]{Definition}
  \newtheorem{example}[thmcounter]{Example}
  \theoremstyle{remark}
  \newtheorem{remark}[thmcounter]{Remark}
  \newtheorem{notation}[thmcounter]{Notation}
  
  
  % Package for changing fonts in the Verbatim environment:
  \usepackage{xcolor}
  \usepackage{fancyvrb}
  
  % Package for writing captions for align environment:
  \usepackage{capt-of}
  
  % Package for URLs:
  \usepackage{hyperref}  
  
  % Package for tables:
  \usepackage[english]{babel}  
  
  % Define the colon ":" that is used in "x:s"
  % with less spacing around.
  \newcommand{\cln}{{:}}
 
  
  % Define ceiling and flooring symbols:
  \usepackage{mathtools}
  \DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
  \DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

  % Package for underlining and strikethrough texts.
  \usepackage[normalem]{ulem}
  
  % Define text over equality
  \usepackage{mathtools}
  \newcommand{\xeq}[1]
    {\stackrel{\mathclap{\normalfont\tiny\mbox{#1}}}{=}}
    
  % Package for display-mode quotations.
  \usepackage{csquotes}
  
  % Define double-bracket [[P]] (known as the semantics bracket)
  \usepackage{stmaryrd}
  \newcommand{\Bracket}[1]
    {\llbracket#1\rrbracket}
    
  % Package for writing inference rules and formal proofs
  \usepackage{proof}
  % Writing labels about inference rules
  \newcommand{\rl}[1]{\text{\scriptsize{(#1)}}}
  
  % Package for writing BNF syntax
  \usepackage{syntax}
  
  % Package for refering Section 3.1 as something like Section §3.1:
  \usepackage[utf8]{inputenc}
  \usepackage{cleveref}
  \crefname{section}{§}{§§}
  \Crefname{section}{§}{§§}

  \newcommand{\K}{\mbox{$\mathbb{K}$}\xspace}
  
  % Define sorts and symbols in the calculus K.
  
  % Sec 3.1 Truth
  \newcommand{\KPred}{\mathit{KPred}}
  
  %% We shouldn't need the follows.
  \newcommand{\Ktrue}{\mathit{Ktrue}}
  \newcommand{\Kfalse}{\mathit{Kfalse}}
  \newcommand{\KandBool}{\mathit{KandBool}}
  \newcommand{\KorBool}{\mathit{KorBool}}
  \newcommand{\KnotBool}{\mathit{KnotBool}}
  \newcommand{\KimpliesBool}{\mathit{KimpliesBool}}
  
  % Sec 3.2 Strings
  \newcommand{\KChar}{\mathit{KChar}}
  \newcommand{\KString}{\mathit{KString}}
  \newcommand{\Kepsilon}{\mathit{Kepsilon}}
  \newcommand{\KconsKString}{\mathit{KconsKString}}
  
  %% We shouldn't need the follows.  
  \newcommand{\Kconcat}{\mathit{Kconcat}}
  
  % Sec 3.3 Sorts and Symbols
  \newcommand{\KSort}{\mathit{KSort}}
  \newcommand{\Ksort}{\mathit{Ksort}}
  \newcommand{\KSymbol}{\mathit{KSymbol}}
  \newcommand{\Ksymbol}{\mathit{Ksymbol}}
  
  % Sec 3.4 Finite Lists
  \newcommand{\XList}{\mathit{XList}}
  \newcommand{\KnilXList}{\mathit{KnilXList}}
  \newcommand{\KconsXList}{\mathit{KconsXList}}
  \newcommand{\KappendXList}{\mathit{KappendXList}}
  \newcommand{\KinXList}{\mathit{KinXList}}
  \newcommand{\KdeleteXList}{\mathit{KdeleteXList}}
  \newcommand{\KPatternList}{\mathit{KPatternList}}
  \newcommand{\KnilKPatternList}{\mathit{KnilKPatternList}}
  \newcommand{\KconsKPatternList}{\mathit{KconsKPatternList}}
  \newcommand{\KappendKPatternList}{\mathit{KappendKPatternList}}
  \newcommand{\KinKPatternList}{\mathit{KinKPatternList}}
  \newcommand{\KdeleteKPatternList}{\mathit{KdeleteKPatternList}}
  \newcommand{\KSortList}{\mathit{KSortList}}
  \newcommand{\KnilKSortList}{\mathit{KnilKSortList}}
  \newcommand{\KconsKSortList}{\mathit{KconsKSortList}}
  \newcommand{\KappendKSortList}{\mathit{KappendKSortList}}
  \newcommand{\KinKSortList}{\mathit{KinKSortList}}
  \newcommand{\KdeleteKSortList}{\mathit{KdeleteKSortList}}
  %% Define l1 @ l2 for list concatenation.
  \newcommand{\at}{@}
  
  
  \newcommand{\Kdelete}{\mathit{delete}}
    

  
  

  \newcommand{\KSymbolList}{\mathit{KSymbolList}}
  
  
  \newcommand{\KPattern}{\mathit{KPattern}}
  \newcommand{\Kvariable}{\mathit{Kvariable}}
  \newcommand{\Kand}{\mathit{Kand}}
  \newcommand{\Kor}{\mathit{Kor}}
  \newcommand{\Kimplies}{\mathit{Kimplies}}
  \newcommand{\Kiff}{\mathit{Kiff}}
  \newcommand{\Knot}{\mathit{Knot}}
  \newcommand{\Kapplication}{\mathit{Kapplication}}
  \newcommand{\Kexists}{\mathit{Kexists}}
  \newcommand{\Kforall}{\mathit{Kforall}}
  \newcommand{\Kequals}{\mathit{Kequals}}
  \newcommand{\Kin}{\mathit{Kin}}
  \newcommand{\Kcontains}{\mathit{Kcontains}}
  \newcommand{\Ktop}{\mathit{Ktop}}
  \newcommand{\Kbottom}{\mathit{Kbottom}}
  \newcommand{\Kfloor}{\mathit{Kfloor}}
  \newcommand{\Kceil}{\mathit{Kceil}}
  
  % Mifix symbols
  \newcommand{\kand}{\wedge}
  \newcommand{\kor}{\vee}
  \newcommand{\kimplies}{\to}
  \newcommand{\kiff}{\leftrightarrow}
  \newcommand{\knot}{\neg}
  \newcommand{\kexists}{\exists}
  \newcommand{\kforall}{\forall}
  \newcommand{\kequals}{=}
  \newcommand{\kcontains}{\supseteq}
  \newcommand{\kin}{\in}
  \newcommand{\kfloor}{\floor}
  \newcommand{\kceil}{\ceil}
  \newcommand{\ktop}{\top}
  \newcommand{\kbottom}{\bot}
  
  \newcommand{\KgetFvs}{\mathit{KgetFvs}}
  \newcommand{\KfreshName}{\mathit{KfreshName}}
  
  \newcommand{\KSignature}{\mathit{KSignature}}
  \newcommand{\Ksignature}{\mathit{Ksignature}}
  
  \newcommand{\KwellFormed}{\mathit{KwellFormed}}
  \newcommand{\KgetSort}{\mathit{KgetSort}}
  \newcommand{\KisSort}{\mathit{KisSort}}
  \newcommand{\Ksubstitute}{\mathit{Ksubstitute}}
  
  \newcommand{\KTheory}{\mathit{KTheory}}
  \newcommand{\Ktheory}{\mathit{Ktheory}}
  
  \newcommand{\Kdeduce}{\mathit{Kdeduce}}
  
  % The italic font of "ceil" used in math mode.
  \newcommand{\cl}{\mathit{ceil}}
  
  % Use quotation marks "..." in math mode.
  \newcommand{\quot}[1]{\mathrm{``#1"}}

\newcommand{\Nat}{\textit{Nat}}
\newcommand{\List}{\textit{List}}
\newcommand{\parametric}[2]{{#1}\raisebox{.2ex}{\texttt{\footnotesize{\{}}}#2\raisebox{.2ex}{\texttt{\footnotesize{\}}}}}

  % Title and authors
  \title{The Semantics of \K}
  \author{Formal Systems Laboratory \\
          University of Illinois at Urbana-Champaign}

\begin{document}

\maketitle

\info{Please feel free to contribute to this report in all ways.
You could add new contents, remove redundant ones, refactor and
organize the texts, and correct typos, but please follow the FSL
rules for editing, though; e.g., $<$80 characters per line,
each sentence on a new line, etc. }

\section{Introduction}
\label{sec:introduction}

\K is a best effort realization of matching logic~\cite{rosu-2017-lmcs}.
Matching logic allows us to mathematically define arbitrarily infinite
theories, which are not in general possible to describe finitely.
\K proposes a finitely describable subset of matching logic theories.
Since its inception in 2003 as a notation within
Maude~\cite{clavel-et-al99a} convenient for teaching programming
languages~\cite{rosu-2003-cs322}, until recently \K's semantics was explained
either by translation to rewriting logic \cite{meseguer-1992-tcs} or by
translation to some form of graph rewriting~\cite{serbanuta-rosu-2012-icgt}.
These translations not only added clutter and came at a loss of part of the
intended meaning of \K, but eventually turned out to be a serious limiting
factor in the types of theories and languages that could be defined.
Matching logic was specifically created and developed to serve as a
logical, semantic foundation for \K, after almost 15 years of experience
with using \K to define the formal semantics of real-life programming
languages, including
C~\cite{ellison-rosu-2012-popl,hathhorn-ellison-rosu-2015-pldi},
Java~\cite{bogdanas-rosu-2015-popl},
JavaScript~\cite{park-stefanescu-rosu-2015-pldi},
Python~\cite{guth-2013-thesis,pltredex-python},
PHP~\cite{k-php},
EVM~\cite{hiraidefining,hildenbrandt-saxena-zhu-rodrigues-daian-guth-rosu-2017-tr}.

Matching logic allows us to define \emph{theories} $(S,\Sigma,A)$ consisting
of potentially infinite sets of \emph{sorts} $S$, of \emph{symbols}
$\Sigma$ over sorts in $S$ (also called $S$-symbols), and of \emph{patterns}
$A$ built with symbols in $\Sigma$ (also called $\Sigma$-patterns),
respectively, and provides models that interpret the symbols
relationally, which in turn yield a \emph{semantic validity} relation
$(S,\Sigma,A)\models\varphi$ between theories $(S,\Sigma,A)$ and
$\Sigma$-patterns $\varphi$.
Matching logic also has a Hilbert-style complete proof system, which allows
us to derive new patterns $\varphi$ from given theories $(S,\Sigma,A)$,
written $(S,\Sigma,A)\vdash\varphi$.
When the sorts and signature are understood, we omit them; for example,
the completeness of matching logic then states that for any matching logic
theory $(S,\Sigma,A)$ and any $\Sigma$-pattern $\varphi$, we have
$A \models \varphi$ iff $A \vdash \varphi$.

...\improvement{Will add more here as we finalize the notation.
we need some convincing example.  Maybe parametric maps?}

\section{Matching Logic}
\label{sec:matching-logic}

\newcommand{\Var}{\textit{Var}}

Here we recall basic matching logic notions from~\cite{rosu-2017-lmcs}.
Assume a matching logic \emph{signature} $(S, \Sigma)$, where $S$ is the
set of its \emph{sorts} $S$ and $\Sigma$ is the set of its \emph{symbols}.
For each sort $s \in S$, assume a set $\Var_s$ of \emph{variables} of
sort $s$.
We partition $\Sigma$ in sets $\Sigma_{s_1 \ldots s_n, s}$ of symbols
of \emph{arity} $s_1\ldots s_n,s$, where
$s_1,\ldots, s_n, s \in S$.
\emph{Patterns} of sort $s \in S$ are generated by the following grammar:
\begin{align*}
\varphi_s \Coloneqq\  &x \cln s \quad \text{where $x \in \Var$} \\
\mid\  &\sigma(\varphi_{s_1},...,\varphi_{s_n}) \quad\
\text{where $\sigma \in \Sigma_{s_1 \ldots s_n, s}$ and
$\varphi_{s_1},...,\varphi_{s_n}$ of appropriate sorts} \\
\mid\  &\varphi_s \wedge \varphi_s \\
\mid\  &\neg \varphi_s \\
\mid\  &\exists x \cln s' . \varphi_s \quad \text{where $x \in N$ and $s' \in S$}
\end{align*}
\begingroup\vspace*{-\baselineskip}
\captionof{figure}{The grammar of matching logic patterns.}
\label{ml-grammar}
\vspace*{\baselineskip}\endgroup

The grammar above only defines the syntax of (well-formed) patterns of sort
$s$.
It says nothing about their semantics.
For example, patterns $x\cln s \wedge y \cln s$ and
$y\cln s \wedge x \cln s$ are distinct elements in the language
of the grammar, in spite of them being semantically/provably equal
in matching logic.
Derived constructs like $\vee$, $\rightarrow$, $\leftrightarrow$,
$\forall$, etc., can be defined as aliases as usual (e.g.,
$\varphi_1 \vee \varphi_2 \equiv \neg(\neg \varphi_1 \wedge \neg\varphi_2)$).

For notational convenience, we take the liberty to use mix-fix syntax for
operators in $\Sigma$,
parentheses for grouping, and omit variable sorts when understood.
For example, if $\Nat \in S$ and
$\_+\_, \_*\_ \in \Sigma_{\Nat \times \Nat, \Nat}$
then we may write $(x + y)*z$ instead of
$\_*\_(\_+\_(x\cln\Nat,y\cln\Nat),z\cln\Nat)$.
More notational convenience and conventions will be introduced along the way
as we use them. 

A matching logic \emph{theory} is a triple $(S, \Sigma, A)$ where
$(S,\Sigma)$ is a signature and $A$ is a set of patterns called \emph{axioms}.
Like in many logics, sets of patterns may be presented as \emph{schemas}
making use of meta-variables ranging over patterns, sometimes constrained
to subsets of patterns using side conditions.
For example:
$$
\begin{array}{rl}
\varphi[\varphi_1/x] \wedge (\varphi_1 = \varphi_2) \rightarrow \varphi[\varphi_2/x]
&\textrm{where $\varphi$ is any pattern and $\varphi_1$, $\varphi_2$} \\
& \textrm{are any patterns of same sort as $x$}
\\[2ex]
\forall x . \varphi \rightarrow \varphi[t/x]
&\textrm{where $t$ is any \emph{syntactic pattern}, or \emph{term}}, \\
& \textrm{i.e., containing only variables and symbols}
\\[2ex]
(\lambda x . \varphi)\varphi' = \varphi[\varphi'/x]
& \textrm{where $\varphi$, $\varphi'$ are patterns containing only}
\\
& \textrm{variables, $\lambda$ binders and application symbols}
\\[2ex]
\varphi_1 \mathrel{\texttt{+}} \varphi_2 = \varphi_1 +_\Nat \varphi_2
& \textrm{where $\varphi$, $\varphi'$ are \emph{ground} syntactic patterns}
\\
&\textrm{of sort $\Nat$, that is, patterns built only}
\\
&\textrm{with symbols \texttt{zero} and \texttt{succ}}
\\[2ex]
(\varphi_1 \rightarrow \varphi_2) \rightarrow
(\varphi[\varphi_1 / x] \rightarrow \varphi[\varphi_2 / x])
& \textrm{where $\varphi$ is a \emph{positive context in $x$}, that is,}
\\
& \textrm{a pattern
containing only one occurrence}
\\
&\textrm{of $x$ with no negation ($\neg$) on the path to}
\\
&\textrm{$x$, and where $\varphi_1$, $\varphi_2$ are any patterns}
\\
&\textrm{having the same sort}
\end{array}
$$

One of the major goals of this paper is to propose a formal language,
and an implementation, that allow us to finitely specify potentially
infinite matching logic theories presented with finitely many pattern schemas.

\improvement{We should also add the semantics here: models, $M \models_{(S,\Sigma)} A$,
$(S,\Sigma,A) \models \varphi$.}

\section{Matching Logic Theory of Matching Logic: Finite Case}

\newcommand{\Kfinite}{{K_\text{finite}}}

\todo[inline, author=Xiaohong]{I am working on this section, so please don't touch it to prevent conflicts.}

\emph{Finite matching logic theories} are theories that have a finite number of sorts, symbols, and axioms.
In this section, we present a matching logic theory $\Kfinite = \langle S_\Kfinite, \Sigma_\Kfinite, F_\Kfinite \rangle$ as \emph{the theory of finite matching logic theories}, in which $S_\Kfinite$ is a finite set of sorts, $\Sigma_\Kfinite$ is a finite set of symbols, and $F_\Kfinite$ is a finite set of axioms.
Notice that $\Kfinite$ itself is a finite matching logic theory.

\subsection{Truth}
\improvement
{Xiaohong: I don't know what goes wrong but this section needs improvement.}
A sort $\KPred$ is introduced, as in~\cite{rosu-2017-lmcs}, to capture predicate logic.
Patterns of sort $\KPred$ are constructed using \emph{predicate symbols} together the regular matching logic connectives.
A symbol is said to be a {predicate symbol} if its return sort is $\KPred$.
Predicate symbols in $\Kfinite$ will be defined in later sections when we introduce them.

\begin{notation}
	If $b$ is a $\KPred$ pattern, we take the freedom to write $b$ instead of $b = \top_\KPred$, so that $\KPred$ patterns can be used in any sort context.
\end{notation}





\subsection{Strings}
The sort $\KChar$ is the sort for characters. It has the following $26 + 26 + 10 = 62$ functional symbols as constructors:
\begin{center}
	\begin{tabular}{c c c}
		$\quot{a} \colon \to \KChar$ & $\quot{b} \colon \to \KChar$ & $\quot{c} \colon \to \KChar$ \\
		$\cdots$ & $\cdots$ & $\cdots$ \\
		$\quot{x} \colon \to \KChar$ & $\quot{y} \colon \to \KChar$ & $\quot{z} \colon \to \KChar$ \\
		$\quot{A} \colon \to \KChar$ & $\quot{B} \colon \to \KChar$ & $\quot{C} \colon \to \KChar$ \\
		$\cdots$ & $\cdots$ & $\cdots$ \\
		$\quot{X} \colon \to \KChar$ & $\quot{Y} \colon \to \KChar$ & $\quot{Z} \colon \to \KChar$ \\
		$\quot{0} \colon \to \KChar$ & $\cdots$ & $\quot{9} \colon \to \KChar$. 
	\end{tabular}
\end{center}

The sort $\KString$ is the sort for strings, regarded as cons-lists of characters.
The two constructors of sort $\KString$ are functional symbols:
\begin{align*}
  & \Kepsilon \colon \to \KString,
  \\
  & \mathit{KconsKString} \colon \KChar \times \KString \to \KString.
\end{align*}

\begin{notation}
	As a convention, strings are often wrapped with quotation marks. 
	For example, instead of writing
	$$
	\KconsKString(\quot{a}, \KconsKString(\quot{b}, \KconsKString(\quot{c}, \Kepsilon))),
	$$
	we simply write $\quot{abc}$.
	The empty string $\Kepsilon$ is often written as $\quot{}$ or $\epsilon$.
	\unsure
	{Xiaohong: We may not need this abbreviation, though. Let's keep it here for a while. }
\end{notation}




\subsection{Matching Logic Sorts and Symbols}

The sort $\KSort$ is the sort for matching logic sorts.
The only constructor of the sort $\KSort$ is the functional symbol:
\begin{equation*}
\Ksort \colon \KString \to \KSort,
\end{equation*}
where the argument is called the \emph{name} or \emph{identity} of the sort. 

The sort $\KSymbol$ is the sort for matching logic symbols.
The only constructor of the sort $\KSymbol$ is the functional symbol:
\begin{equation*}
\Ksymbol \colon \KString \times \KSortList \times \KSort \to \KSymbol,
\end{equation*}
where the first argument is the \emph{name} of the symbol, and the rest arguments are the \emph{argument sorts} and the \emph{return sort} of the symbol. 

\subsection{Finite Lists}

For sorts $\KSort$, $\KSymbol$, and $\KPattern$\footnote{The sort $\KPattern$ is defined in Section~\cref{sec:matching-logic-patterns}.}
in $S_\Kfinite$,
we define sorts $\KSortList$, $\KSymbolList$, and $\KPatternList$ to be the sorts of finite lists over them, respectively.
For any sort $X$ where
$$
X \in \{\KSort, \KSymbol, \KPattern\},
$$
the sort $\XList$ is in $S_\Kfinite$, and the following functional constructors of sort $\XList$ are in $\Sigma_\Kfinite$:
\begin{align*}
  & \KnilXList \colon \to \XList,
  \\
  & \KconsXList \colon \mathit{X} \times \XList \to \XList.
\end{align*}

\begin{notation}
	To write lists expression more compactly, we adopt the following abbreviations:
	\begin{equation*}
	  x_1, x_2, \dots, x_n \equiv \KconsXList(x_1, \KconsXList(x_2, \dots\KconsXList(x_n, \KnilXList)\dots)).
	\end{equation*}
\end{notation}

Common operations on lists can be defined as functional symbols on $\XList$.
The symbol $$\KappendXList \colon \XList \times \XList \to \XList$$ \unsure{We might not need $\KappendXList$ at all, but let us keep it here for while in case we need it later.}
takes two lists and returns the concatenation of them, with two axioms:
\begin{align*}
  & \KappendXList(\KnilXList, l) = l,
  \\
  & \KappendXList(\KconsXList(x, l_0), l) = \KconsXList(x, \KappendXList(l_0, l)).
\end{align*}
\begin{notation}
	We adopt the following notation abbreviation for list concatenation:
	\begin{equation*}
	  l_1 \at l_2 \equiv \KappendXList(l_1, l_2).
	\end{equation*}
\end{notation}

The predicate symbol $$\KinXList \colon \mathit{X} \times \XList \to \KPred$$
takes an element and a list, and decides whether the element is a member of the list or not. The two axioms for $\KinXList$ are:
\begin{align*}
  & \neg \KinXList(x, \KnilXList),
  \\
  & \KinXList(x, \KconsXList(y, l)) = (x = y) \vee \KinXList(x, l).
\end{align*}

The functional symbol $$\KdeleteXList \colon \mathit{X} \times \XList \to \KPred$$
takes an element and a list, and returns the list in which all appearances of the element has been deleted, and the order of remaining elements does not change.
It is axiomatized by the next two axioms:
\begin{align*}
  & \KdeleteXList(x, \KnilXList) = \KnilXList,
  \\
  & \KdeleteXList(x, \KconsXList(y, l))
  \\
  & = ((x = y) \wedge \KdeleteXList(x, l)) \vee ((x \neq y) \wedge \KconsXList(x, \KdeleteXList(x, l))).
\end{align*}

\subsection{Matching Logic Patterns}
\label{sec:matching-logic-patterns}

The sort $\KPattern$ is the sort for matching logic patterns.
It has five constructors:
\begin{align*}
  & \Kvariable \colon \KString \times \KSort \to \KPattern,
  \\
  & \Kapplication \colon \KSymbol \times \KPatternList \to \KPattern,
  \\
  & \Kand  \colon \KPattern \times \KPattern \times \KSort \to \KPattern,
  \\
  & \Knot \colon \KPattern \times \KSort \to \KPattern,
  \\
  & \Kexists \colon \KString \times \KSort \times \KPattern \times \KSort \to \KPattern. 
\end{align*}
Apart from the five constructor symbols, the sort $\KSort$ also has the following functional symbols:
\begin{align*}
  & \Kor \colon \KPattern \times \KPattern \times \KSort \to \KPattern,
  \\
  & \Kimplies \colon \KPattern \times \KPattern \times \KSort \to \KPattern,
  \\
  & \Kiff \colon \KPattern \times \KPattern \times \KSort \to \KPattern,
  \\
  & \Kforall \colon \KString \times \KSort \times \KPattern \times \KSort \to \KPattern,
  \\
  & \Kceil \colon \KPattern \times \KSort \times \KSort \to \KPattern,
  \\
  & \Kfloor \colon \KPattern \times \KSort \times \KSort \to \KPattern,
  \\
  & \Kequals \colon \KPattern \times \KPattern \times \KSort \times \KSort \to \KPattern,
  \\
  & \Kin \colon \KPattern \times \KPattern \times \KSort \times \KSort \to \KPattern,
  \\
  & \Ktop \colon \KSort \to \KPattern,
  \\
  & \Kbottom \colon \KSort \to \KPattern.
\end{align*}

\begin{notation}\label{notation:variables-about-KPattern}
	As a convention, we use $\varphi$ and $\psi$ for $\KPattern$ variables, $x$ for $\KString$ variables, and $s$ for $\KSort$ variables.  
\end{notation}

Functional symbols that do not belong to the five constructors of $\KPattern$ are called \emph{derived connectives of $\KPattern$}, and they are axiomatized by the following axioms:
\begin{align*}
  & \Kor(\varphi, \psi, s) = \Knot(\Kand(\Knot(\varphi, s), \Knot(\psi, s), s), s),
  \\
  & \Kimplies(\varphi, \psi, s) = \Kor(\Knot(\varphi, s), \psi, s),
  \\
  & \Kiff(\varphi, \psi, s) = \Kand(\Kimplies(\varphi, \psi, s), \Kimplies(\psi, \varphi, s), s),
  \\
  & \Kforall(x, s_1, \varphi, s_2) = \Knot(\Kexists(x, s_1, \Knot(\varphi, s_2), s_2), s_2),
  \\
  & \Kceil(\varphi, s_1, s_2) =
  \\
  & \Kapplication(\Ksymbol(\quot{ceil}, \KconsKSortList(s_1, \KnilKSortList), s_2), \varphi),
  \\
  & \Kfloor(\varphi, s_1, s_2) = \Knot(\Kceil(\Knot(\varphi, s_1), s_1, s_2), s_2),
  \\
  & \Kequals(\varphi, \psi, s_1, s_2) = \Kfloor(\Kiff(\varphi, \psi, s_1), s_1, s_2),
  \\
  & \Kin(\varphi, \psi, s_1, s_2) = \Kfloor(\Kimplies(\varphi, \psi, s_1), s_1, s_2),
  \\
  & \Ktop(s) = \Kexists(x, s, \Kvariable(x, s), s),
  \\
  & \Kbottom(s) = \Knot(\Ktop(s), s).
\end{align*}

\begin{notation}
	As one may have already noticed, patterns of sort $\KPattern$ get huge rather quickly.
	The following notation conventions are adopted to write $\KPattern$ patterns in a more compact way, by putting a bar upon their normal mixfix forms:
	\begin{align*}
	  & \overline{x \cln s} \equiv \Kvariable(x, s),
	  \\
	  & \overline{\sigma(\varphi_1, \dots, \varphi_n)} \equiv \Kapplication(\sigma, (\varphi_1, \dots, \varphi_n)),
	  \\
	  & \overline{\varphi \wedge_s \psi} \equiv \Kand(\varphi, \psi, s),
	  \\
	  & \overline{\neg_s \varphi} \equiv \Knot(\varphi, s),
	  \\
	  & \overline{\exists_{s_1}^{s_2} x . \varphi} \equiv \Kexists(x, s_1, \varphi, s_2),
	  \\
	  & \overline{\varphi \vee_s \psi} \equiv \Kor(\varphi, \psi, s),
	  \\
	  & \overline{\varphi \to_s \psi} \equiv \Kimplies(\varphi, \psi, s),
	  \\
	  & \overline{\varphi \leftrightarrow_s \psi} \equiv \Kiff(\varphi, \psi, s),
	  \\
	  & \overline{\forall_{s_1}^{s_2} x . \varphi} \equiv \Kforall(x, s_1, \varphi, s_2),
      \\
      & \overline{\ceil{\varphi}_{s_1}^{s_2}} \equiv \Kceil(\varphi, s_1, s_2),
      \\
      & \overline{\floor{\varphi}_{s_1}^{s_2}} \equiv \Kfloor(\varphi, s_1, s_2),
      \\
      & \overline{\varphi =_{s_1}^{s_2} \psi} \equiv \Kequals(\varphi, \psi, s_1, s_2),
      \\
      & \overline{\varphi \in_{s_1}^{s_2} \psi} \equiv \Kin(\varphi, \psi, s_1, s_2),
      \\
      & \overline{\top_s} \equiv \Ktop(s),
      \\
      & \overline{\bot_s} \equiv \Kbottom(s).
	\end{align*}
\end{notation}

Apart from the five constructors and derived connectives introduced above, the sort $\KPattern$ also has some common operators defined as functional symbols.
They are defined and axiomatized in this section, too.

The functional symbol 
$$\KgetFvs \colon \KPattern \to \KPatternList$$
traverses the argument pattern and collects all its free variables. 
It has the following axioms:
\begin{align*}
  & \KgetFvs(\overline{x \cln s}) = \overline{x \cln s},
  \\
  & \KgetFvs(\overline{\sigma(\varphi_1, \dots, \varphi_n)}) = \KgetFvs(\varphi_1), \dots, \KgetFvs(\varphi_n),
  \\
  & \KgetFvs(\overline{\varphi \kand_s \psi}) = \KgetFvs(\varphi), \KgetFvs(\psi),
  \\
  & \KgetFvs(\overline{\knot_s \varphi}) = \KgetFvs(\varphi),
  \\
  & \KgetFvs(\overline{\kexists_{s_1}^{s_2} x . \varphi}) = \KdeleteKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi)).
\end{align*}

The functional symbol
$$\KfreshName \colon \KPatternList \to \KString$$ 
generates a variable name that does not occur free in the argument patterns.
It has the following axiom:
\begin{align*}
\neg(\KinKPatternList(\Kvariable(\KfreshName(\varphi_1,\dots,\varphi_n), s), (\KgetFvs(\varphi_1),\dots,\KgetFvs(\varphi_n)))).
\end{align*}

The functional symbol
$$\Ksubstitute \colon \KPattern \times \KPattern \times \KPattern \to \KPattern$$
takes a target pattern $\varphi$, a ``replace''-pattern $\psi$, and a ``find''-pattern $\overline{x \cln s}$, and returns $\varphi[\psi / x \cln s]$.
The symbol $\Ksubstitute$ expects the third argument to be of the form $\Kvariable(x, s)$, and will ``get stuck'' if otherwise.
\improvement{Does not look good here. Need improvement.}

\begin{notation}
	We abbreviate $\Ksubstitute(\varphi, \psi, x \cln s)$ as 
	$\overline{\varphi[\psi / x \cln s]}$.
\end{notation}

The function $\Ksubstitute$ has the following axioms:
\begin{align*}
  & \overline{x \cln s_1 [\psi / y \cln s_2]} = ((\overline{x \cln s_1} = \overline{y \cln s_2}) \wedge \psi) \vee ((\overline{x \cln s_1} \neq \overline{y \cln s_2}) \wedge \overline{x \cln s_1}),
  \\
  & \overline{\sigma(\varphi_1, \dots, \varphi_n) [\psi / x \cln s]} = \overline{\sigma(\varphi_1[\psi / x \cln s], \dots, \varphi_n[\psi / x \cln s])},
  \\
  & \overline{(\varphi_1 \wedge_s \varphi_2) [\psi / x \cln s']} = \overline{\varphi_1[\psi / x \cln s'] \wedge_s \varphi_2[\psi / x \cln s']},
  \\
  & \overline{(\neg_s \varphi)[\psi / x \cln s']} = \overline{\neg_s \varphi[\psi / x \cln s']},
  \\
  & \overline{(\kexists_{s_1}^{s_2}x . \varphi)[\psi/y \cln s_3]} = \exists z . (z = \KfreshName(\varphi, \psi, \overline{x \cln s_1})) \wedge \overline{\kexists_{s_1}^{s_2} z . (\varphi[z/x \cln s_1][\psi/y \cln s_3])}.
\end{align*}

\subsection{Finite Matching Logic Signatures}

The sort $\KSignature$ is the sort for finite matching logic signatures, and it has just one constructor symbol:
\begin{equation*}
\Ksignature \colon \KSortList \times \KSymbolList \to \KSignature,
\end{equation*}
which takes a finite list of sorts and a finite list of symbols as arguments, and returns the corresponding finite signature.

\begin{notation}
	As a convention, we use $\Sigma$ for $\KSignature$ variables. 
	We use~$S$ for~$\KSortList$ variables and $\Sigma$ for $\KSymbolList$ variables if they appear as in~$\Ksignature(S, \Sigma)$.
	We often abbreviate $\Ksignature(S, \Sigma)$ as $\langle S, \Sigma \rangle$. \unsure{I use the angle parenthesis here. Maybe should just use normal parenthesis.}
\end{notation}

Common operators on $\KSignature$ and $\KPattern$ can then be easily defined.
For example, the predicate symbol 
$$\KwellFormed \colon \KPattern \times \KSignature \to \KPred$$ 
takes a pattern and a finite signature, and decides whether the pattern is a \emph{well-formed} one in the given signature.
The partial function
$$\KgetSort \colon \KPattern \times \KSignature \rightharpoonup \KSort$$
takes a pattern and a finite signature, and returns the sort of the pattern in the given signature if the pattern is well-formed.
Otherwise, it returns $\bot_\KSort$.
The symbols $\KwellFormed$ and $\KgetSort$ are axiomatized by the following axioms:
\begin{align*}
  &\KwellFormed(\overline{x \cln s}, \langle S, \Sigma \rangle) = \KinKSortList(s, S),
  \\
  & \KwellFormed(\overline{\varphi \kand_s \psi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s) \wedge (\KgetSort(\psi, \Sigma) = s),
  \\
  & \KwellFormed(\overline{\knot_s \varphi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s),
  \\
  & \KwellFormed(\overline{\sigma(\varphi_1, \dots, \varphi_n)}, \Sigma) = TODO,
  \\
  & \KwellFormed(\overline{\kexists_{s_1}^{s_2} x . \varphi}, \langle S, \Sigma \rangle) = \KinKSortList(s_1, S) \wedge (\KgetSort(\varphi, (S, \Sigma)) = s_2),
  \\
  & \KgetSort(\overline{x \cln s}, \langle S, \Sigma \rangle) = (s \in S) \wedge s,
  \\
  & \KgetSort(\overline{\varphi \kand_s \psi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s) \wedge (\KgetSort(\psi, \Sigma) = s) \wedge s,
  \\
  & \KgetSort(\overline{\knot_s \varphi}, \Sigma) = (\KgetSort(\varphi, \Sigma) = s) \wedge s,
  \\
  & \KgetSort(\overline{\sigma(\varphi_1,\dots,\varphi_n)}, \langle S, \Sigma \rangle) = (TODO) \wedge s,
  \\
  & \KgetSort(\overline{\kexists_{s_1}^{s_2} x . \varphi}, \Sigma) = \KinKSortList(s_1, S) \wedge (\KgetSort(\varphi, \Sigma) = s_2) \wedge s_2.
\end{align*}

\subsection{Finite Matching Logic Theories}

The sort $\KTheory$ is the sort of finite matching logic theories. The only constructor symbol is 
$$\Ktheory \colon \KSignature \times \KPatternList \to \KTheory,$$
which takes a finite signature and a finite list of patterns as axioms, and returns the finite matching logic theory. 

\begin{notation}
	As a convention, we use $F$ for $\KPatternList$ variables as it appears in $\Ktheory(\Sigma, F)$, which is often abbreviated as $\langle \Sigma, F \rangle$. The theory $\langle \langle S, \Sigma \rangle, F \rangle$ is often abbreviated to just $\langle S, \Sigma, F \rangle$, too. We use $T$ for $\KTheory$ variables.  \unsure{Same here. Angle parenthesis versus regular parenthesis.}
\end{notation}

\subsection{Matching Logic Proof System}

A sound and complete proof system has been introduced in~\cite{rosu-2017-lmcs}.
In this section we define the predicate symbol $\Kdeduce$ that captures the sound and complete proof system of matching logic.
The predicate symbol
$$
\Kdeduce \colon \KTheory \times \KPattern \to \KPred
$$
takes a finite theory and a pattern as proof obligation, and decides if the obligation pattern is deducible in the given theory.
The symbol $\Kdeduce$ has axioms in correspondence to the inference rules\footnote{Axioms are considered as inference rules with zero premises, so we do not distinguish axioms from inference rules anymore.} 
of the matching logic proof system in~\cite{rosu-2017-lmcs}.

In the following, we list all the inference rules of the matching logic proof system and the correspondent axioms of $\Kdeduce$. \improvement{We should mention here that all the subterms that appear in the axioms are assumed to be well-formed. We omit them when writing the axioms because writing all of them down need a lot of space, and will make the axioms less readable.}

We recall the readers our conventions of choosing variable names. 
We use 
$x$ and $y$ for $\KString$ variables,
$s$ for $\KSort$ variables,
$\varphi$ and $\psi$ for $\KPattern$ variables,
$l$ and $r$ for $\KPatternList$ variables~(in \textbf{Rule~(M5)}),
$\Sigma$ for $\KSignature$ variables, 
$F$ for $\KPatternList$ variables~(in \textbf{Rule~(Axiom)}),
and $T$ for $\KTheory$ variables.

\paragraph{Rule (Axiom).}
$F \vdash \varphi$ if $\varphi \in F$.
\begin{align*}
\KinKPatternList(\varphi, F) \to \Kdeduce(\langle \Sigma, F \rangle, \varphi).
\end{align*}

\paragraph{Rule (K1).}
$\vdash \varphi \to (\psi \to \varphi)$.
\begin{align*}
\Kdeduce(T, \overline{\varphi \kimplies_s (\psi \kimplies_s \varphi)}).
\end{align*}

\paragraph{Rule (K2).}
$\vdash (\varphi_1 \to (\varphi_2 \to \varphi_3)) \to ((\varphi_1 \to \varphi_2) \to (\varphi_1 \to \varphi_3))$.
\begin{equation*}
\Kdeduce(T, 
\overline{(\varphi_1 \kimplies_s (\varphi_2 \kimplies_s \varphi_3)) \kimplies_s ((\varphi_1 \kimplies_s \varphi_2) \kimplies_s (\varphi_1 \kimplies_s \varphi_3))}).
\end{equation*}

\paragraph{Rule (K3).}
$\vdash (\neg \psi \to \neg \varphi) \to (\varphi \to \psi)$.
\begin{equation*}
\Kdeduce(T, \overline{(\knot_s \psi \kimplies_s \knot_s \varphi) \kimplies_s (\varphi 
\kimplies_s \psi)}).
\end{equation*}

\paragraph{Rule (K4).}
$\vdash \forall x . \varphi \to \varphi[y/x]$.
\begin{equation*}
\Kdeduce(T, \overline{\kforall_{s_1}^{s_2}  x . \varphi \kimplies_{s_2} \varphi[y \cln s_1 / x \cln s_1]}).
\end{equation*}

\paragraph{Rule (K5).}
$\vdash \forall x . (\varphi \to \psi) \to (\varphi \to \forall x . \psi)$ if $x$ does not occur free in $\varphi$. 
\begin{equation*}
\neg\KinKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi))
\to \Kdeduce(T, \overline{\kforall_{s_1}^{s_2} x . (\varphi \kimplies_{s_2} \psi) \kimplies_{s_2} (\varphi \kimplies_{s_2} \kforall_{s_1}^{s_2} x . \psi)}).
\end{equation*}

\paragraph{Rule (K6).}
$\vdash (\varphi_1 = \varphi_2) \to (\psi[\varphi_1/x] \to \psi[\varphi_2/x])$.
\begin{equation*}
\Kdeduce(T, \overline{(\varphi_1 \kequals_{s_1}^{s_2} \varphi_2) \kimplies_{s_2} (\psi[\varphi_1/x \cln s] \kimplies_{s_2} \psi[\varphi_2/x \cln s])}).
\end{equation*}

\paragraph{Rule (Df).}
$\vdash \ceil{x}$.
\begin{equation*}
\Kdeduce(T, \Kapplication(\Ksymbol(\quot{ceil}, \KconsKSortList(s_1, \KnilKPatternList), s_2), x \cln s_1)).
\end{equation*}

\paragraph{Rule (M1).}
$\vdash (x \in y) = (x = y)$.
\begin{equation*}
\Kdeduce(T, \overline{(x \kin_{s_1}^{s_2} y) \kequals_{s_2}^{s_3} (x \kequals_{s_1}^{s_2} y)}).
\end{equation*}

\paragraph{Rule (M2).}
$\vdash x \in (\varphi \wedge \psi) = (x \in \varphi) \wedge (x \in \psi).$
\begin{equation*}
\Kdeduce(T, \overline{x \kin_{s_1}^{s_2} (\varphi \kand_{s_1} \psi) \kequals_{s_2}^{s_3} (x \kin_{s_1}^{s_2} \varphi) \kand_{s_2} (x \kin_{s_1}^{s_2} \psi)}).
\end{equation*}

\paragraph{Rule (M3).}
$\vdash x \in \neg \varphi = \neg (x \in \varphi)$.
\begin{equation*}
\Kdeduce(T, \overline{x \kin_{s_1}^{s_2} \knot_{s_1} \varphi \kequals_{s_2}^{s_3} \knot_{s_2} (x \kin_{s_1}^{s_2} \varphi)}).
\end{equation*}

\paragraph{Rule (M4).}
$\vdash x \in \forall y . \varphi = \forall y . x \in \varphi$ if $x$ is distinct from $y$.
\begin{equation*}
(\overline{x \cln s_1} \neq \overline{y \cln s_2})  \to \Kdeduce(T, \overline{(x \kin_{s_1}^{s_3} \kforall_{s_2}^{s_1} y . \varphi) \kequals_{s_3}^{s_4} (\kforall_{s_2}^{s_3} y . (x \kin_{s_1}^{s_3} \varphi))}).
\end{equation*}

\paragraph{Rule (M5).}
$\vdash x \in \sigma(\dots \varphi_i \dots) = \exists y . y \in \varphi_i \wedge x \in \sigma(\dots y \dots)$ where $y$ is distinct from $x$ and it does not occur free in $\sigma(\dots \varphi_i \dots)$.
\begin{align*}
& (\overline{x \cln s_1} \neq \overline{y \cln s_2}) 
  \wedge \neg \KinKPatternList(\overline{y \cln s_2}, \KgetFvs(\overline{\sigma(l, \varphi_i, r)}))
\\
\to & \Kdeduce(T, \overline{x \cln s_1 \kin_{s_1}^{s_3} \sigma(l, 
\varphi_i, r) \kequals_{s_3}^{s_4} \kexists_{s_2}^{s_4} y . (y \cln s_2 \kin_{s_2}^{s_3} \varphi_i \kand x \cln s_1 \kin_{s_1}^{s_3} \sigma(l, y, r))}),
\end{align*}
where $l$ and $r$ are $\KPatternList$ variables. 

\paragraph{Rule (Modus Ponens).}
If $\vdash \varphi$ and $\vdash \varphi \to \psi$, then $\vdash \psi$.
\begin{equation*}
\Kdeduce(T, \varphi) \wedge \Kdeduce(T, \overline{\varphi \kimplies_s \psi}) \to 
\Kdeduce(T, \psi).
\end{equation*}

\paragraph{Rule (Universal Generalization).}
If $\vdash \varphi$, then $\vdash \forall x . \varphi$.
\begin{equation*}
\Kdeduce(T, \varphi) \to \Kdeduce(T, \overline{\kforall_{s_1}^{s_2} x . \varphi}).
\end{equation*}

\paragraph{Rule (Membership Introduction).}
If $\vdash \varphi$ and $x$ does not occur free in $\varphi$, then $\vdash x \in \varphi$.
\begin{equation*}
\Kdeduce(T, \varphi) \wedge \neg \KinKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi)) \to \Kdeduce(T, \overline{x \cln s_1 \kin_{s_1}^{s_2} \varphi}).
\end{equation*}

\paragraph{Rule (Membership Elimination).}
If $\vdash x \in \varphi$ and $x$ does not occur free in $\varphi$, then $\vdash \varphi$.
\begin{equation*}
\Kdeduce(T, \overline{x \cln s_1 \kin_{s_1}^{s_2} \varphi}) \wedge\neg \KinKPatternList(\overline{x \cln s_1}, \KgetFvs(\varphi)) \to \Kdeduce(T, \varphi).
\end{equation*}

\subsection{Faithfulness: Finite Case}

\begin{theorem}[Faithfulness Theorem]
	For any finite matching logic theory $T = (S, \Sigma, F)$ and a $\Sigma$-pattern $\varphi$, let us use $\hat{T}$ to denote the corresponding $\Sigma_\Kfinite$-pattern of the sort $\KTheory$ that represents the theory $T$, and use $\hat{\varphi}$ to denote the corresponding $\Sigma_\Kfinite$-pattern of the sort $\KPattern$ that represents the pattern $\varphi$, then
	$$T \vdash \varphi \quad \text{iff} \quad \Kfinite \vdash \Kdeduce(\hat{T}, \hat{\varphi}).$$
\end{theorem}
\begin{proof}
	TBC.
\end{proof}

\section{Matching Logic Theory of Matching Logic: With Meta-Variables}

\section{Matching Logic Theory of Matching Logic: With Parameters}

\section{Get Material From Here}

Matching logic imposes no restrictions on the cardinality of the set of
sorts $S$, of the set of symbols $\Sigma$, or of the set of patterns $A$
in a theory $(S,\Sigma,A)$.
In practice, however, we need a finite mechanism to describe such theories
in order to mechanically reason about them using a computer.
In the vast universe of possibilities, we here propose one particular approach
that we found useful, convenient and sufficient in our semantics engineering
efforts.
Specifically:
\begin{itemize}
\item
We restrict the infinite sets of sorts to ones which can be described with
a finite set of \emph{parametric} sorts, where the parameters range over
other sorts.
For example, $S=\{\Nat,\parametric{\List}{X}\}$ describes the infinite set
of sorts
$S=\{\Nat, \parametric{\List}{\Nat}, \parametric{\List}{\parametric{\List}{\Nat}}, ...\}$.

\end{itemize}

From here on, unless otherwise specified, when we say \emph{set} we mean
a \emph{recursively enumerable set}, i.e., a set that can be generated
algorithmically (not to be confused with the weaker notion of a
countable\unsure{countable may suffice, we'll need to understand how it is in FOL}
set, which only means that it has a cardinal no larger than
$\aleph_0$---either finite or in bijection with the set
of natural numbers).


In this section, we define a matching logic theory $K = (S_K, \Sigma_K, A_K)$ 
as \emph{the (reflective) calculus of matching logic},
where $S_K, \Sigma_K$, and $A_K$ are \emph{finite} sets of sorts,
symbols, and axioms,  respectively.



\section{The Kore Syntax}

The Kore syntax that we propose here is the \emph{minimal} one, in the sense that it supports only the five basic matching logic constructors (variables, symbol applications, conjunction, negation, and existential quantifications), plus parametricity, which allows to define matching logic theories with infinite sorts, symbols, and axioms.

\begin{grammar}\small
	<definition>    ::= <declaration>$^*$
	
	<declaration>   ::= "sort" <sort>
	\alt "hooked-sort" <sort>
	\alt "symbol" <symbol> "(" <sort>$^*$ ")" ":" <sort>
	\alt "hooked-symbol" <symbol> "(" <sort>$^*$ ")" ":" <sort>
	\alt "axiom" <pattern>
	
	<sort>          ::= <atomic-sort> | <parametric-sort>
	
	<parametric-sort> ::= "{" <sort-variable> "}"
	\alt <sort-constructor> "{" <sort-variable>$^+$ "}"
	
	<pattern> ::= <pattern-variable>
	\alt <symbol-id> "(" <pattern-list> ")"
	\alt "\\and" "(" <pattern> "," <pattern> ")"
	\alt "\\not" "(" <pattern> ")" 
	\alt "\\exists" "(" <pattern-variable> "," <pattern> ")"
\end{grammar}

\newcommand{\smalltt}[1]{\texttt{\small #1} }
\newcommand{\sort}{\smalltt{sort}}
\newcommand{\symb}{\smalltt{symbol}}
\newcommand{\axiom}{\smalltt{axiom}}


Sorts are declared using the \sort keyword, symbols are declared using the \symb keyword, and axioms are defined using the \axiom keyword.

\begin{Verbatim}[fontsize=\small]
    /* Example 1: One-Element */
    sort Element1
    symbol e() : Element1
    axiom  e()
\end{Verbatim}

\begin{Verbatim}[fontsize=\small]
    /* Example 2: Two-Element */
    sort Element2
    symbol e1() : Element2
    symbol e2() : Element2
    axiom  \not(\and(\not(e1()), \not(e2())))
    axiom  \not(\and(e1(), e2()))
\end{Verbatim}

Symbols can be parametric on sort variables, which are wrapped by curly brackets. 
Sort variables can be instantiated by any sort.

\begin{Verbatim}[fontsize=\small]
    /* Example 3: Identity-Function */
    symbol id({S}) : {S}
    axiom  \not(\and(X:{S},     \not(id(X:{S}))))
    axiom  \not(\and(id(X:{S}), \not(X:{S})))
\end{Verbatim}

Given the context where two sorts \smalltt{Element1} and \smalltt{Element2} are declared, the above is just a shorthand of

\begin{Verbatim}[fontsize=\small]
    /* Example 3': Identity-Function */
    symbol id(Element1) : Element1
    symbol id(Element2) : Element2
    axiom  \not(\and(X:Element1,     \not(id(X:Element1))))
    axiom  \not(\and(id(X:Element1), \not(X:Element1)))
    axiom  \not(\and(X:Element2,     \not(id(X:Element2))))
    axiom  \not(\and(id(X:Element1), \not(X:Element1)))
\end{Verbatim}

If a sort variable appears multiple times in a statement, only one of the appearances needs curly brackets.
Therefore, an alternative way to write Example~3 is
\begin{Verbatim}[fontsize=\small]
    /* Example 3'': Identity-Function */
    symbol id({S}) : S
    axiom  \not(\and(X:{S},     \not(id(X:S))))
    axiom  \not(\and(id(X:{S}), \not(X:S)))
\end{Verbatim}

If a variable is decorated with a sort variable, as in {\small\verb|X:{S}|}, the sort decoration can be omitted. Therefore, an alternative way to write Example 3 is
\begin{Verbatim}[fontsize=\small]
    /* Example 3''': Identity-Function */
    symbol id({S}) : S
    axiom  \not(\and(X,     \not(id(X))))
    axiom  \not(\and(id(X), \not(X)))
\end{Verbatim}

Symbols can be parametric on more than one sort variables.
\begin{Verbatim}[fontsize=\small]
    /* Example 4: Definedness */
    symbol ceil({S}) : {S'}
    axiom  ceil(X)
\end{Verbatim}

Use sort constructors and sort variables to declare parametric sorts.
\begin{Verbatim}[fontsize=\small]
    /* Example 5: Lists */
    sort List{S}
    symbol nil() : List{S}
    symbol cons(S, List{S}) : List{S}
    symbol length(List{S}) : Nat
\end{Verbatim}

Parametric sorts can take multiple sort variables.
\begin{Verbatim}[fontsize=\small]
    /* Example 6: Pairs */
    sort Pair{S, S'}
    symbol pairOf(S, S') : Pair{S, S'}
    symbol fst(Pair{S, S'}) : S
    symbol snd(Pair{S, S'}) : S'  
\end{Verbatim}

\paragraph{Example (Boolean Algebra).}
\begin{Verbatim}[fontsize=\small]
    sort Bool
    symbol true() : Bool
    symbol false() : Bool
    axiom  \or(true(), false())
    axiom  \not(\and(true(), false()))
    symbol andBool(Bool, Bool) : Bool
    axiom  \equals(andBool(true(), B), B)
    axiom  \equals(andBool(false(), B), false())
\end{Verbatim}



\section{Ignore Me}

\subsection{Syntax and Semantics of Kore}
\label{sec:syntax-of-kore}

\begin{Verbatim}[fontsize=\small]
// Namespaces for sorts, variables, metavariables,
// symbols, and Kore modules.
Sort           = String
VariableId     = String
MetaVariableId = String
Symbol         = String
ModuleId       = String

Variable       = VariableId:Sort
MetaVariable   = MetaVariableId::Sort

Pattern        = Variable | MetaVariable
               | \and(Pattern, Pattern)
               | \not(Pattern)
               | \exists(Variable, Pattern)
               | Symbol(PatternList)

Sentence       = import ModuleId
               | syntax Sort
               | syntax Sort ::= Symbol(SortList)
               | axiom Pattern
Sentences      = Sentence | Sentences Sentences

Module         = module ModuleId
                   Sentences
                 endmodule
\end{Verbatim}

In Kore syntax, the backslash ``\verb|\|'' is reserved for matching logic connectives and the sharp ``\verb|#|'' is reserved for the meta-level, i.e., the $K$ sorts and symbols. 
Therefore, the sorts $\KPred$, $\KString$, $\KSymbol$, $\KSort$, and 
$\KPattern$ in the calculus $K$ are denoted as \verb|#Bool|, \verb|#String|, 
\verb|#Symbol|, \verb|#Sort|, and \verb|#Pattern| in Kore respectively.
Symbols in $K$ are denoted in the similar way, too. 
For example, the constructor symbol $\Kvariable \colon \KString \times \KSort \to \KPattern$ is denoted as \verb|#variable| in Kore. 

A Kore module definition begins with the keyword \verb|module| followed by the name of the module-being-defined, and ends with the keyword \verb|endmodule|. The body of the definition consists of some \emph{sentences}, whose meaning are introduced in the following.

The keyword \verb|import| takes an argument as the name of the module-being-imported, and looks for that module in previous definitions. 
If the module is found, the body of that module is copied to the current module.
Otherwise, nothing happens. 
The keyword \verb|syntax| leads a \emph{syntax declaration}, which can be either a \emph{sort declaration} or a \emph{symbol declaration}.
Sorts declared by sort declarations are called \emph{object-sorts}, in comparison to the five \emph{meta-sorts}, \verb|#Bool|, \verb|#String|, \verb|#Symbol|, \verb|#Sort|, and \verb|#Pattern|, in $K$. 
Symbols whose argument sorts and return sort are all object-sorts (meta-sorts) are called \emph{object-symbols} (\emph{meta-sorts}).

Patterns are written in prefix forms. 
A pattern is called an \emph{object-pattern} (\emph{meta-pattern}) if all sorts and symbols in it are object (meta) ones.
Meta-symbols will be added to the calculus $K$, while object-sorts and object-symbols will not.
They only serve for the purpose to parse an object pattern. 

The keyword \verb|axiom| takes a pattern and adds an axiom to the calculus $K$.
If the pattern is a meta-pattern, it adds the pattern itself as an axiom.
If the pattern $\varphi$ is an object-pattern, it adds $\Bracket{\varphi}$ as an axiom to the calculus $K$.

Recall that we have defined the semantics bracket as
\begin{equation*}
\Bracket{\varphi} \equiv 
\left(\textit{deducible}\left(\mathit{lift}[\varphi]\right) = true\right),
\end{equation*}
where $\varphi$ is a pattern of the grammar in Figure~\ref{ml-grammar}.
However, here in Kore we allow $\varphi$ containing \emph{meta-variables}.
As a result, we modify the definition of the semantics bracket as $$\Bracket{\varphi} \equiv \mathit{mvsc}[\varphi] \to (deducible\left(\mathit{lift}[\varphi]\right) = true),$$
where the lifting function $\mathit{lift}[\_]$ and the meta-variable sort constraint $\mathit{mvsc}[\_]$ are defined in Algorithm~\ref{alg:liftingfunction} and~\ref{alg:mvsc}, respectively.
Intuitively, meta-variables in an object-pattern $\varphi$ are lifted to variables of the sort $\KPattern$ with the corresponding sort constraints. 
For example, the meta-variable $x \cln\cln s$ is lifted to a variable $x \cln \KPattern$ in $K$ with the constraint that $\KgetSort(x \cln \KPattern) = sort(s)$. The function $\mathit{mvsc}[\_]$ collects all such meta-variable sort constraint in an object-pattern is implemented in Algorithm~\ref{alg:mvsc}.

\begin{algorithm}
	\KwIn{An object-pattern $\varphi$.}
	\KwOut{The meta-representation (ASTs) of $\varphi$ in $K$}
	\uIf{$\varphi$ is $x \cln s$}{Return $\mathit{variable(x, sort(s))}$}
	\uElseIf{$\varphi$ is $x \cln \cln s$}{Return $x \cln \KPattern {\ \wedge\ } (\mathit{sort(s)} = \KgetSort(x \cln \KPattern)) $}
	\uElseIf{$\varphi$ is $\varphi_1 \wedge \varphi_2$}
	{Return $\Kand(\mathit{lift}[\varphi_1], \mathit{lift}[\varphi_2]$}
	\uElseIf{$\varphi$ is $\neg \varphi_1$}
	{Return $\Knot(\mathit{lift}[\varphi_1])$}
	\uElseIf{$\varphi$ is $\exists x \cln s . \varphi_1$}
	{Return $\Kexists(x, \mathit{sort(s)}, \mathit{lift}[\varphi_1])$}
	\uElseIf{$\varphi$ is $\sigma(\varphi_1,\dots,\varphi_n)$ and $\sigma \in \Sigma_{s_1,\dots,s_n,s}$}
	{Return $\Kapplication(\mathit{symbol}(\sigma, (\Ksort(s_1), \dots, \Ksort(s_n)), \Ksort(s)),$
	$\mathit{lift}[\varphi_1],\dots,\mathit{lift}[\varphi_n])$}
	\caption{Lifting Function $\mathit{lift}[\_]$}
	\label{alg:liftingfunction}
\end{algorithm}

\begin{algorithm}
	\KwIn{An object-pattern $\varphi$}
	\KwOut{The meta-variable sort constraint of $\varphi$}
	Collect in set $W$ all meta-variables appearing in $\varphi$\;
	Let $C = \emptyset$\;
	\ForEach{$x \cln \cln s \in W$}
	{$C = C \cup (\mathit{sort(s)} = \KgetSort(x \cln \KPattern))$}
	Return $\bigwedge C$\;
	\caption{Meta-Variable Sort Constraint Collection $\mathit{mvsc}$}
	\label{alg:mvsc}
\end{algorithm}


\subsection{Examples of Kore}
\label{sec:examples-of-kore}

\todo[inline, author=Xiaohong]{Add more examples and texts here.}

\paragraph{The {\small BOOL} module.}\quad
\begin{Verbatim}[fontsize=\small]
module BOOL
  syntax Bool
  syntax Bool ::= true | false | notBool(Bool)
                | andBool(Bool, Bool) | orBool(Bool, Bool)
  axiom \or(true(), false())
  axiom \exists(X:Bool, \equals(X:Bool, true()))
  axiom \equals(andBool(B1::Bool, B2::Bool), 
                andBool(B2::Bool, B1::Bool))
  axiom ... ...
endmodule
\end{Verbatim}

\paragraph{The {\small BOOL} module (desugared).}\quad
\begin{Verbatim}[fontsize=\small]
module BOOL
  axiom \equals(
    #true,
    #deducible(#or(#application(#symbol("true", #nilSort, #sort("Bool")),
                                #nilPattern), 
                   #application(#symbol("false", #nilSort, #sort("Bool")),
                                #nilPattern))))
  axiom \equals(
    #true,
    #deducible(#exists("X", #sort("Bool"), 
               #equals(#variable("X", #sort("Bool")), 
                       #application(#symbol("true", #nilSort, #sort("Bool")),
                                    #nilPattern)))))
  axiom \implies(
    \and(\equals(#getSort(B1:Pattern), #sort("Bool")), 
         \equals(#getSort(B2:Pattern), #sort("Bool"))),
    \equals(
      #true,
      #deducible(#equals(#application(#symbol("andBool", 
                                              (#sort("Bool"), #sort("Bool"))
                                              #sort("Bool")), 
                                      (B1:Patern, B2:Pattern)), ---- TODO
                         #application(#symbol("andBool", 
                                              (#sort("Bool"), #sort("Bool"))
                                              #sort("Bool")), 
                                      (B2:Patern, B1:Pattern))))))
  axiom ... ...
endmodule
\end{Verbatim}

\paragraph{The {\small LAMBDA} module}\quad
\begin{Verbatim}[fontsize=\small]
module LAMBDA
  syntax Exp
  syntax Exp ::= app(Exp, Exp) | lambda0(Exp, Exp)
  syntax #Bool ::= isLTerm(#Pattern)

  axiom \equals(
    isLTerm(#variable(X:String, #sort("Exp"))), 
    true)
  axiom \equals(
    isLTerm(#application(
              #symbol("app", (#sort("Exp"), #sort("Exp")), #sort("Exp")),
              (E:Pattern, E':Pattern))),
    andBool(isLTerm(E:Pattern), isLTerm(E':Pattern)))
  axiom \equals(
    isLTerm(#exists(X:String, #sort("Exp"),
                    #application(#symbol("lambda0",
                                         (#sort("Exp"), #sort("Exp")),
                                         #sort("Exp")),
                                 (#variable(X:String, #sort("Exp")),
                                  E:Pattern))),
    isLTerm(E:Pattern))
  axiom \implies(\equals(true, 
                         andBool(isLTerm(E:Pattern), 
                                 isLTerm(E':Pattern))),
                 \equals(true,
                         deducible(#equals(...1,
                                           ...2)))) 
endmodule
\end{Verbatim}

\section{Ignore Me}
A proof system is a theorem generator. 
In $K$, the proof system of matching logic is captured by the functional symbol 
$\mathit{deducible} \colon \KPattern \to \KPred$, which returns $\Ktrue$ 
iff the argument pattern is a theorem. 

We introduce the double bracket $\Bracket{\_}$, known as the semantics bracket, as follows:
\begin{equation*}
\Bracket{\varphi} \equiv 
\left(\textit{deducible}\left(\mathit{lift}[\varphi]\right) = true\right).
\end{equation*}
Intuitively, $\Bracket{\varphi}$ means that ``$\varphi$ is deducible''.
Whenever there is an inference rule (axioms are considered as rules with zero 
premise)
$$
\infer{\psi}
{\varphi_1,\dots,\varphi_n}
$$
in matching logic, there is a corresponding axiom in $K$:
$$
\Bracket{\varphi_1} \wedge \dots \wedge \Bracket{\varphi_n} \to \Bracket{\psi}.
$$
Inference modulo theories can be considered in the same way. 
For any (syntactic) matching logic theory $T$ whose axiom set is $A$, we add
$$
\Bracket{\varphi} \quad \text{for all $\varphi \in A$}
$$
as axioms to $K$. We sometimes denote the extended theory as $\mathit{lift}[T]$ 
and call it 
the \emph{meta-theory for} $T$.

\bibliographystyle{abbrv}
\bibliography{refs}

\end{document}

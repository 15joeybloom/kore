    /* Define propositional derived connectives as alias */
    alias  \or{S}(P:KPattern, Q:KPattern)
        := \not{S}(\and{S}(\not{S}(P:KPattern), \not{S}(Q:KPattern)))
    alias  \implies{S}(P:KPattern, Q:KPattern) 
        := \or{S}(\not{S}(P:KPattern), Q:KPattern)
    alias  \iff{S}(P:KPattern, Q:KPattern) 
        := \and{S}(\implies{S}(P:KPattern, Q:KPattern), 
                   \implies{S}(Q:KPattern, P:KPattern))
    
    /* Define the definedness symbol ceil(),
     * which is parametric on sorts S1 and S2 */
    symbol ceil{S1,S2}(S1) : S2
    
    /* Declare the axiom ceil(X:S) */
    axiom  ceil{S1,S2}(X:S1)
    
    alias  floor{S1,S2}(P:KPattern) 
        := \not{S2}(ceil{S1,S2}(\not{S1}(P:KPattern)))
    alias  \equals{S1,S2}(P:KPattern,Q:KPattern) 
        := floor{S1,S2}(\iff{S1,S2}(P:KPattern,Q:KPattern))
    alias  \forall{S1}(X:S2,P:KPattern) 
        := \not{S1}(\exists{S1}(X:S2,\not{S1}(P:KPattern)))
    
    /* Define Boolean algebra */
    hooked-sort   Bool
    hooked-symbol true()              : Bool
    hooked-symbol false()             : Bool
    hooked-symbol notBool(Bool)       : Bool
    hooked-symbol andBool(Bool, Bool) : Bool
    
    /* Symbol true() is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, true(), Bool, {S}), {S})
    
    /* Symbol false() is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, false(), Bool, {S}), {S})
    
    /* Symbol notBool is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, notBool(C:Bool), Bool, {S}), {S})
    
    /* Symbol andBool is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, andBool(C1:Bool, C2:Bool), Bool, {S}), {S})
    
    /* No-Junk axiom */
    axiom  \or(true(), false(), Bool)
    
    /* No-Overlap axiom */
    axiom  \not(\and(true(), false(), Bool), Bool)
    
    /* notBool(B) = not B */
    axiom  \equals(notBool(B:Bool), \not(B:Bool, Bool), Bool, {S})
    
    /* andBool(B, true) = B */
    axiom  \equals(andBool(B:Bool, true()), B:Bool, Bool, {S})
    
    /* andBool(B, false) = false */
    axiom  \equals(andBool(B:Bool, false()), false(), Bool, {S})
    
    /* Define Presburger arithmetic */
    hooked-sort   Nat
    hooked-symbol zero()         : Nat
    hooked-symbol succ(Nat)      : Nat
    hooked-symbol plus(Nat, Nat) : Nat
    hooked-symbol gte(Nat, Nat)  : Bool /* greater-than-or-equal-to */
    
    /* Symbol zero() is functional */
    axiom  \exists(X:Nat, \equals(X:Nat, zero(), Nat, {S}), {S})
    
    /* Symbol succ is functional */
    axiom  \exists(X:Nat, \equals(X:Nat, succ(Y:Nat), Nat, {S}), {S})
    
    /* Symbol plus is functional */
    axiom  \exists(X:Nat, \equals(X:Nat, plus(Y:Nat, Z:Nat), Nat, {S}), {S})
    
    /* Symbol gte is functional */
    axiom  \exists(B:Bool, \equals(B:Bool, gte(Y:Nat, Z:Nat), Bool, {S}), {S})
    
    /* No-Junk axiom */
    axiom  \or(zero(), \exists(X:Nat, succ(X:Nat), Nat), Nat)
    
    /* No-Overlap axiom */
    axiom  \not(\and(zero(), \exists(X:Nat, succ(X:Nat), Nat), Nat), Nat)
    
    /* X + 0 = X */
    axiom  \equals(plus(X:Nat, zero()), zero(), Nat, {S})
    
    /* X + succ(Y) = succ(X + Y) */
    axiom  \equals(plus(X:Nat, succ(Y:Nat),
                   succ(plus(X:Nat, Y:Nat)),
                   Nat, {S})
                   
    /* Define parametric cons-lists */
    sort   List{S}
    symbol nil{S}()              : List{S}
    symbol cons{S}({S}, List{S}) : List{S}
    
    /* Axioms of functional symbols: nil and cons */
    axiom  \exists(L:List{S}, \equals(L:List{S}, nil{S}(), List{S}, {S1}), {S1})
    axiom  \exists(L:List{S}, \equals(L:List{S}, cons{S}(X:S, L0:List{S}), List{S}, {S1}), {S1})
    
    /* No-Junk and No-Overlap axioms */
    axiom  \or(nil{S}, \exists(X:S, \exists(L:List{S}, 
                       cons{S}(X:S, L:List{S}), List{S}), List{S}), List{S})
    axiom  \not(\and(nil{S}, \exists(X:S, \exists(L:List{S}, 
                             cons{S}(X:S, L:List{S}), List{S}), List{S}), List{S}), List{S})
                             
    /* Define parametric maps */
    sort   Map{S1, S2}
    symbol emptyMap{S1, S2}()                      : Map{S1, S2}
    symbol bind{S1, S2}({S1}, {S2})                : Map{S1, S2}
    symbol merge{S1, S2}(Map{S1, S2}, Map{S1, S2}) : Map{S1, S2}
    
    /* Axioms of functional symbols, partial functional symbols,
     * and constructors:
     *  - emptyMap is functional
     *  - bind     is functional
     *  - merge    is partial
     *  - merge    is assoc-comm
     *  - emptyMap, bind, and merge modulo are constructors
     *  - merge(bind(X, Y), bind(X, Z)) = bottom
     */
    ... ...
    
    /* Define parametric contexts */
    sort   Ctxt{S1,S2}
    symbol gamma0{S1,S2}({S1},{S2})            : Ctxt{S1,S2}
    symbol ctxtapp{S1,S2}(Ctxt{S1,S2}, {S1})   : {S2}
    
    /* Define alias gamma(HOLE:S1, BODY, S2)
     *           := exists HOLE:S1 . BODY
     */
    alias  gamma{S1,S2}(HOLE:S1,P:KPattern) 
        := \exists(HOLE:S1,gamma0{S1,S2}(HOLE:S1,P:KPattern))

    /* plusAExp is active at 1st argument:
     * wellFormedCtxt(C:KPattern) ->
     * plusAExp(C[X],E) = (gamma H:S . plusAExp(C[H:S],E))[E]
     */
    axiom  \implies{S}(\equals{KSort, S}(KgetSort(C:KPattern, Signature), Ctxt{S',AExp}),  /* <-- what is signature? */
    \equals{AExp,S}(plusAExp(ctxtapp(C:KPattern,X:S'), E:AExp),
                    ctxtapp(gamma(HOLE:S, plusAExp(ctxtapp(C:KPattern,HOLE:S'), E:AExp)),
                                   E:AExp))
        
    /* In the following we show how to define the semantics of IMP */
    
    /* Define all IMP program variables */
    sort   Id
    symbol a() : Id
    symbol b() : Id
    ... ...
    symbol z() : Id
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms */
    ... ...
                   
    /* Define the sort AExp of arithmetic expressions */
    sort   AExp
    
    /* syntax AExp  ::= Nat                    <---- NatToAExp    
     *                | Id                     <---- IdToAExp
     *                | AExp "+" AExp [strict] <---- plusAExp
     */
    symbol NatToAExp(Nat)       : AExp
    symbol IdToAExp(Nat)        : AExp
    symbol plusAExp(AExp, AExp) : AExp
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms:
       NatToAExp, IdToAExp, and plusAExp are constructors */
    ... ...
    
    /* Injection from Nat to AExp
     * NatToAExp(X) = NatToAExp(Y) implies X = Y */
    axiom  \implies(\equals(NatToAExp(X:Nat), NatToAExp(Y:Nat), AExp, {S}),
                    \equals(X:Nat, Y:Nat, Nat, {S}), 
                    {S})
   
    /* Injection from Id to AExp */
    axiom  \implies(\equals(IdToAExp(X:Id), IdToAExp(Y:Id), AExp, {S}),
                    \equals(X:Id, Y:Id, Id, {S}),
                    {S})

    /* Axiom of strictness: AExp "+" AExp [strict] */
    meta-var CAExp : Ctxt{S, AExp}
    axiom  \equals(plusAExp(CAExp[X:S], E),      <---- how to tell the S is the one that we used in CAExp?
                   ctxtapp{S,AExp}(gamma(H:S,plusAExp(CAExp[H:S], E), AExp), X),
                   AExp, {S'})
                   
    
    /* Define Boolean expressions */
    sort   BExp
    
   /* syntax BExp  ::= Bool                       <---- BoolToBExp    
    *                | "!" BExp       [strict]    <---- notBExp
    *                | AExp ">=" AExp [seqstrict] <---- gteBExp
    */
    symbol BoolToBExp(Bool)     : BExp
    symbol notBExp(BExp)       : BExp
    symbol gteBExp(AExp, AExp) : BExp
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms:
       BoolToBExp, notBExp, and gteBExp are constructors. */
    ... ...
    
    /* Injection axioms */
    ... ...
    
    /* Axiom of strictness: "!" BExp       [strict] */
    ??? ???
    
    /* Axiom of strictness: AExp ">=" AExp [seqstrict] */
    ??? ???
    
    /* Define Block and Stmt */
    sort   Block
    sort   Stmt
    
    /* syntax Block ::= "{" "}"      <---- emptyBlock()
     *                | "{" Stmt "}" <---- CurlyBracket(Stmt)
     */
    symbol emptyBlock()       : Block
    symbol CurlyBracket(Stmt) : Block
    
    /* syntax Stmt  ::= Block
     *                | Id "=" AExp ";"            [strict(2)]
     *                | "if" "(" BExp ")"
     *                  Block "else" Block         [strict(1)]
     *                | "while" "(" BExp ")" Block
     *                | Stmt Stmt
     */
     
    symbol BlockToStmt(Block)      : Stmt
    symbol asgn(Id, AExp)          : Stmt
    symbol ite(BExp, Block, Block) : Stmt
    symbol while(BExp, Block)      : Stmt
    symbol seq(Stmt, Stmt)         : Stmt
    
    /* Axioms of functional symbols */
    ... ...
    
    /* No-Junk and No-Overlap axioms of constuctors */
    ... ...
    
    /* Axiom of strictness: Id "=" AExp ";" [strict(2)] */
    ??? ???
    
    /* Axiom of strictness: "if" "(" BExp ")" Block "else" Block [strict(1)] */
    ??? ???
    
    /* Define Pgm and Ids */
    /* syntax Pgm ::= "int" Ids ";" Stmt <---- pgm
     * syntax Ids ::= List{Id,","}       <---- List{Id} */
    
    sort   Pgm
    symbol pgm(Ids, Stmt) : Pgm
    
    alias  Ids := List{Id}
    
    /* Define infrastructure of rewriting systems */
    sort   Cfg
    symbol tcell(K, State) : Cfg
    sort   K
    symbol kcell(Pgm) : K
    sort   State
    symbol statecell(Map{Id, Nat}) : State
    
    /* Define rewriting */
    ... ...
    /* the predicate pattern \rewrites(left, right, S, S') means that
     * left => right, S is the sort of left and right,
     * and S' is the sort of the context
     * in which \rewrites(left, right, S, S') is mentioned.
     */
    alias  \rewrites(_,_,_,_) := ... ...
    
    /* syntax KResult ::= Int | Bool */
    sort   KResult
    symbol IntToKResult(Int)   : KResult
    symbol BoolToKResult(Bool) : KResult
    
    /* Define contexts */
    
    ... ...
    
    /* Define rules */
    
    /* rule I1 + I2 => I1 +Int I2 */
    axiom   \rewrites(C[I1 + I2], C[I1 +Int I2], ..., ...) 


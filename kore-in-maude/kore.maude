---- This module contains a parser for the Kore language, whose
---- formal grammar is given in standard BNF notation.

---- General Design Principle: 
----   The lifting function from the
----   object-level to the meta-level should be as trivial and 
----   straightforward as possible, which means:
----   (1) One nonterminal has simply one way to be lifted;
----   (2) Different nonterminals have different ways to be lifted.

---- Following the General Design Principle, object-level things and
---- meta-level things should belong to different nonterminals (Maude
---- sorts) because they are treated differently when being lifted.






fmod KORE is


  ---- <Sort> ::= 
  ---- | <ObjectSort>
  ---- | <MetaSort>

  sorts Sort ObjectSort MetaSort .
  subsorts ObjectSort MetaSort < Sort .


  ---- <ObjectSort> ::=
  ---- | <ObjectSortConstructor> "{" <ObjectSortList> "}"
  ---- | <ObjectSortVariable>
  ---- Remark: Nonterminals <ObjectSortConstructor> and <ObjectSortVariable> 
  ----         are defined as sets of terminals using regular expressions.
  ----         Because Maude does not allow us to use regular expressions
  ----         to define nonterminals, we explicitly define a few terminals
  ----         as Maude constant operators in "tokens.maude".

  sort ObjectSortConstructor .
  sort ObjectSortList .
  sort ObjectSortVariable .
  subsort ObjectSortVariable < ObjectSort .
  op _`{_`} : ObjectSortConstructor ObjectSortList -> ObjectSort [prec 50] .


  ---- <ObjectSortList> ::=
  ---- | ""
  ---- | <ObjectSort>
  ---- | <ObjectSort> "," <ObjectSortList>

  op .ObjectSortList : -> ObjectSortList .
  subsort ObjectSort < ObjectSortList .
  op _,_ : ObjectSort ObjectSortList -> ObjectSortList [prec 52] .

  ---- Deal with (parsing) the empty list.
  op _`{`} : ObjectSortConstructor -> ObjectSort [prec 50] .
  eq SC:ObjectSortConstructor{}
   = SC:ObjectSortConstructor{.ObjectSortList} .


  ---- <MetaSort> ::=
  ---- | <MetaSortConstructor> "{" "}"
  ---- | <MetaSortVariable> 
  ---- Remark: <MetaSortConstructor> has only a finite number of terminals.

  sort MetaSortConstructor .
  sort MetaSortList .
  sort MetaSortVariable .
  subsort MetaSortVariable < MetaSort .
  op _`{`} : MetaSortConstructor -> MetaSort [prec 50] .

  op KPred        : -> MetaSortConstructor . 
  op KChar        : -> MetaSortConstructor . 
  op KString      : -> MetaSortConstructor . 
  op KSort        : -> MetaSortConstructor . 
  op KSortList    : -> MetaSortConstructor . 
  op KSymbol      : -> MetaSortConstructor . 
  op KSymbolList  : -> MetaSortConstructor .   
  op KVariable    : -> MetaSortConstructor . 
  op KPattern     : -> MetaSortConstructor . 
  op KPatternList : -> MetaSortConstructor . 
  op KAxiom       : -> MetaSortConstructor .  
  op KAxiomList   : -> MetaSortConstructor . 

  op KS           : -> MetaSortVariable .
  op KS1          : -> MetaSortVariable .
  op KS2          : -> MetaSortVariable .
  op KS3          : -> MetaSortVariable .
  op KS'          : -> MetaSortVariable .
  op KS''         : -> MetaSortVariable .


  ---- <MetaSortList> ::=
  ---- | ""
  ---- | <MetaSort>
  ---- | <MetaSort> "," <MetaSortList>

  op .MetaSortList : -> MetaSortList .
  subsort MetaSort < MetaSortList .
  op _,_ : MetaSort MetaSortList -> MetaSortList [prec 52] .


 
  ---- Symbols are elements of a signature:
  ---- - Atomic constant symbols         : true{} false{} zero{}
  ---- - Parametric constant symbols     : nil{Nat}
  ---- - Atomic non-constant symbols     : plus{}
  ---- - Parametric non-constant symbols : cons{Nat}


  ---- <Symbol> ::= 
  ---- | <ObjectSymbol>
  ---- | <MetaSymbol>

  sorts Symbol ObjectSymbol MetaSymbol .
  subsorts ObjectSymbol MetaSymbol < Symbol .


  ---- <ObjectSymbol> ::=
  ---- | <ObjectSymbolConstructor> "{" <ObjectSortList> "}"

  sort ObjectSymbolConstructor .
  op _`{_`} : ObjectSymbolConstructor ObjectSortList 
           -> ObjectSymbol [prec 50] .
  op _`{`}  : ObjectSymbolConstructor 
           -> ObjectSymbol [prec 50] .
  eq SC:ObjectSymbolConstructor{}
   = SC:ObjectSymbolConstructor{.ObjectSortList} .


  ---- <MetaSymbol> ::=
  ---- | <MetaSymbolConstructor> "{" <MetaSortList> "}"
  ---- Remark: <MetaSymbolConstructor> has a finite number of terminals,

  sort MetaSymbolConstructor .
  op _`{_`} : MetaSymbolConstructor MetaSortList 
           -> MetaSymbol [prec 50] .
  op _`{`}  : MetaSymbolConstructor 
           -> MetaSymbol [prec 50] .
  eq SC:MetaSymbolConstructor{}
   = SC:MetaSymbolConstructor{.MetaSortList} .
  
  ---- Pick better names.
  op Ksort             : -> MetaSymbolConstructor .
  op KnilKSortList     : -> MetaSymbolConstructor .
  op KconsKSortList    : -> MetaSymbolConstructor .
  op Ksymbol           : -> MetaSymbolConstructor .
  op Kvariable         : -> MetaSymbolConstructor .
  op Kapplication      : -> MetaSymbolConstructor .
  op Kand              : -> MetaSymbolConstructor .
  op Knot              : -> MetaSymbolConstructor .
  op Kexists           : -> MetaSymbolConstructor .
  op KnilKPatternList  : -> MetaSymbolConstructor .
  op KconsKPatternList : -> MetaSymbolConstructor .
  op Kaxiom            : -> MetaSymbolConstructor .
  op KgetSort          : -> MetaSymbolConstructor .




  ---- Aliases have the same grammar / syntax as symbols,
  ---- for simplicity. But, semantically, aliases are *not*
  ---- symbols. Semantically, aliases do not exist. They
  ---- desugar into patterns.

  ---- Remark: the grammar for aliases is so similar with the
  ----         one for symbols that I simply copy-and-paste
  ----         the symbol grammar and replace "Symbol" with
  ----         "Alias" in the following.

  ---- <Alias> ::= 
  ---- | <ObjectAlias>
  ---- | <MetaAlias>

  sorts Alias ObjectAlias MetaAlias .
  subsorts ObjectAlias MetaAlias < Alias .

  ---- <ObjectAlias> ::=
  ---- | <ObjectAliasConstructor> "{" <ObjectSortList> "}"

  sort ObjectAliasConstructor .
  op _`{_`} : ObjectAliasConstructor ObjectSortList 
           -> ObjectAlias [prec 50] .
  op _`{`}  : ObjectAliasConstructor 
           -> ObjectAlias [prec 50] .
  eq SC:ObjectAliasConstructor{}
   = SC:ObjectAliasConstructor{.ObjectSortList} .


  ---- <MetaAlias> ::=
  ---- | <MetaAliasConstructor> "{" <MetaSortList> "}"
  ---- Remark: <MetaAliasConstructor> has a finite number of terminals,

  sort MetaAliasConstructor .
  op _`{_`} : MetaAliasConstructor MetaSortList 
           -> MetaAlias [prec 50] .
  op _`{`}  : MetaAliasConstructor 
           -> MetaAlias [prec 50] .
  eq SC:MetaAliasConstructor{}
   = SC:MetaAliasConstructor{.MetaSortList} .
  
  ---- More to go ...
  op Kor             : -> MetaAliasConstructor .





  ---- <Variable> ::=
  ---- | <ObjectVariable>
  ---- | <MetaVariable>

  sorts Variable ObjectVariable MetaVariable .
  subsorts ObjectVariable MetaVariable < Variable .


  sort VariableName .

  ---- <ObjectVariable> ::=
  ---- | <VariableName> ":" <ObjectSort>

  op _:_ : VariableName ObjectSort -> ObjectVariable [prec 52] .


  ---- <MetaVariable> ::=
  ---- | <VariableName> ":" <MetaSort>

  op _:_ : VariableName MetaSort -> MetaVariable [prec 52] .


endfm

quit


  ---- <Pattern> ::= <Variable>                       
  ---- | <Symbol> "(" <PatternList> ")"   
  ---- | "\not" "{" <Sort> "}" "(" <Pattern> ")"
  ---- | "\and" "{" <Sort> "}" "(" <Pattern> "," <Pattern> ")"
  ---- | "\exists" "{" <Sort> "," <Sort> "}" "(" <Variable> "," <Pattern> ")"
  ---- | <Alias> "(" <PatternList> ")"   
  ---- | <String>
  ----
  ---- <PatternList> ::= ""
  ----                 | <Pattern>
  ----                 | <Pattern> "," <PatternList>

  sorts Pattern PatternList .

  subsort Pattern < PatternList .
  op .PatternList : -> PatternList .
  op _,_ : Pattern PatternList -> PatternList [prec 58] .  


  subsort Variable < Pattern .

  op _`(_`) : Symbol PatternList -> Pattern [prec 53] .
  op _`(_`) : Alias  PatternList -> Pattern [prec 53] .
  op _`(`)  : Symbol             -> Pattern [prec 53] .
  op _`(`)  : Alias              -> Pattern [prec 53] .
  eq S:Symbol() = S:Symbol(.PatternList) .
  eq S:Alias()  = S:Alias (.PatternList) .

  op \not`{_`}`(_`) : Sort Pattern -> Pattern 
     [format(d d d d d d d d) prec 52] .

  op \and`{_`}`(_,_`) : Sort Pattern Pattern -> Pattern 
     [format(d d d d d d d d d d) prec 52] .

  op \exists`{_,_`}`(_,_`) : Sort Sort Variable Pattern -> Pattern
     [format(d d d d d d d d d d d d) prec 52] .


  protecting STRING .
  subsort String < Pattern .



  ---- <Sentence>  ::= "sort" <Sort>
  ----               | "symbol" <Symbol> "(" <SortList> ")" ":" <Sort>
  ----               | "axiom" "{" <SortList> "}" <Pattern>
  ----               | "alias" "{" <SortList> "}" <Pattern> ":=" <Pattern>
  ----
  ---- <Sentences> ::= <Sentence>
  ----               | <Sentence> <Sentences>

  sort Sentence Sentences .
  subsort Sentence < Sentences .

  op __ : Sentence Sentences -> Sentences 
     [format(d n d) prec 75] .


  op sort_ : Sort -> Sentence 
     [format(nb o d) prec 66] .

  op symbol_`(_`):_ : Symbol SortList Sort -> Sentence 
     [format(nb o d d d d d d) prec 66] .

  op axiom{_}_ : SortList Pattern -> Sentence 
     [format(nb o d d n++i --) prec 66] .

  op alias{_}_:=_ : SortList Pattern Pattern -> Sentence 
     [format(nb o d d n++i nb o --) prec 66] .

  ---- Deal with empty sort parameter list.
  op symbol_():_ : Symbol Sort -> Sentence
     [format(nb o d d d d d) prec 66] .
  eq symbol S:Symbol() : S:Sort = symbol S:Symbol (.SortList) : S:Sort .
  op axiom{}_ : Pattern -> Sentence 
     [format(nb o d n++i --) prec 66] .
  eq axiom{} P:Pattern = axiom{.SortList} P:Pattern .
  op alias{}_:=_ : Pattern Pattern -> Sentence 
     [format(nb o d n++i ni d --) prec 66] .
  eq alias{} P:Pattern := Q:Pattern = alias{.SortList} P:Pattern := Q:Pattern .

endfm



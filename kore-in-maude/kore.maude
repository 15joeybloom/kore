---- This module contains a parser for the Kore language, whose
---- formal grammar is given in standard BNF notation.

---- General Design Principles: 
----   The lifting function from the
----   object-level to the meta-level should be as trivial and 
----   straightforward as possible, which means:
----   (1) One nonterminal has one way to lift;
----   (2) Different nonterminals have different ways to lift.

fmod KORE is

  ---- <Sort>     ::= <SortConstructor> "{" <SortList> "}"
  ----              | <SortVariable>
  ---- <SortList> ::= ""
  ----              | <Sort>
  ----              | <Sort> "," <SortList>
  
  ---- Notice: Nonterminals <SortConstructor> and <SortVariable> are
  ----         defined as sets of terminals using regular expressions.
  ----         Because Maude does not allow us to use regular expressions
  ----         to define nonterminals, we explicitly define a few terminals
  ----         as Maude constant operators in "tokens.maude".
  
  ---- Example terminals of <SortConstructor>:
  ---- - Nat Int AExp BExp List Ctxt
  
  ---- Example terminals of <SortVariable>:
  ---- - S S' S1 S2 R

  sorts Sort SortList .

  subsort Sort < SortList .
  op .SortList : -> SortList .
  op _,_ : Sort SortList -> SortList [prec 52] .

  sorts SortVariable SortConstructor .

  subsort SortVariable < Sort .
  op _`{_`} : SortConstructor SortList -> Sort [prec 50] .
  op _`{`}  : SortConstructor          -> Sort [prec 50] .

  eq SC:SortConstructor{}
   = SC:SortConstructor{.SortList} .
  

  ---- <Symbol> ::= <SymbolConstructor> "{" <SortList> "}"
  ---- <Alias>  ::= <AliasConstructor>  "{" <SortList> "}"
  
  ---- Symbols are elements of a signature:
  ---- - Atomic constant symbols         : true{} false{} zero{}
  ---- - Parametric constant symbols     : nil{Nat}
  ---- - Atomic non-constant symbols     : plus{}
  ---- - Parametric non-constant symbols : cons{Nat}

  ---- Aliases have the same grammar / syntax as symbols,
  ---- for simplicity. But, semantically, aliases are *not*
  ---- symbols. Semantically, aliases do not exist. They
  ---- desugar into patterns.

  sorts Symbol SymbolConstructor .
  op _`{_`} : SymbolConstructor SortList -> Symbol [prec 50] .
  op _`{`}  : SymbolConstructor          -> Symbol [prec 50] .
  eq SC:SymbolConstructor{}
   = SC:SymbolConstructor{.SortList} .

  sorts Alias AliasConstructor .
  op _`{_`} : AliasConstructor SortList -> Alias [prec 50] .
  op _`{`}  : AliasConstructor          -> Alias [prec 50] .
  eq SC:AliasConstructor{}
   = SC:AliasConstructor{.SortList} .

  ---(
  ---- Trick to prevent symbol overloading warnings
  sort BottomSymbolAlias .
  subsorts BottomSymbolAlias < Symbol Alias .
  op _{_} : BottomSymbolAlias SortList -> BottomSymbolAlias [prec 50] .
  ---)

  ---- <Variable> ::= <VariableName> ":" <Sort>

  sorts VariableName Variable .
  op _:_ : VariableName Sort -> Variable [prec 52] .




  ---- <Pattern>     ::= <Variable>                       
  ----                 | <Symbol> "(" <PatternList> ")"   
  ----                 | "\not" "{" <Sort> "}" "(" <Pattern> ")"
  ----                 | "\and" "{" <Sort> "}" "(" <Pattern> "," <Pattern> ")"
  ----                 | "\exists" "{" <Sort> "}" "(" <Variable> "," <Pattern> ")"
  ----                 | <Alias> "(" <PatternList> ")"   
  ----
  ---- <PatternList> ::= ""
  ----                 | <Pattern>
  ----                 | <Pattern> "," <PatternList>

  sorts Pattern PatternList .

  subsort Pattern < PatternList .
  op .PatternList : -> PatternList .
  op _,_ : Pattern PatternList -> PatternList [prec 58] .  


  subsort Variable < Pattern .

  op _`(_`) : Symbol PatternList -> Pattern [prec 53] .
  op _`(_`) : Alias  PatternList -> Pattern [prec 53] .
  op _`(`)  : Symbol             -> Pattern [prec 53] .
  op _`(`)  : Alias              -> Pattern [prec 53] .
  eq S:Symbol() = S:Symbol(.PatternList) .
  eq S:Alias()  = S:Alias (.PatternList) .

  op \not`{_`}`(_`) : Sort Pattern -> Pattern 
     [format(d d d d d d d d) prec 52] .

  op \and`{_`}`(_,_`) : Sort Pattern Pattern -> Pattern 
     [format(d d d d d d d d d d) prec 52] .

  op \exists`{_,_`}`(_,_`) : Sort Sort Variable Pattern -> Pattern
     [format(d d d d d d d d d d d d) prec 52] .





  ---- <Sentence>  ::= "sort" <Sort>
  ----               | "symbol" <Symbol> "(" <SortList> ")" ":" <Sort>
  ----               | "axiom" "{" <SortList> "}" <Pattern>
  ----               | "alias" "{" <SortList> "}" <Pattern> ":=" <Pattern>
  ----
  ---- <Sentences> ::= <Sentence>
  ----               | <Sentence> <Sentences>

  sort Sentence Sentences .
  subsort Sentence < Sentences .

  op __ : Sentence Sentences -> Sentences 
     [format(d n d) prec 75] .


  op sort_ : Sort -> Sentence 
     [format(nb o d) prec 66] .

  op symbol_`(_`):_ : Symbol SortList Sort -> Sentence 
     [format(nb o d d d d d d) prec 66] .

  op axiom{_}_ : SortList Pattern -> Sentence 
     [format(nb o d d n++i --) prec 66] .

  op alias{_}_:=_ : SortList Pattern Pattern -> Sentence 
     [format(nb o d d n++i nb o --) prec 66] .

  ---- Deal with empty sort list.
  op symbol_():_ : Symbol Sort -> Sentence
     [format(nb o d d d d d) prec 66] .
  eq symbol S:Symbol() : S:Sort = symbol S:Symbol (.SortList) : S:Sort .
  op axiom{}_ : Pattern -> Sentence 
     [format(nb o d n++i --) prec 66] .
  eq axiom{} P:Pattern = axiom{.SortList} P:Pattern .
  op alias{}_:=_ : Pattern Pattern -> Sentence 
     [format(nb o d n++i ni d --) prec 66] .
  eq alias{} P:Pattern := Q:Pattern = alias{.SortList} P:Pattern := Q:Pattern .

endfm

---(

---- Reflection ----

---- Kore's syntax is reflexive, in the sense that
---- everything can be parsed as a Pattern, and a
---- Pattern can be parsed as anything. The general
---- principle is "No-Surprise":
----  - something won't be parsed as a Pattern unless
----    it has to.
----  - a Pattern won't be parsed as something(else)
----    unless it has to.

---- We provide some examples of reflection here.

---- Example 1 (Parse Sort As Pattern):
----   \equals{KSort, S}
----     (KgetSort(C:KPattern), Ctxt{BExp, AExp})

---- Example 2 (Parse Symbol As Pattern):
----   \equals{KSymbol, S}
----     (Sigma:KSymbol, plus)

---- Example 3 (Parse Pattern As Sort):
----   X:Ksort("Int")

---- Reflection is implemented by the following modules
---- with overloaded operators.
---- (Overloaded) operators are assigned with selected
---- precedence so that there is "No-Surprise".


---- Parse Sort as Pattern

fmod SORT-AS-PATTERN is

  protecting PATTERN .

  sort    Sort-As-Pattern           .
  subsort Sort-As-Pattern < Pattern .
  
  sort SortList-As-PatternList                  .
  subsort SortList-As-PatternList < PatternList .     

  subsort Sort-As-Pattern < SortList-As-PatternList .
  op _,_ : Sort-As-Pattern SortList-As-PatternList
        -> SortList-As-PatternList
     [prec 53] .

  sort AtomicSort-As-Pattern        .
  sort SortVariable-As-Pattern      .
  sort ParametricSort-As-Pattern    .

  subsort AtomicSort-As-Pattern   < Sort-As-Pattern . 
  subsort SortVariable-As-Pattern < Sort-As-Pattern .
  op _{_} : ParametricSort-As-Pattern SortList-As-PatternList 
         -> Sort-As-Pattern [prec 53] . 

endfm

---- Parse Symbol as Pattern

fmod SYMBOL-AS-PATTERN is

---- TODO::

endfm


---- Parse Pattern as Sort

fmod PATTERN-AS-SORT is

---- TODO::

endfm

---- Parse Pattern as Symbol

fmod PATTERN-AS-SYMBOL is

---- TODO::

endfm





fmod REFLEXIVITY is

  protecting SORT-AS-PATTERN   .
  protecting SYMBOL-AS-PATTERN .
  protecting PATTERN-AS-SORT   .
  protecting PATTERN-AS-SYMBOL .

endfm

---)



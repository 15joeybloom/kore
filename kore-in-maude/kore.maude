---- The Kore Language: A Maude Implementation ----

fmod KORE is

  protecting META-LEVEL *
    (sort Sort     to META-LEVEL.Sort,
     sort Variable to META-LEVEL.Variable) .

  protecting INT .
  protecting STRING .
  protecting CONVERSION .





  ---- Syntax of Kore: BNF grammar followed by the implementation.





  ---- <ObjectSort>  ::= <AtomicObjectSort>
  ----                 | <ParametricObjectSort> "{" <NeObjectSortList> "}"
  ----                 | <ObjectSortVariable>
  ---- <MetaSort>    ::= "KSort"
  ----                 | "KSortList"
  ----                 | "KSymbol"
  ----                 | "KPattern" 
  ----                 | "KPatternList" 
  ----                 | "KString"
  ----                 | <MetaSortVariable> 

  ---- Remark: It is critical that we are able to distintuish object sorts 
  ----         and meta sorts statically (and preferably locally, too).

  sorts ObjectSort MetaSort .

  sort AtomicObjectSort ParametricObjectSort ObjectSortVariable .
  subsorts AtomicObjectSort ObjectSortVariable < ObjectSort .
  op _`{_`} : ParametricObjectSort NeObjectSortList -> ObjectSort [prec 50] .

  sort MetaSortVariable .
  subsort MetaSortVariable < MetaSort .

  ---- Defining lists of various types.
  ---- Remark: Maude cannot parse "" as the empty list, so we use "." instead.
  ----         Some auxiliary equations are added to help Maude parse
  ----         the empty list.

  ---- Object sort list.

  sorts NeObjectSortList ObjectSortList .
  subsort ObjectSort < NeObjectSortList < ObjectSortList .
  op . : -> ObjectSortList .
  op _,_ : ObjectSort ObjectSortList -> NeObjectSortList [prec 52] .

  ---- Meta sort list.

  sort NeMetaSortList MetaSortList .
  subsort MetaSort < NeMetaSortList < MetaSortList .
  op . : -> MetaSortList .
  op _,_ : MetaSort NeMetaSortList -> NeMetaSortList [prec 52] .

  ---- <SortVariable> ::= <ObjectSortVariable> | <MetaSortVariable>

  ---- Remark: Sort variables are declared (locally) in curly brackets "{}"
  ----         after keywords "axiom" and "alias". We require a clear 
  ----         distinction between object sort variables and meta sort
  ----         variables. 

  sort SortVariable .
  subsort ObjectSortVariable MetaSortVariable < SortVariable .

  ---- Sort variable lists.

  sorts NeSortVariableList SortVariableList .
  subsorts SortVariable < NeSortVariableList < SortVariableList .
  op . : -> SortVariableList .
  op _,_ : SortVariable SortVariableList -> NeSortVariableList [prec 52] .

  ---- Non-empty object sort variable list

  sort NeObjectSortVariableList .
  subsorts ObjectSortVariable < NeObjectSortVariableList < NeSortVariableList .
  op _,_ : ObjectSortVariable NeObjectSortVariableList 
        -> NeObjectSortVariableList [prec 52] .

  ---- Some utility functions.

  var OS : ObjectSort . var MS : MetaSort .
  var OH : ObjectHead . var MH : MetaHead .
  vars MSs MSs' : NeMetaSortList .
  var NeSVs : NeSortVariableList .

  ---- Append two lists.
  op _@_ : NeMetaSortList NeMetaSortList -> NeMetaSortList .
  eq MS @ MSs = MS, MSs .
  eq (MS, MSs) @ MSs' = MS, (MSs @ MSs') .

  ---- Length of lists.
  op len : NeMetaSortList -> Nat .
  eq len(MS) = 1 .
  eq len(MS, MSs) = 1 + len(MSs) .





  ---- <Pattern>     ::= <Head> "(" <PatternList> ")"
  ----                 | <VariableName> ":" <ObjectSort>
  ----                 | <VariableName> ":" <MetaSort>
  ----                 | <String>
  ---- <PatternList> ::= ""
  ----                 | <Pattern>
  ----                 | <Pattern> "," <PatternList>

  ---- Remark: Maude cannot parse "", so we use "." instead.

  sorts Pattern PatternList Head VariableName .

  op _`(_`) : Head PatternList -> Pattern 
     [format(d d n++i d --) prec 75] .
  op _:_ : VariableName ObjectSort -> Pattern 
     [prec 75] .
  op _:_ : VariableName MetaSort -> Pattern 
     [prec 75] .
  subsort String < Pattern .

  op . : -> PatternList .
  subsort Pattern < PatternList .
  op _,_ : Pattern PatternList -> PatternList 
     [format(d d ni d) prec 78] .

  ---- Help Maude parse the empty pattern list.
  op _`(`) : Head -> Pattern [prec 75] .
  eq H:Head() = H:Head(.) .

  ---- Prevent "." to appear at the tail of a list.
  eq P:Pattern, . = P:Pattern .

  vars Ps Ps' : PatternList .

  ---- Append two lists.
  op _@_ : PatternList PatternList -> PatternList .
  eq . @ Ps = Ps .
  eq P:Pattern @ Ps = P:Pattern, Ps .
  eq (P:Pattern, Ps) @ Ps' = P:Pattern, (Ps @ Ps') .

  ---- Length of lists.
  op len : PatternList -> Nat .
  eq len(P:Pattern) = 1 .
  eq len(P:Pattern, Ps) = 1 + len(Ps) .







  ---- <Head> ::= <ObjectHead> | <MetaHead>
  
  ---- Remark: One design principle of the Kore language is that
  ----         we can tell (locally and statically) whether a head
  ----         is an object-level one or a meta-level one.

  sorts ObjectHead MetaHead . 
  subsorts ObjectHead MetaHead < Head .

  ---- <ObjectHead> ::= <AtomicObjectHead>
  ----                | <ParametricHead> "{" <NeObjectSortList> "}" 
  ---- <MetaHead>   ::= <AtomicMetaHead>
  ----                | <ParametricHead> "{" <NeMetaSortList> "}"

  sorts AtomicObjectHead AtomicMetaHead ParametricHead .
  subsort AtomicObjectHead < ObjectHead .
  subsort AtomicMetaHead < MetaHead .
  op _`{_`} : ParametricHead NeObjectSortList -> ObjectHead [prec 72] .
  op _`{_`} : ParametricHead NeMetaSortList -> MetaHead [prec 72] .






  ---- A Kore definition (def.kore) consists of a sequence of declarations.

  ---- <Declaration>  ::= 
  ----   | "sort" <AtomicObjectSort>
  ----   | "sort" <ParametricObjectSort> "{" <NeObjectSortVariableList> "}"
  ----   | "symbol" <ObjectHead> "(" <ObjectSortList> ")" ":" <ObjectSort>
  ----   | "symbol" <MetaHead> "(" <MetaSortList> ")" ":" <MetaSort>
  ----   | "axiom" <Pattern>
  ----   | "axiom" "{" <NeSortVariableList> "}" <Pattern>
  ----   | "alias" 
  ----             <Head> "(" <PatternList> ")" ":=" <Pattern> 
  ----   | "alias" "{" <NeSortVariableList> "}" 
  ----             <Head> "(" <PatternList> ")" ":=" <Pattern> 

  ---- <Declarations> ::= 
  ----   | ""
  ----   | <Declaration>
  ----   | <Declaration> <Declarations>

  ---- Remark: Maude can't parse an empty definition, so we omit that case.

  sorts Declaration Declarations .
  subsort Declaration < Declarations .
  op __ : Declaration Declarations -> Declarations [format(d n d) prec 85] .

  var Decl : Declaration .
  vars Decls Decls' : Declarations .

  ---- Append two declarations.
  op _@_ : Declarations Declarations -> Declarations .
  eq Decl @ Decls = Decl Decls .
  eq (Decl Decls) @ Decls' = Decl (Decls @ Decls') .

  op sort_ : AtomicObjectSort -> Declaration 
     [format(b o d) prec 82] .
  op sort_`{_`} : ParametricObjectSort NeObjectSortVariableList 
               -> Declaration 
     [format(b o d d d d) prec 82] .

  op symbol_`(_`):_ : ObjectHead ObjectSortList ObjectSort -> Declaration 
     [format(b o d d d s d d) prec 82] .
  op symbol_`(_`):_ : MetaHead MetaSortList MetaSort -> Declaration
     [format(b o d d d s d d) prec 82] .

  op axiom_    : Pattern -> Declaration 
     [format(b on++i --) prec 82] .
  op axiom{_}_ : NeSortVariableList Pattern -> Declaration 
     [format(b o d d n++i --) prec 82] .

  op alias_`(_`):=_ : Head PatternList Pattern -> Declaration 
     [prec 82] .
  op alias`{_`}_`(_`):=_ : NeSortVariableList Head PatternList Pattern 
                        -> Declaration 
     [format(b o d d d d d s d d d) prec 82] .
  
  ---- Help Maude parse empty lists.

  op symbol_`(`):_ : ObjectHead ObjectSort -> Declaration 
     [format(b o d d s d d) prec 82] .
  eq symbol OH() : OS = symbol OH(.) : OS .
  
  op symbol_`(`):_ : MetaHead MetaSort -> Declaration 
     [format(b o d d s d d) prec 82] .
  eq symbol MH() : MS = symbol MH(.) : MS .

  op alias_`(`):=_ : Head Pattern -> Declaration 
     [prec 82] .
  eq alias H:Head() := P:Pattern = alias H:Head(.) := P:Pattern .

  op alias`{_`}_`(`):=_ : NeSortVariableList Head Pattern -> Declaration 
     [format(b o d d d d s d d d) prec 82] .
  eq alias{NeSVs} H:Head() := P:Pattern = alias{NeSVs} H:Head(.) := P:Pattern .


  ----

  eq axiom P:Pattern = axiom{.} P:Pattern .
  eq alias H:Head(Ps) := P:Pattern = alias{.} H:Head(Ps) := P:Pattern .


  ---(




  ---- Defining the lifting bracket [[_]]





  vars Ps Ps' : PatternList .

  var PH : ParametricHead .


  op ERROR@AtomicMetaHead : -> [AtomicMetaHead] .
  op ERROR@VariableName   : -> [VariableName]   .


  ---- Lift a pattern
  op [[_]] : Pattern -> Pattern . 
  eq [[H:AtomicObjectHead(Ps)]] = [[H:AtomicObjectHead]]([[Ps]]) .
  eq [[H:AtomicMetaHead(Ps)]] = H:AtomicMetaHead([[Ps]]) .
  eq [[PH:ParametricHead{OSs}(Ps)]] = [[PH:ParametricHead]]([[OSs]] @ [[Ps]]) .
  eq [[PH:ParametricHead{MSs}(Ps)]] = PH:ParametricHead{MSs}([[Ps]]) .
  eq [[X:VariableName : OS]] = Kvariable([[X:VariableName]], [[OS]]) .
  eq [[X:VariableName : MS]] = X:VariableName : MS .
  eq [[S:String]] = S:String .

  ---- Lift a list of patterns by lifting each of them.
  op [[_]] : PatternList -> PatternList .
  eq [[.]] = . .
  eq [[P:Pattern, Ps]] = [[P:Pattern]], [[Ps]] . 

  ---- Lift an atomic object head by putting a "K" in front of it
  op [[_]] : AtomicObjectHead -> AtomicMetaHead .
  eq [[H:AtomicObjectHead]] 
   = downTerm(
       addK(upTerm(H:AtomicObjectHead)),
       ERROR@AtomicMetaHead) . 

  ---- Lift a parametric head by putting a "K" in front of it
  op [[_]] : ParametricHead -> AtomicMetaHead .
  eq [[PH:ParametricHead]]
   = downTerm(
       addK(upTerm(PH:ParametricHead)),
       ERROR@AtomicMetaHead) .

  ---- Lift an object sort to a pattern.
  op [[_]] : ObjectSort -> Pattern .

  ---- Lift an atomic object sort by putting a "K" in front of it
  ----   [[Nat]] = KNat()
  ----   [[Bool]] = KBool()
  eq [[S:AtomicObjectSort]]
   = downTerm(
       addK(upTerm(S:AtomicObjectSort)),
       ERROR@AtomicMetaHead) () .

  ---- Lifting a parametric sort by putting a "K" in front of it
  op [[_]] : ParametricObjectSort -> AtomicMetaHead .
  eq [[S:ParametricObjectSort]]
   = downTerm(
       addK(upTerm(S:ParametricObjectSort)),
       ERROR@AtomicMetaHead) .
  eq [[PS:ParametricObjectSort{OSs}]]
   = [[PS:ParametricObjectSort]]([[OSs]]) .

  ---- Lifting an object sort variable:
  ----   [[S]] = S : KSort
  eq [[S:ObjectSortVariable]]
   = (downTerm(
        qid(string(getName(upTerm(S:ObjectSortVariable)))
            + ".VariableName"), 
        ERROR@VariableName)) : KSort .

  ---- Lifting a list of object sorts by lifting each of them.
  op [[_]] : ObjectSortList -> PatternList .
  eq [[S:ObjectSort, OSs]]
   = [[S:ObjectSort]], [[OSs]] .

  ---- Lifting a variable name to its string representation.
  op [[_]] : VariableName -> String .
  eq [[X:VariableName]]
   = string(getName(upTerm(X:VariableName))) .


  ---- Lifting a sentence to sentences at meta-level
  op [[_]] : Declarations -> Declarations .
  eq [[S:Declaration Ss:Declarations]] = [[S:Declaration]] @ [[Ss:Declarations]] .


  ---- Lifting axiom declarations
  ---- Step 1: Get rid of object sort variables.
  ----         In fact, the object sort variables in the curly bracket
  ----         after the keyword "axiom" is of no use in this implementation,
  ----         because we already knew (defined) terminals of ObjectSortVariable
  eq [[axiom P:Pattern]] = axiom liftToAxiom(P:Pattern) .
  eq [[axiom{OSs} P:Pattern]] = axiom liftToAxiom(P:Pattern) .
  eq [[axiom{MSs} P:Pattern]] = axiom{MSs} liftToAxiom(P:Pattern) .
  ---- Step 2: if Pattern has metahead, lift to [[P]]
  ----         otherwise, lift to KisAxiom([[P]]) .
  eq liftToAxiom(P:Pattern)
   = if   hasMetaHead(P:Pattern)
     then [[P:Pattern]]
     else KisAxiom([[P:Pattern]])
     fi .
  op liftToAxiom : Pattern -> Pattern .
  op hasMetaHead : Pattern -> Bool .
  eq hasMetaHead(H:MetaHead(Ps)) = true .
  eq hasMetaHead(H:ObjectHead(Ps)) = false .
  eq hasMetaHead(S:String) = true .


 ---- Lifting sort declarations
 ceq [[sort OS:ObjectSort]] 
   = axiom KisSort([[OS:ObjectSort]])
     axiom equals{KSort, KS}(
             [[OS:ObjectSort]],
             Ksort(name(OS:ObjectSort), ListOfKSortToKSortList(Ps:PatternList)))
  if H:MetaHead(Ps:PatternList) := [[OS:ObjectSort]] .
  ---- Calculating the names (strings) of atomic object sorts and
  ---- parametric sorts.
  ---- For example, name(Nat) = "Nat", name(List) = "List".
  op name : AtomicObjectSort -> String .
  eq name(S:AtomicObjectSort) = string(getName(upTerm(S:AtomicObjectSort))) .
  op name : ParametricObjectSort -> String .
  eq name(PS:ParametricObjectSort) 
   = string(getName(upTerm(PS:ParametricObjectSort))) .
  op name : ObjectSort -> String .
  eq name(PS:ParametricObjectSort{Ss:SortList})
   = name(PS:ParametricObjectSort) .
  ---- Convert a list of meta-level patterns (whose sorts are KSort)
  ---- to one meta-level pattern of the sort KSortList . 
  ---- KnilKSortList and KconsKSortList are constructors of KSortList.
  op ListOfKSortToKSortList : PatternList -> Pattern .
  eq ListOfKSortToKSortList(.) = KnilKSortList() .
  eq ListOfKSortToKSortList(P:Pattern) 
   = KconsKSortList(P:Pattern, KnilKSortList()) .
  eq ListOfKSortToKSortList(P:Pattern, Ps)
   = KconsKSortList(P:Pattern, ListOfKSortToKSortList(Ps)) .



  ---- TODO:: We shouldn't need this case!
  ---- Lifting object symbols declarations: non-parametric constant case
  ---- [[symbol f() : S]]
  ---- = symbol Kf() : KPattern
  ----   axiom Kf(.) = Kapplication(Ksymbol("f", nil, nil, S), nil)
  eq [[symbol H:AtomicObjectHead() : S:ObjectSort]]
   = symbol [[H:AtomicObjectHead]]() : KPattern
     axiom equals{KPattern,KS}(
        [[H:AtomicObjectHead()]],
        Kapplication(Ksymbol(name(H:AtomicObjectHead),
                             KnilKSortList(),
                             KnilKSortList(),
                             [[S:ObjectSort]]), 
                     KnilKPatternList())) .

  ---- Lifting object symbols declarations: non-parametric non-constant case
  ---- [[symbol f(S1,...,Sn) : S]]
  ---- = symbol Kf(KPattern,...,KPattern) : KPattern
  ----   axiom Kf(P1,...,Pn) 
  ----         = Kapplication(Ksymbol("f", nil, (S1,...,Sn), S),
  ----                        (P1,...,Pn))
   
  eq [[symbol H:AtomicObjectHead(OSs) : S:ObjectSort]]
   = symbol
       [[H:AtomicObjectHead]](makeListOfKPattern(len(OSs))) : KPattern
     axiom equals{KPattern,KS}(
       [[H:AtomicObjectHead]](makeListOfKPatternVar(len(OSs))),
       Kapplication(
         Ksymbol(name(H:AtomicObjectHead),
                 KnilKSortList(),
                 ListOfKSortToKSortList([[OSs]]),
                 [[S:ObjectSort]]),
         ListOfKPatternToKPatternList(makeListOfKPatternVar(len(OSs))))) .
  op name : AtomicObjectHead -> String .
  eq name(H:AtomicObjectHead) = string(getName(upTerm(H:AtomicObjectHead))) .
  ---- Some aux functions
  op makeListOfKPattern : NzNat -> MetaSortList . 
  eq makeListOfKPattern(1) = KPattern .
  eq makeListOfKPattern(N:Nat) = KPattern, makeListOfKPattern(N:Nat + -1) .

  op makeKPatternVar : NzNat -> Pattern .
  eq makeKPatternVar(N:Nat)
   = makeVariableName("P", N:Nat) : KPattern . 
  op makeVariableName : String Nat -> VariableName .
  eq makeVariableName(Prefix:String, N:Nat)
   = downTerm(
       qid(Prefix:String + string(N:Nat, 10) + ".VariableName"),
       ERROR@VariableName) .
  op makeListOfKPatternVar : NzNat -> PatternList .
  eq makeListOfKPatternVar(1) = makeKPatternVar(1) .
  eq makeListOfKPatternVar(N:NzNat)
   = makeListOfKPatternVar(N:NzNat + -1) @ makeKPatternVar(N:NzNat) .
  ---- Convert a list of meta-level patterns (whose sorts are KPattern)
  ---- to the meta-level pattern of sort KPatternList .
  op ListOfKPatternToKPatternList : PatternList -> Pattern .
  eq ListOfKPatternToKPatternList(.)
   = KnilKPatternList() .
  eq ListOfKPatternToKPatternList(P:Pattern)
   = KconsKPatternList(P:Pattern, KnilKPatternList()) .
  eq ListOfKPatternToKPatternList(P:Pattern, Ps)
   = KconsKPatternList(P:Pattern, ListOfKPatternToKPatternList(Ps)) .


  ---- TODO:: We shouldn't need this case!
  ---- Lifting object symbols declarations: parametric constant case
  ---- [[symbol f{S1,...,Sn}() : S]]
  ---- = symbol Kf(KSort,...,KSort) : KPattern
  ---- = axiom Kf(S1,...,Sn)
  ----         = Kapplication(Ksymbol("f", (S1,...,Sn), nil, S),
  ----                        nil)
  eq [[symbol PH{OSs}() : S:ObjectSort]]
   = symbol [[PH]](makeListOfKSort(len(OSs))) : KPattern
     axiom equals{KPattern,KS}(
       [[PH]]([[OSs]]),
       Kapplication(
         Ksymbol(name(PH),
                 ListOfKSortToKSortList([[OSs]]),
                 KnilKSortList(),
                 [[S:ObjectSort]]),
         KnilKPatternList())) .
  ---- Some aux functions
  op makeListOfKSort : NzNat -> MetaSortList .
  eq makeListOfKSort(1) = KSort .
  eq makeListOfKSort(N:NzNat)
   = KSort, makeListOfKSort(N:NzNat + -1) .


  ---- Lifting object symbols declarations: parametric non-constant case
  ---- [[symbol f{S1...Sn}(T1...Tm) : S]]
  ---- = symbol Kf(KSort,..,KSort,KPattern,...,KPattern) : KPattern
  ---- = axiom Kf(S1,...,Sn,P1,...,Pn)
  ----         = Kapplication(
  ----             Ksymbol("f", (S1...Sn), (T1...Tn), S),
  ----             (P1...Pn)) 
  eq [[symbol PH{OSs}(OSs') : S:ObjectSort]]
   = symbol [[PH]](makeListOfKSort(len(OSs)) 
                 @ makeListOfKPattern(len(OSs'))) : KPattern
     axiom equals{KPattern,KS}(
       [[PH]]([[OSs]] @ makeListOfKPatternVar(len(OSs'))),
       Kapplication(
         Ksymbol(name(PH),
                 ListOfKSortToKSortList([[OSs]]),
                 ListOfKSortToKSortList([[OSs']]),
                 [[S:ObjectSort]]),
         ListOfKPatternToKPatternList(makeListOfKPatternVar(len(OSs'))))) .
  op name : ParametricHead -> String .
  eq name(PH) = string(getName(upTerm(PH))) .



  ---- Lifting object alias declarations: parametric case
  ---- For the same reason, object sort variables in the curly
  ---- bracket after "alias" is of no use in this implementation.
  ---- [[alias{...} g{S1...Sn}(P1...Pn) := Q]]
  ---- = symbol Kg(KSort,...,KSort,KPattern,...,KPattern) : KPattern
  ----   axiom Kg(S1,...,Sn,P1,...,Pn) = [[Q]]
  eq [[alias{OSs'} PH{OSs}(Ps) := Q:Pattern]]
   = symbol [[PH]](makeListOfKSort(len(OSs))
                 @ makeListOfKPattern(len(Ps))) : KPattern
     axiom equals{KPattern,KS}(
       [[PH]]([[OSs]] @ [[Ps]]),
       [[Q:Pattern]]) .



  ---- Lifting meta-level declarations: just keep them!
  eq [[sort MS]] = sort MS .
  eq [[symbol MH() : MS]] = symbol MH() : MS .
  eq [[symbol MH(MSs) : MS]] = symbol MH(MSs) : MS .





  ---- An aux function that takes anything to its corresponding
  ---- atomic meta head at the meta-theory. For example:
  ----   'plus.AtomicObjectHead     ---> 'Kplus.AtomicMetaHead
  ----   'cons.ParametricHead       ---> 'Kcons.AtomicMetaHead
  ----   'Nat.AtomicObjectSort      ---> 'KNat.AtomicMetaHead
  ----   'List.ParametricObjectSort ---> 'KList.AtomicMetaHead
  op addK : Constant -> Constant .
  eq addK(C:Constant) = qid("K" 
                            + string(getName(C:Constant)) 
                            + ".AtomicMetaHead") .

  ---)



  op exists     : -> ParametricHead .
  op not        : -> ParametricHead .
  op and        : -> ParametricHead .
  op or         : -> ParametricHead .
  op implies    : -> ParametricHead .
  op iff        : -> ParametricHead .
  op equals     : -> ParametricHead .
  op forall     : -> ParametricHead .
  op ceil       : -> ParametricHead .

  op KPred        : -> MetaSort .
  op KChar        : -> MetaSort .
  op KString      : -> MetaSort .
  op KSort        : -> MetaSort .
  op KSortList    : -> MetaSort .
  op KSymbol      : -> MetaSort .
  op KSymbolList  : -> MetaSort .
  op KVariable    : -> MetaSort .
  op KPattern     : -> MetaSort .
  op KPatternList : -> MetaSort .

  op KS   : -> MetaSortVariable .
  op KisAxiom    : -> AtomicMetaHead .
  op KisSort     : -> AtomicMetaHead .
  op KisSymbol   : -> AtomicMetaHead .

  op Kvariable  : -> AtomicMetaHead  .
  op Kexists    : -> AtomicMetaHead  .
  op Knot       : -> AtomicMetaHead  .
  op Kand       : -> AtomicMetaHead  .
  op Kor        : -> AtomicMetaHead  .
  op Kimplies   : -> AtomicMetaHead  .
  op Kiff       : -> AtomicMetaHead  .
  op Kequals    : -> AtomicMetaHead  .
  op Kforall    : -> AtomicMetaHead  .
  op Kbottom    : -> AtomicMetaHead  .
  op Ktop       : -> AtomicMetaHead  .


  op Ksort     : -> AtomicMetaHead .
  op Ksymbol   : -> AtomicMetaHead .
  op KnilKSortList : -> AtomicMetaHead .
  op KconsKSortList : -> AtomicMetaHead .
  op KnilKPatternList : -> AtomicMetaHead .
  op KconsKPatternList : -> AtomicMetaHead .
  op Kapplication : -> AtomicMetaHead .


endfm


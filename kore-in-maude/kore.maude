---- Run Maude with option -no-prelude.  We only need the builtin strings
---- from the Maude prelude, which we reinclude/rehook below (ignore warning):

fmod STRING is

  sort String .
  op <Strings> : -> String [special(id-hook StringSymbol)] .

endfm

fmod SORT is

  sorts   Sort   SortList .
  subsort Sort < SortList .
  op _,_ : Sort SortList -> SortList [prec 52] .

  ---- Atomic sorts examples: Nat Int AExp
  ---- Parametric sorts     : List{Nat} Ctxt{S, Nat} List{List{S}}
  ---- Sort variables       : S S1 S2 
  sorts AtomicSort SortVar ParSort .
  subsort AtomicSort < Sort . 
  subsort SortVar    < Sort .
  op _{_} : ParSort SortList -> Sort [prec 50] .

  sort SortVarList .
  subsort SortVar < SortVarList .
  subsort SortVarList < SortList .
  op _,_ : SortVar SortVarList -> SortVarList [prec 52] .

endfm

fmod SYMBOL is

  protecting SORT .

  ---- Symbol identifiers examples: plusAExp ctxtapp{S1, S2}
  ----   - Constant symbols
  ----   - NonConstant symbols
  sorts SymbolId ConstSymbolId NConstSymbolId .
  subsorts ConstSymbolId NConstSymbolId < SymbolId .
  
  ---- Decorated symbols examples:
  ----  - plus(Nat, Nat) : Nat
  ----  - true : Bool
  sort DecoSymbol .
  op _:_ : ConstSymbolId Sort -> DecoSymbol 
    [format(d s s d) prec 52] .
  op _`(_`):_ : NConstSymbolId SortList Sort -> DecoSymbol 
    [format(d d d d s s d) prec 52] .

  ---- Constant symbols identifier: non-parametric and parametric:
  sorts AtomicConstSymbolId ParConstSymbolId .
  subsort AtomicConstSymbolId < ConstSymbolId .
  op _{_} : ParConstSymbolId SortList -> ConstSymbolId 
    [format(d d d o d) prec 50] .

  ---- Non-constant symbols identifier: non-par and par:
  sorts AtomicNConstSymbolId ParNConstSymbolId .
  subsort AtomicNConstSymbolId < NConstSymbolId .
  op _{_} : ParNConstSymbolId SortList -> NConstSymbolId 
    [format(d d d o d) prec 50] .

endfm

---- This is the module for matching logic variables.
---- Known issue: Maude cannot parse x:s as x : s;
---- We need some space around the colon ":" when
---- parsing variables.
---- To get around this (not a big) issue,
---- in files *-tokens.maude where we define terminals,
---- we define some "frontend sugar" that allows us
---- write x:s instead of x : s.
fmod VARIABLE is

  protecting SORT .

  sorts VariableName Variable .
  op _:_ : VariableName Sort -> Variable [prec 52] .

endfm


fmod PATTERN is

  protecting SYMBOL     .
  protecting VARIABLE   .
  protecting STRING     .

  sorts Pattern PatternList .
  subsort Pattern < PatternList .
  op _,_ : Pattern PatternList -> PatternList [prec 58] .  

  subsort Variable < Pattern .

  subsort ConstSymbolId < Pattern .
  op _`(_`) : NConstSymbolId PatternList -> Pattern [prec 53] .

  op \not{_}`(_`) : Sort Pattern -> Pattern 
    [format(d d d o d d d d) prec 52] .
  op \and{_}`(_,_`) : Sort Pattern Pattern -> Pattern 
    [format(d d d o d d d d d d) prec 52] .
  op \exists{_,_}`(_,_`) : Sort Sort Variable Pattern -> Pattern
    [format(d d d d d o d d d d d d) prec 52] . 

  ---- strings
  subsort String < Pattern .

  ---- alias (defined later in this module)
  subsort ConstAliasId < Pattern .
  op _`(_`) : NConstAliasId PatternList -> Pattern [prec 53] .


  ---- fmod ALIAS is

  ---- An alias is something that enjoys the same 
  ---- syntax / grammar as a symbol but semantically
  ---- different from a symbol.
  ---- Therefore, it is reasonable to expect something (syntactic)
  ---- similar to happen with alias.

  ---- Alias should has its own module ALIAS.
  ---- The reason we put it here under PATTERN module is that
  ---- ALIAS depends on PATTERN and PATTERN depends on ALIAS,
  ---- and Maude does not allow this.
  
  sorts AliasId ConstAliasId NConstAliasId .
  subsorts ConstAliasId NConstAliasId < AliasId .
  
  ---- Constant alias identifier: non-parametric and parametric:
  sorts AtomicConstAliasId ParConstAliasId .
  subsort AtomicConstAliasId < ConstAliasId .
  op _{_} : ParConstAliasId SortList -> ConstAliasId
    [format(d d d o d) prec 50] .

  ---- Non-constant alias identifier: non-par and par:
  sorts AtomicNConstAliasId ParNConstAliasId .
  subsort AtomicNConstAliasId < NConstAliasId .
  op _{_} : ParNConstAliasId SortList -> NConstAliasId
    [format(d d d o d) prec 50] .

  ---- endfm ALIAS

endfm

fmod MODULE is
  
  protecting PATTERN .

  sorts Module Modules .
  subsort Module < Modules .
  op __ : Module Modules -> Modules 
    [format(d n d) prec 90] .

  sort ModuleName Sentence Sentences .
  op module__endmodule : ModuleName Sentences -> Module 
    [format(nb o n++ n--b o) prec 80] .

  subsort Sentence < Sentences .
  op __ : Sentence Sentences -> Sentences
    [format(d n d) prec 75] .

  op import_ : ModuleName -> Sentence [format(ib o d) prec 66] .
  op sort_ : Sort -> Sentence [format(ib o d) prec 66] .
  op symbol_ : DecoSymbol -> Sentence [format(ib o d) prec 66] .
  op alias_:=_ : Pattern Pattern -> Sentence [format(ib o d d d) prec 66] .
  op axiom_ : Pattern -> Sentence [format(ib n++io --) prec 66] .
  op axiom{_}_ : SortVarList Pattern -> Sentence 
    [format(ib o d d n++i --) prec 66] .
  
endfm

---- Reflection
---- Kore's syntax is reflexive, in the sense that
---- everything can be parsed as a Pattern, and a
---- Pattern can be parsed as anything. The general
---- principle is "No-Surprise":
----  - something won't be parsed as a Pattern unless
----    it has to.
----  - a Pattern won't be parsed as something(else)
----    unless it has to.

---- Reflection is implemented by the following modules
---- with overloaded operators.
---- (Overloaded) operators are assigned with selected
---- precedence so that there is "No-Surprise".

---- Reflect Sort as Pattern

fmod SORT-AS-PATTERN is

  protecting PATTERN .

  sorts   Sort-As-Pattern   SortList-As-PatternList .

  subsort Sort-As-Pattern         < Pattern     .
  subsort SortList-As-PatternList < PatternList . 
  
  subsort Sort-As-Pattern < SortList-As-PatternList .
  op _,_ : Sort-As-Pattern SortList-As-PatternList -> SortList-As-PatternList 
    [prec 58] . ---- has the same prec as the (_,_) on PatternList.

  sorts AtomicSort-As-Pattern SortVar-As-Pattern ParSort-As-Pattern .
  subsort AtomicSort-As-Pattern < Sort-As-Pattern . 
  subsort SortVar-As-Pattern    < Sort-As-Pattern .
  op _{_} : ParSort-As-Pattern SortList-As-PatternList -> Sort-As-Pattern 
    [prec 53] . 

endfm

fmod REFLEXIVITY is

  protecting SORT-AS-PATTERN .

endfm

---(
---- Lift to the meta-theory ----
  sorts   Sort   SortList .
  subsort Sort < SortList .
  op _,_ : Sort SortList -> SortList [prec 52] .

  ---- Atomic sorts examples: Nat Int AExp
  ---- Parametric sorts     : List{Nat} Ctxt{S, Nat} List{List{S}}
  ---- Sort variables       : S S1 S2 
  sorts AtomicSort SortVar ParSort .
  subsort AtomicSort < Sort . 
  subsort SortVar    < Sort .
  op _{_} : ParSort SortList -> Sort [prec 50] .

  sort SortVarList .
  subsort SortVar < SortVarList .
  subsort SortVarList < SortList .
  op _,_ : SortVar SortVarList -> SortVarList [prec 52] .
---)

fmod KORE is

  protecting MODULE      .
  protecting REFLEXIVITY .

endfm


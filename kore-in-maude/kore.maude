---(
fmod STRING is

  sort String .
  op <Strings> : -> String [special(id-hook StringSymbol)] .

endfm
---)

fmod SORT is

  ---- Sorts examples:
  ----   Atomic sorts     : Nat Int AExp
  ----   Parametric sorts : List{Nat} Ctxt{S, Nat} List{List{S}}
  ----   Sort variables   : S S1 S2 

  sorts AtomicSort SortVariable ParametricSort Sort .
  subsorts AtomicSort < Sort .
  op _{_} : ParametricSort SortList -> Sort [prec 50] .

  sorts SortVariableList SortList .
  subsorts SortVariable < SortVariableList Sort < SortList .
  op _,_ : SortVariable SortVariableList -> SortVariableList [prec 52] .
  op _,_ : Sort SortList -> SortList [prec 52] .

endfm

fmod SYMBOL is

  protecting SORT .

  ---- Symbols examples:
  ----   Atomic constant symbols         : true false zero
  ----   Parametric constant symbols     : nil{Nat}
  ----   Atomic non-constant symbols     : plus
  ----   Parametric non-constant symbols : cons{Nat}

  sort Symbol . ---- Terminals defined in tokens.maude

  ---- Constuct parametric symbols:
  op _{_} : Symbol SortList -> Symbol [prec 50] . 

endfm

fmod ALIAS is

  protecting SORT .

  ---- Aliases have the same grammar / syntax with
  ---- symbols, but they are semantically different
  ---- from symbols.

  sort Alias .
  op _{_} : Alias SortList -> Alias [prec 50] .

endfm

fmod VARIABLE is

  protecting SORT .

  sorts VariableName Variable .
  op _:_ : VariableName Sort -> Variable [prec 52] .

  ---- Known issue: Maude cannot parse X:S.
  ---- It needs some space around the colon ":".
  ---- To solve this (not a big) issue,
  ---- we define a list of equations of the form
  ----   eq X:S = X : S .
  ---- in file "tokens.maude" to help Maude.

endfm


fmod PATTERN is

  protecting SYMBOL     .
  protecting ALIAS      .
  protecting VARIABLE   .
  protecting STRING     .

  sorts Pattern PatternList .
  subsort Pattern < PatternList .
  op _,_ : Pattern PatternList -> PatternList [prec 58] .  


  ---- Recall the grammar of patterns:
  ----   Pattern ::= Variable
  ----             | Symbol(PatternList)        // For non-constant symbols
  ----             | Symbol                     // For constant symbols
  ----             | \not{S}(Pattern)
  ----             | \and{S}(Pattern, Pattern)
  ----             | \exists{S,S'}(Variable, Pattern)
  ----             | Alias(PatternList)         // For non-constant aliases
  ----             | Alias                      // For constant aliases 
  ----             | "..."                      // Strings

  subsort Variable < Pattern .

  op _`(_`) : Symbol PatternList -> Pattern [prec 53] .

  subsort Symbol < Pattern .

  op \not{_}`(_`) : Sort Pattern -> Pattern 
     [format(d d d o d d d d) prec 52] .

  op \and{_}`(_,_`) : Sort Pattern Pattern -> Pattern 
     [format(d d d o d d d d d d) prec 52] .

  op \exists{_,_}`(_,_`) : Sort Sort Variable Pattern -> Pattern
     [format(d d d d d o d d d d d d) prec 52] . 

  op _`(_`) : Alias PatternList -> Pattern [prec 53] .

  subsort Alias < Pattern .

  subsort String < Pattern .

endfm

fmod MODULE is
  
  protecting PATTERN .

  sorts   Module   Modules .  
  subsort Module < Modules .
  op __ : Module Modules -> Modules [format(d n d) prec 90] .

  ---- Terminals of ModuleName are defined in "tokens.maude".
  sort ModuleName .

  sort    Sentence   Sentences .
  subsort Sentence < Sentences .
  op __ : Sentence Sentences -> Sentences [format(d n d) prec 75] .

  ---- A module has a name and some sentence(s) (at least one).
  op module__endmodule : ModuleName Sentences -> Module 
     [format(nb o n++ n--b o) prec 80] .

  ---- Various types of sentences:

  op import_ : ModuleName -> Sentence 
     [format(ib o d) prec 66] .

  op sort_ : Sort -> Sentence 
     [format(ib o d) prec 66] .

  op symbol_`(_`):_ : Symbol SortList Sort -> Sentence 
     [format(ib o d d d d d d) prec 66] .

  op symbol_:_ : Symbol Sort -> Sentence
     [format(ib o d d d) prec 66] .

  op alias_:=_ : Pattern Pattern -> Sentence 
     [format(ib o d d d) prec 66] .

  op axiom_ : Pattern -> Sentence 
     [format(ib n++io --) prec 66] .

  op axiom{_}_ : SortVariableList Pattern -> Sentence 
     [format(ib o d d n++i --) prec 66] .
  
endfm

---(

---- Reflection
---- Kore's syntax is reflexive, in the sense that
---- everything can be parsed as a Pattern, and a
---- Pattern can be parsed as anything. The general
---- principle is "No-Surprise":
----  - something won't be parsed as a Pattern unless
----    it has to.
----  - a Pattern won't be parsed as something(else)
----    unless it has to.

---- Reflection is implemented by the following modules
---- with overloaded operators.
---- (Overloaded) operators are assigned with selected
---- precedence so that there is "No-Surprise".

---- Reflect Sort as Pattern

fmod SORT-AS-PATTERN is

  protecting PATTERN .

  sorts   Sort-As-Pattern   SortList-As-PatternList .

  subsort Sort-As-Pattern         < Pattern     .
  subsort SortList-As-PatternList < PatternList . 
  
  subsort Sort-As-Pattern < SortList-As-PatternList .
  op _,_ : Sort-As-Pattern SortList-As-PatternList -> SortList-As-PatternList 
    [prec 58] . ---- has the same prec as the (_,_) on PatternList.

  sorts AtomicSort-As-Pattern SortVariable-As-Pattern ParametricSort-As-Pattern .
  subsort AtomicSort-As-Pattern < Sort-As-Pattern . 
  subsort SortVariable-As-Pattern    < Sort-As-Pattern .
  op _{_} : ParametricSort-As-Pattern SortList-As-PatternList -> Sort-As-Pattern 
    [prec 53] . 

endfm

fmod REFLEXIVITY is

  protecting SORT-AS-PATTERN .

endfm

---)


fmod KORE is

  protecting MODULE      .
  --- protecting REFLEXIVITY .

endfm


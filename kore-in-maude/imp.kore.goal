
module AEXP

  import ID

  sort   AExp
  
  /* syntax AExp  ::= Nat                    <---- NatToAExp    
   *                | Id                     <---- IdToAExp
   *                | AExp "+" AExp [strict] <---- plusAExp
   */
  
  symbol NatToAExp(Nat)       : AExp
  symbol IdToAExp(Nat)        : AExp
  symbol plusAExp(AExp, AExp) : AExp
  
  /* Axioms of functional symbols */
  /* No-Junk and No-Overlap axioms:
  /* Injection from Nat to AExp */
  
  /* Axiom of strictness: AExp "+" AExp [strict] */
  
  
  /* plusAExp is strict at the 1st argument:
   * plusAExp(C[X],E) = (gamma H:S . plusAExp(C[H:S],E))[X]
   * if C is of sort Ctxt{S, AExp}
   */
  axiom{S, R}
  \implies{R}(
  \equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S, AExp}),
          /* or ... KgetSort(C:KPattern, KModule("IMP")), ... */
  \equals{AExp, R}(plusAExp(ctxtapp{S,AExp}(C:KPattern, X:S), E:AExp),
                   ctxtapp{S,AExp}(
                     gamma{S,AExp}(
                       HOLE:S, 
                       plusAExp(ctxtapp{S,AExp}(C:KPattern, HOLE:S), E:AExp)), 
                     X:S)))

  /* plusAExp is strict at the 2nd argument:
   * plusAExp(E, C[X]) = (gamma H:S . plusAExp(E, C[H]))[X]
   * if C is of sort Ctxt{S, AExp}
   */
  axiom{S, R}
  \implies{R}(
  \equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S,AExp}),
  \equals{AExp, R}(ctxtapp{S,AExp}(
                     gamma{S,AExp}(
                       HOLE:S, 
                       plusAExp(ctxtapp{S,AExp}(C:KPattern, HOLE:S), E:AExp)), 
                     X:S)),
                   plusAExp(ctxtapp{S,AExp}(C:KPattern, X:S), E:AExp))
  
  /* ite is strict at the 1st argument:
   * ite(C[X], S1, S2) = (gamma H:S . ite(C[H], S1, S2))[X]
   * if C is of sort Ctxt{S, BExp}
   */
  axiom{S, R}
  \implies{R}(
  \equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S, BExp}),
  \equals{Stmt, R}(ite(ctxtapp{S, BExp}(C:KPattern, X:S), S1:Stmt, S2:Stmt),
                   ctxtapp{S, Stmt}(
                     gamma{S, Stmt}(
                       HOLE:S,
                       ite(ctxtapp{S, BExp}(C:KPattern, HOLE:S),
                           S1:Stmt, S2:Stmt)), X:S)))
endmodule

/**** IGNORE THE REST ****/
/**** IGNORE THE REST ****/
/**** IGNORE THE REST ****/
/**** IGNORE THE REST ****/


/* In the following we show how to define the semantics of IMP */

   
               

/* Define Boolean expressions */
sort   BExp

* syntax BExp  ::= Bool                       <---- BoolToBExp    
*                | "!" BExp       [strict]    <---- notBExp
*                | AExp ">=" AExp [seqstrict] <---- gteBExp
*/
symbol BoolToBExp(Bool)     : BExp
symbol notBExp(BExp)       : BExp
symbol gteBExp(AExp, AExp) : BExp

/* Axioms of functional symbols */
... ...

/* No-Junk and No-Overlap axioms:
   BoolToBExp, notBExp, and gteBExp are constructors. */
... ...

/* Injection axioms */
... ...

/* Axiom of strictness: "!" BExp       [strict] */
??? ???

/* Axiom of strictness: AExp ">=" AExp [seqstrict] */
??? ???

/* Define Block and Stmt */
sort   Block
sort   Stmt

/* syntax Block ::= "{" "}"      <---- emptyBlock  
 *                | "{" Stmt "}" <---- CurlyBracket(Stmt)
 */
symbol emptyBlock         : Block
symbol CurlyBracket(Stmt) : Block

/* syntax Stmt  ::= Block
 *                | Id "=" AExp ";"            [strict(2)]
 *                | "if" "(" BExp ")"
 *                  Block "else" Block         [strict(1)]
 *                | "while" "(" BExp ")" Block
 *                | Stmt Stmt
 */
 
symbol BlockToStmt(Block)      : Stmt
symbol asgn(Id, AExp)          : Stmt
symbol ite(BExp, Block, Block) : Stmt
symbol while(BExp, Block)      : Stmt
symbol seq(Stmt, Stmt)         : Stmt

/* Axioms of functional symbols */
... ...

/* No-Junk and No-Overlap axioms of constuctors */
... ...

/* Axiom of strictness: Id "=" AExp ";" [strict(2)] */
??? ???

/* Axiom of strictness: "if" "(" BExp ")" Block "else" Block [strict(1)] */
??? ???

/* Define Pgm and Ids */
/* syntax Pgm ::= "int" Ids ";" Stmt <---- pgm
 * syntax Ids ::= List{Id,","}       <---- List{Id} */

sort   Pgm
symbol pgm(Ids, Stmt) : Pgm

alias  Ids := List{Id}

/* Define infrastructure of rewriting systems */
sort   Cfg
symbol tcell(K, State) : Cfg
sort   K
symbol kcell(Pgm) : K
sort   State
symbol statecell(Map{Id, Nat}) : State

/* Define rewriting */
... ...
/* the predicate pattern \rewrites(left, right, S, S') means that
 * left => right, S is the sort of left and right,
 * and S' is the sort of the context
 * in which \rewrites(left, right, S, S') is mentioned.
 */
alias  \rewrites(_,_,_,_) := ... ...

/* syntax KResult ::= Int | Bool */
sort   KResult
symbol IntToKResult(Int)   : KResult
symbol BoolToKResult(Bool) : KResult

/* Define contexts */

... ...

/* Define rules */

/* rule I1 + I2 => I1 +Int I2 */
axiom   \rewrites(C[I1 + I2], C[I1 +Int I2], ..., ...) 

endmodule


---- The IMP theory in Kore ----

in imp-tokens.kore

fmod IMP is
  including TOKENS .
  op imp : -> Declarations .
  eq imp =




  -------------------------
  -------"imp.kore"--------
  -------------------------
  
  symbol
    ceil{S1,S2}(S1) : S2

  axiom{S1,S2}  
    ceil{S1,S2}(X : S1)

  alias{S1,S2}
    floor{S1,S2}(P : KPattern)
  := not{S2}(ceil{S1,S2}(not{S1}(P : KPattern)))

  alias{S}
    or{S}(P : KPattern , Q : KPattern)
  := not{S}(and{S}(
       not{S}(P : KPattern),
       not{S}(Q : KPattern)))


  sort Bool

  symbol true() : Bool
  symbol false() : Bool

  axiom or{Bool}(true(), false())

  symbol andBool(Bool, Bool) : Bool
  symbol notBool(Bool) : Bool

  sort Nat

  symbol zero() : Nat
  symbol succ(Nat) : Nat
  symbol plus(Nat, Nat) : Nat 

  sort List{S}

  symbol nil{S}() : List{S}
  symbol cons{S}(S, List{S}) : List{S}

  ---- No-Junk Axiom ----
  axiom{S}
    or{S}(
      nil{S}(),
      exists{S,List{S}}(
        X : S,
        exists{List{S}, List{S}}(
          L : List{S},
          cons{S}(X : S, L : List{S})))) 

  symbol append{S}(List{S}, List{S}) : List{S}

  ---- append(nil, L) = L
  axiom{S}
    equals{List{S}, R}(
      append{S}(nil{S}(), L : List{S}),
      L : List{S})

  ---- append(cons(X, L0), L) = cons(X, append(L0, L))
  axiom{S}
    equals{List{S}, R}(
      append{S}(cons{S}(X : S, L0 : List{S}), L : List{S}),
      cons{S}(X : S, append{S}(L0 : List{S}, L : List{S})))

  sort Map{S1,S2}

  symbol emp{S1,S2}() : Map{S1,S2}
  symbol merge{S1,S2}(Map{S1,S2},Map{S1,S2}) : Map{S1,S2}
  symbol bind{S1,S2}(S1,S2) : Map{S1,S2}


  sort Stmt
  symbol ite(BExp,Stmt,Stmt) : Stmt
  axiom{S,R} 
    implies{R}(
      choice{KSort,KPattern}(
        equals{KSort,KSort}(KgetSort(C : KPattern), KCtxt(S : KSort,KAExp())),
        top{KPattern}(), 
        bottom{KPattern}()),
      equals{Stmt, R}(
        ite(ctxtapp{S,BExp}(C : KPattern, X : S), S1 : Stmt, S2 : Stmt),
        ctxtapp{S,BExp}(
          gamma{S,BExp}(
            H : S,
            ite(ctxtapp{S,BExp}(C : KPattern, H : S), S1 : Stmt, S2 : Stmt)),
          X : S)))

  axiom{R}
    rewrites{R}(
      ctxtapp{Stmt,R}(C : KPattern, ite(tt(), S1 : Stmt, S2 : Stmt)),
      ctxtapp{Stmt,R}(C : KPattern, S1 : Stmt))

  axiom{R}
    rewrites{R}(
      ctxtapp{Stmt,R}(C : KPattern, ite(ff(), S1 : Stmt, S2 : Stmt)),
      ctxtapp{Stmt,R}(C : KPattern, S2 : Stmt))
  

  -------------------------
  ---- End "imp.kore" -----
  -------------------------

  .

endfm


reduce [[imp]] .

---- Should return true:
reduce [[imp]] == [[ [[imp]] ]] .




quit



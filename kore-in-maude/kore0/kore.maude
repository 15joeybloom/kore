---- This module contains a parser for the Kore language, whose
---- formal grammar is given in standard BNF notation.

---- General Design Principle: 
----   The lifting function from the
----   object-level to the meta-level should be as trivial and 
----   straightforward as possible, which means:
----   (1) One nonterminal has simply one way to be lifted;
----   (2) Different nonterminals have different ways to be lifted.

---- Following the General Design Principle, object-level things and
---- meta-level things should belong to different nonterminals (Maude
---- sorts) because they are treated differently when being lifted.






fmod KORE is

  protecting META-LEVEL *
    (sort Sort     to META-LEVEL.Sort,
     sort Variable to META-LEVEL.Variable) .


  ---- <Sort> ::= 
  ---- | <ObjectSort>
  ---- | <MetaSort>

  sorts Sort ObjectSort MetaSort .
  subsorts ObjectSort MetaSort < Sort .


  ---- <ObjectSort> ::=
  ---- | <ObjectSortConstructor> "{" <ObjectSortList> "}"
  ---- | <ObjectSortVariable>
  ---- Remark: Nonterminals <ObjectSortConstructor> and <ObjectSortVariable> 
  ----         are defined as sets of terminals using regular expressions.
  ----         Because Maude does not allow us to use regular expressions
  ----         to define nonterminals, we explicitly define a few terminals
  ----         as Maude constant operators in "tokens.maude".

  sort ObjectSortConstructor .
  sort ObjectSortList .
  sort ObjectSortVariable .
  subsort ObjectSortVariable < ObjectSort .
  op _`{_`} : ObjectSortConstructor ObjectSortList -> ObjectSort [prec 50] .


  ---- <ObjectSortList> ::=
  ---- | ""
  ---- | <ObjectSort>
  ---- | <ObjectSort> "," <ObjectSortList>

  op .ObjectSortList : -> ObjectSortList .
  subsort ObjectSort < ObjectSortList .
  op _,_ : ObjectSort ObjectSortList -> ObjectSortList [prec 52] .

  ---- Deal with (parsing) the empty list.
  op _`{`} : ObjectSortConstructor -> ObjectSort [prec 50] .
  eq SC:ObjectSortConstructor{}
   = SC:ObjectSortConstructor{.ObjectSortList} .


  ---- <MetaSort> ::=
  ---- | <MetaSortConstructor> "{" "}"
  ---- | <MetaSortVariable> 
  ---- Remark: <MetaSortConstructor> has only a finite number of terminals.

  sort MetaSortConstructor .
  sort MetaSortList .
  sort MetaSortVariable .
  subsort MetaSortVariable < MetaSort .
  op _`{`} : MetaSortConstructor -> MetaSort [prec 50] .

  op KPred        : -> MetaSortConstructor . 
  op KChar        : -> MetaSortConstructor . 
  op KString      : -> MetaSortConstructor . 
  op KSort        : -> MetaSortConstructor . 
  op KSortList    : -> MetaSortConstructor . 
  op KSymbol      : -> MetaSortConstructor . 
  op KSymbolList  : -> MetaSortConstructor .   
  op KVariable    : -> MetaSortConstructor . 
  op KPattern     : -> MetaSortConstructor . 
  op KPatternList : -> MetaSortConstructor . 
  op KAxiom       : -> MetaSortConstructor .  
  op KAxiomList   : -> MetaSortConstructor . 

  op KS           : -> MetaSortVariable .
  op KS1          : -> MetaSortVariable .
  op KS2          : -> MetaSortVariable .
  op KS3          : -> MetaSortVariable .
  op KS'          : -> MetaSortVariable .
  op KS''         : -> MetaSortVariable .


  ---- <MetaSortList> ::=
  ---- | ""
  ---- | <MetaSort>
  ---- | <MetaSort> "," <MetaSortList>

  op .MetaSortList : -> MetaSortList .
  subsort MetaSort < MetaSortList .
  op _,_ : MetaSort MetaSortList -> MetaSortList [prec 52] .


 
  ---- Symbols are elements of a signature:
  ---- - Atomic constant symbols         : true{} false{} zero{}
  ---- - Parametric constant symbols     : nil{Nat}
  ---- - Atomic non-constant symbols     : plus{}
  ---- - Parametric non-constant symbols : cons{Nat}


  ---- <Symbol> ::= 
  ---- | <ObjectSymbol>
  ---- | <MetaSymbol>

  sorts Symbol ObjectSymbol MetaSymbol .
  subsorts ObjectSymbol MetaSymbol < Symbol .


  ---- <ObjectSymbol> ::=
  ---- | <ObjectSymbolConstructor> "{" <ObjectSortList> "}"

  sort ObjectSymbolConstructor .
  op _`{_`} : ObjectSymbolConstructor ObjectSortList 
           -> ObjectSymbol [prec 50] .
  op _`{`}  : ObjectSymbolConstructor 
           -> ObjectSymbol [prec 50] .
  eq SC:ObjectSymbolConstructor{}
   = SC:ObjectSymbolConstructor{.ObjectSortList} .


  ---- <MetaSymbol> ::=
  ---- | <MetaSymbolConstructor> "{" <MetaSortList> "}"
  ---- Remark: <MetaSymbolConstructor> has a finite number of terminals,

  sort MetaSymbolConstructor .
  op _`{_`} : MetaSymbolConstructor MetaSortList 
           -> MetaSymbol [prec 50] .
  op _`{`}  : MetaSymbolConstructor 
           -> MetaSymbol [prec 50] .
  eq SC:MetaSymbolConstructor{}
   = SC:MetaSymbolConstructor{.MetaSortList} .
  
  ---- Pick better names.
  op Ksort             : -> MetaSymbolConstructor .
  op KnilKSortList     : -> MetaSymbolConstructor .
  op KconsKSortList    : -> MetaSymbolConstructor .
  op Ksymbol           : -> MetaSymbolConstructor .
  op Kvariable         : -> MetaSymbolConstructor .
  op Kapplication      : -> MetaSymbolConstructor .
  op Kand              : -> MetaSymbolConstructor .
  op Knot              : -> MetaSymbolConstructor .
  op Kexists           : -> MetaSymbolConstructor .
  op KnilKPatternList  : -> MetaSymbolConstructor .
  op KconsKPatternList : -> MetaSymbolConstructor .
  op Kaxiom            : -> MetaSymbolConstructor .
  op KgetSort          : -> MetaSymbolConstructor .
  op KVariableToKPattern : -> MetaSymbolConstructor .




  ---- Aliases have the same grammar / syntax as symbols,
  ---- for simplicity. But, semantically, aliases are *not*
  ---- symbols. Semantically, aliases do not exist. They
  ---- desugar into patterns.

  ---- Remark: the grammar for aliases is so similar with the
  ----         one for symbols that I simply copy-and-paste
  ----         the symbol grammar and replace "Symbol" with
  ----         "Alias" in the following.

  ---- <Alias> ::= 
  ---- | <ObjectAlias>
  ---- | <MetaAlias>

  sorts Alias ObjectAlias MetaAlias .
  subsorts ObjectAlias MetaAlias < Alias .

  ---- <ObjectAlias> ::=
  ---- | <ObjectAliasConstructor> "{" <ObjectSortList> "}"

  sort ObjectAliasConstructor .
  op _`{_`} : ObjectAliasConstructor ObjectSortList 
           -> ObjectAlias [prec 50] .
  op _`{`}  : ObjectAliasConstructor 
           -> ObjectAlias [prec 50] .
  eq SC:ObjectAliasConstructor{}
   = SC:ObjectAliasConstructor{.ObjectSortList} .


  ---- <MetaAlias> ::=
  ---- | <MetaAliasConstructor> "{" <MetaSortList> "}"
  ---- Remark: <MetaAliasConstructor> has a finite number of terminals,

  sort MetaAliasConstructor .
  op _`{_`} : MetaAliasConstructor MetaSortList 
           -> MetaAlias [prec 50] .
  op _`{`}  : MetaAliasConstructor 
           -> MetaAlias [prec 50] .
  eq SC:MetaAliasConstructor{}
   = SC:MetaAliasConstructor{.MetaSortList} .
  
  ---- More to go ...
  op Kor             : -> MetaAliasConstructor .





  ---- <Variable> ::=
  ---- | <ObjectVariable>
  ---- | <MetaVariable>

  sorts Variable ObjectVariable MetaVariable .
  subsorts ObjectVariable MetaVariable < Variable .


  sort VariableName .

  ---- <ObjectVariable> ::=
  ---- | <VariableName> ":" <ObjectSort>

  op _:_ : VariableName ObjectSort -> ObjectVariable [prec 52] .


  ---- <MetaVariable> ::=
  ---- | <VariableName> ":" <MetaSort>

  op _:_ : VariableName MetaSort -> MetaVariable [prec 52] .




  ---- <Pattern> ::=
  ---- | <ObjectPattern>
  ---- | <MetaPattern>

  sorts Pattern ObjectPattern MetaPattern .
  subsorts ObjectPattern MetaPattern < Pattern .


  ---- <ObjectPattern> ::= 
  ---- | <ObjectVariable>                       
  ---- | <ObjectSymbol> "(" <ObjectPatternList> ")"   
  ---- | <ObjectAlias> "(" <ObjectPatternList> ")"   
  ---- | "\not" "{" <ObjectSort> "}" "(" <ObjectPattern> ")"
  ---- | "\and" "{" <ObjectSort> "}" 
  ----          "(" <ObjectPattern> "," <ObjectPattern> ")"
  ---- | "\exists" "{" <ObjectSort> "," <ObjectSort> "}" 
  ----             "(" <ObjectVariable> "," <ObjectPattern> ")"

  subsort ObjectVariable < ObjectPattern .

  op _`(_`) : ObjectSymbol ObjectPatternList -> ObjectPattern [prec 53] .

  op _`(_`) : ObjectAlias  ObjectPatternList -> ObjectPattern [prec 53] .

  op \not`{_`}`(_`) : ObjectSort ObjectPattern -> ObjectPattern 
     [format(d d d d d d d d) prec 52] .

  op \and`{_`}`(_,_`) : ObjectSort ObjectPattern ObjectPattern 
                     -> ObjectPattern 
     [format(d d d d d d d d d d) prec 52] .

  op \exists`{_,_`}`(_,_`) : ObjectSort ObjectSort ObjectVariable ObjectPattern 
                          -> ObjectPattern
     [format(d d d d d d d d d d d d) prec 52] .

  ---- Deal with empty list.
  op _`(`)  : ObjectSymbol -> ObjectPattern [prec 53] .
  op _`(`)  : ObjectAlias  -> ObjectPattern [prec 53] .
  eq S:ObjectSymbol() = S:ObjectSymbol(.ObjectPatternList) .
  eq S:ObjectAlias()  = S:ObjectAlias (.ObjectPatternList) .

  ---- <ObjectPatternList> ::=
  ---- | ""
  ---- | <ObjectPattern>
  ---- | <ObjectPattern> "," <ObjectPatternList>

  sort ObjectPatternList .

  subsort ObjectPattern < ObjectPatternList .
  op .ObjectPatternList : -> ObjectPatternList .
  op _,_ : ObjectPattern ObjectPatternList -> ObjectPatternList [prec 58] .  


  ---- <MetaPattern> ::= 
  ---- | <MetaVariable>                       
  ---- | <MetaSymbol> "(" <MetaPatternList> ")"   
  ---- | <MetaAlias> "(" <MetaPatternList> ")"   
  ---- | "\not" "{" <MetaSort> "}" "(" <MetaPattern> ")"
  ---- | "\and" "{" <MetaSort> "}" 
  ----          "(" <MetaPattern> "," <MetaPattern> ")"
  ---- | "\exists" "{" <MetaSort> "," <MetaSort> "}" 
  ----             "(" <MetaVariable> "," <MetaPattern> ")"
  ---- | <String> // quoted texts

  subsort MetaVariable < MetaPattern .

  op _`(_`) : MetaSymbol MetaPatternList -> MetaPattern [prec 53] .

  op _`(_`) : MetaAlias  MetaPatternList -> MetaPattern [prec 53] .

  op \not`{_`}`(_`) : MetaSort MetaPattern -> MetaPattern 
     [format(d d d d d d d d) prec 52] .

  op \and`{_`}`(_,_`) : MetaSort MetaPattern MetaPattern 
                     -> MetaPattern 
     [format(d d d d d d d d d d) prec 52] .

  op \exists`{_,_`}`(_,_`) : MetaSort MetaSort MetaVariable MetaPattern 
                          -> MetaPattern
     [format(d d d d d d d d d d d d) prec 52] .

  protecting STRING .
  subsort String < MetaPattern .


  ---- Deal with empty list.
  op _`(`)  : MetaSymbol -> MetaPattern [prec 53] .
  op _`(`)  : MetaAlias  -> MetaPattern [prec 53] .
  eq S:MetaSymbol() = S:MetaSymbol(.MetaPatternList) .
  eq S:MetaAlias()  = S:MetaAlias (.MetaPatternList) .

  ---- <MetaPatternList> ::=
  ---- | ""
  ---- | <MetaPattern>
  ---- | <MetaPattern> "," <MetaPatternList>

  sort MetaPatternList .

  subsort MetaPattern < MetaPatternList .
  op .MetaPatternList : -> MetaPatternList .
  op _,_ : MetaPattern MetaPatternList -> MetaPatternList [prec 58] .  

  

  sort PatternList .
  subsort MetaPatternList ObjectPatternList < PatternList .
  op _,_ : Pattern PatternList -> PatternList [prec 58] .
  op _@_ : PatternList PatternList -> PatternList .
  eq .ObjectPatternList @ Ps:PatternList = Ps:PatternList .
  eq .MetaPatternList @ Ps:PatternList = Ps:PatternList .
  eq P:Pattern @ Ps:PatternList = P:Pattern, Ps:PatternList .
  eq (P:Pattern, Ps:PatternList) @ Ps':PatternList
   = P:Pattern, (Ps:PatternList @ Ps':PatternList) .



  ---- Define lifting bracket(s) [[_]].
  ---- Preferably [[_]] should be defined using Maude's META-LEVEL.
  ---- For intuition, let's not worry about the length of our code.
  ---- We'll enumerate all equations, one for each terminals, in "tokens.maude".

  ---- General lifting principle:
  ----   Object-level things are lifted to their meta-representations;
  ----   Meta-level things are not lifted and keep unchanged.


  ---- Lift <ObjectSortVariable> to <MetaVariable>
  op [[_]] : ObjectSortVariable -> MetaVariable .

  ---- Lift <ObjectSortConstructor> to <MetaSymbol>
  op [[_]] : ObjectSortConstructor -> MetaSymbol .

  ---- Lift <ObjectSort> to <MetaPattern>
  op [[_]] : ObjectSort -> MetaPattern .
  eq [[SC:ObjectSortConstructor{Ss:ObjectSortList}]]
   = [[SC:ObjectSortConstructor]]([[Ss:ObjectSortList]]) .

  ---- Lift <ObjectSortList> to <MetaPatternList>, elementwisely
  op [[_]] : ObjectSortList -> MetaPatternList .
  eq [[.ObjectSortList]] = .MetaPatternList .
  eq [[S:ObjectSort, Ss:ObjectSortList]]
   = [[S:ObjectSort]], [[Ss:ObjectSortList]] . 

  ---- Some examples of lifting a symbol-application pattern.

  ---- Example 1:
  ----   [[cons{Nat}(P, Q)]]
  ----   = kcons{}([[Nat]], [[P]], [[Q]]) 

  ---- Example 2 (the general case):
  ----   [[sigma{S1,...,Sn}(P1,...,Pn)]]
  ----   = ksigma{}([[S1]],...,[[Sn]],[[P1]],...,[[Pn]])

  ---- Lift <ObjectSymbolConstructor> to <MetaSymbol>
  op [[_]] : ObjectSymbolConstructor -> MetaSymbol .



  ---- Lift <VariableName> to <MetaPattern>
  ----   [[X]] = "X"
  ----   [[HOLE]] = "HOLE"
  op [[_]] : VariableName -> MetaPattern .
  eq [[X:VariableName]]
   = string(getName(upTerm(X:VariableName))) .
  
  ---- Lift <ObjectVariable> to <MetaPattern> of sort KVariable
  op [[_]]1 : ObjectVariable -> MetaPattern .
  eq [[X:VariableName : S:ObjectSort]]1
   = Kvariable{}([[X:VariableName]], [[S:ObjectSort]]) .

  ---- Lift <Pattern> to <MetaPattern> 
  op [[_]] : Pattern -> MetaPattern .
  op [[_]] : PatternList -> MetaPatternList . ---- elementwisely

  ---- lifting variables
  eq [[V:ObjectVariable]] = KVariableToKPattern{}([[V:ObjectVariable]]1) .
  eq [[V:MetaVariable]] = V:MetaVariable .

  ---- lifting symbol applications
  eq [[Sigma:ObjectSymbolConstructor{Ss:ObjectSortList}(Ps:PatternList)]] 
   = [[Sigma:ObjectSymbolConstructor]]([[Ss:ObjectSortList]] @ [[Ps:PatternList]]) .
  eq [[Sigma:MetaSymbol(Ps:PatternList)]]
   = Sigma:MetaSymbol([[Ps:PatternList]]) .

  ---- lifting \and
  eq [[\and{S:ObjectSort}(P:Pattern, Q:Pattern)]]
   = Kand{}([[S:ObjectSort]], [[P:Pattern]], [[Q:Pattern]]) .
  eq [[\and{S:MetaSort}(P:Pattern, Q:Pattern)]]
   = \and{S:MetaSort}([[P:Pattern]], [[Q:Pattern]]) .

  ---- lifting \not
  eq [[\not{S:ObjectSort}(P:Pattern)]]
   = Knot{}([[S:ObjectSort]], [[P:Pattern]]) .
  eq [[\not{S:MetaSort}(P:Pattern)]]
   = \not{S:MetaSort}([[P:Pattern]]) .

  ---- lifting \exists
  eq [[\exists{S1:ObjectSort, S2:ObjectSort}(V:Variable, P:Pattern)]]
   = Kexists{}([[S1:ObjectSort]], [[S2:ObjectSort]], [[V:Variable]]1, [[P:Pattern]]) .

  eq [[\exists{S1:MetaSort, S2:MetaSort}(V:Variable, P:Pattern)]]
   = \exists{S1:MetaSort, S2:MetaSort}([[V:Variable]], [[P:Pattern]]) .

  ---- lifting a list
  eq [[.MetaPatternList]] = .MetaPatternList .
  eq [[.ObjectPatternList]] = .MetaPatternList .
  eq [[P:Pattern, Ps:PatternList]] = [[P:Pattern]], [[Ps:PatternList]] .


endfm

---(

  ---- <Sentence>  ::= "sort" <Sort>
  ----               | "symbol" <Symbol> "(" <SortList> ")" ":" <Sort>
  ----               | "axiom" "{" <SortList> "}" <Pattern>
  ----               | "alias" "{" <SortList> "}" <Pattern> ":=" <Pattern>
  ----
  ---- <Sentences> ::= <Sentence>
  ----               | <Sentence> <Sentences>

  sort Sentence Sentences .
  subsort Sentence < Sentences .

  op __ : Sentence Sentences -> Sentences 
     [format(d n d) prec 75] .


  op sort_ : Sort -> Sentence 
     [format(nb o d) prec 66] .

  op symbol_`(_`):_ : Symbol SortList Sort -> Sentence 
     [format(nb o d d d d d d) prec 66] .

  op axiom{_}_ : SortList Pattern -> Sentence 
     [format(nb o d d n++i --) prec 66] .

  op alias{_}_:=_ : SortList Pattern Pattern -> Sentence 
     [format(nb o d d n++i nb o --) prec 66] .

  ---- Deal with empty sort parameter list.
  op symbol_():_ : Symbol Sort -> Sentence
     [format(nb o d d d d d) prec 66] .
  eq symbol S:Symbol() : S:Sort = symbol S:Symbol (.SortList) : S:Sort .
  op axiom{}_ : Pattern -> Sentence 
     [format(nb o d n++i --) prec 66] .
  eq axiom{} P:Pattern = axiom{.SortList} P:Pattern .
  op alias{}_:=_ : Pattern Pattern -> Sentence 
     [format(nb o d n++i ni d --) prec 66] .
  eq alias{} P:Pattern := Q:Pattern = alias{.SortList} P:Pattern := Q:Pattern .

endfm

---)


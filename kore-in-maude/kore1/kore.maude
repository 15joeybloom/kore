fmod KORE is

  protecting META-LEVEL *
    (sort Sort     to META-LEVEL.Sort,
     sort Variable to META-LEVEL.Variable) .

  protecting INT .
  protecting STRING .
  protecting CONVERSION .








  ---- <Sort> ::= 
  ---- | <ObjectSort>
  ---- | <MetaSort>

  ---- <SortList> ::=
  ---- | <ObjectSortList>
  ---- | <MetaSortList>

  ---- An observation about the empty sort list:
  ----   We (will) have two empty lists: .ObjectSortList and .MetaSortList,
  ----   instead of just one .SortList being the empty list of sorts.
  ----   The reason that we have two empty lists (which seems weird) 
  ----   is that we want to decide whether a pattern is an object-level
  ----   one or a meta-level one by just looking at its head. 
  ----   Suppose we have just one operator .SortList as the empty list.
  ----   Then consider the following pattern
  ----     f{.SortList}().
  ----   It is not clear whether it is an object-level one or a meta-level
  ----   one. Having both .ObjectSortList and .MetaSortList makes it
  ----   cystal clear:
  ----     f{.ObjectSortList}() is an object-level pattern,
  ----     f{.MetaSortList}() is a meta-level pattern.

  sorts Sort ObjectSort MetaSort .
  subsorts ObjectSort MetaSort < Sort .

  sorts SortList ObjectSortList MetaSortList .
  subsorts ObjectSortList MetaSortList < SortList .







  ---- <ObjectSort> ::=
  ---- | <AtomicObjectSort>
  ---- | <ParametricObjectSort> "{" <ObjectSortList> "}"
  ---- | <ObjectSortVariable>

  ---- <ObjectSortList> ::=
  ---- | <ObjectSort>
  ---- | <ObjectSort> "," <ObjectSortList>


  sort AtomicObjectSort ParametricObjectSort ObjectSortVariable .
  subsorts AtomicObjectSort ObjectSortVariable < ObjectSort .
  op _`{_`} : ParametricObjectSort ObjectSortList -> ObjectSort [prec 50] .

  op .ObjectSortList : -> ObjectSortList .
  subsort ObjectSort < ObjectSortList .
  op _,_ : ObjectSort ObjectSortList -> ObjectSortList [prec 52] .












  ---- <MetaSort> ::=
  ---- | <MetaSort>          /* has only a finite number of terminals */
  ---- | <MetaSortVariable> 

  ---- <MetaSortList> ::=
  ---- | <MetaSort>
  ---- | <MetaSort> "," <MetaSortList>


  sort MetaSortVariable .
  subsort MetaSortVariable < MetaSort .


  subsort MetaSort < MetaSortList .
  op _,_ : MetaSort MetaSortList -> MetaSortList [prec 52] .



  ---- Append two sort lists
  op _@_ : SortList SortList -> SortList [assoc] .
  eq S:Sort @ Ss:SortList = S:Sort, Ss:SortList .
  eq (S:Sort, Ss:SortList) @ (Ss':SortList)
   = S:Sort, (Ss:SortList @ Ss':SortList) .
  op len : SortList -> Nat .
  eq len(S:Sort) = 1 .
  eq len(S:Sort, Ss:SortList) = 1 + len(Ss:SortList) .



  ---- A pattern is a head applied to a list of patterns.

  ---- <Head> ::=
  ---- | <ObjectHead>
  ---- | <MetaHead>

  ---- <Pattern> ::=
  ---- | <Head> "(" <PatternList> ")"
  ---- | <String>
  ---- | <VariableName>     /* This does look wired. */

  ---- <PatternList> ::=
  ---- | ""
  ---- | <Pattern>
  ---- | <Pattern> "," <PatternList>

  sorts Head ObjectHead MetaHead . 
  subsorts ObjectHead MetaHead < Head .

  sort Pattern PatternList VariableName .
  subsorts String VariableName < Pattern .

  op _`(_`) : Head PatternList -> Pattern [format(d d n++i d --) prec 75] .

  subsort Pattern < PatternList .
  op . : -> PatternList .
  op _,_ : Pattern PatternList -> PatternList [format(d d ni d) prec 78] .
  eq P:Pattern, . = P:Pattern .

  ---- Deal with empty pattern list.
  ---- Parse head() as head(.).
  op _`(`) : Head -> Pattern [prec 75] .
  eq H:Head() = H:Head(.) .


  ---- Append two lists
  op _@_ : PatternList PatternList -> PatternList [assoc] .
  eq . @ Ps = Ps .
  eq P:Pattern @ Ps = P:Pattern, Ps .
  eq (P:Pattern, Ps) @ Ps'
   = P:Pattern, (Ps @ Ps') .
  op len : PatternList -> Nat .
  eq len(P:Pattern) = 1 .
  eq len(P:Pattern, Ps) = 1 + len(Ps) .


  ---- <ObjectHead> ::=
  ---- | <AtomicObjectHead>
  ---- | <ParametricHead> "{" <ObjectSortList> "}" 

  ---- <MetaHead> ::=
  ---- | <AtomicMetaHead>
  ---- | < ParametricHead> "{" <MetaSortList> "}"

  sorts AtomicObjectHead AtomicMetaHead ParametricHead .
  subsort AtomicObjectHead < ObjectHead .
  subsort AtomicMetaHead < MetaHead .
  op _`{_`} : ParametricHead ObjectSortList -> ObjectHead [prec 72] .
  op _`{_`} : ParametricHead MetaSortList -> MetaHead [prec 72] .









  ---- <Sentence> ::=
  ---- | "sort" <ObjectSort>
  ---- | "symbol" <AtomicObjectHead> "(" <ObjectSortList> ")" ":" <ObjectSort>
  ---- | "symbol" <MetaObjectHead> "(" <MetaSortList> ")" ":" <MetaSort>
  ---- | "symbol" "{" <ObjectSortVariableList> "}" "(" ...
  ---- | "axiom" <Pattern>
  ---- | "alias"  ...

  sorts Sentence Sentences .
  subsort Sentence < Sentences .
  op __ : Sentence Sentences -> Sentences [format(d n d) prec 85] .
  ---- append two sentences
  op _@_ : Sentences Sentences -> Sentences .
  eq S:Sentence @ Ss:Sentences = S:Sentence Ss:Sentences .
  eq (S:Sentence Ss:Sentences) @ Ss':Sentences
   = S:Sentence (Ss:Sentences @ Ss':Sentences) .


  op axiom{_}_ : SortList Pattern -> Sentence [format(b o d d n++i --) prec 82] .
  op axiom_    : Pattern -> Sentence [format(b on++i --) prec 82] .


  op sort_ : Sort -> Sentence [format(b o d) prec 82] .


  op symbol_`(_`):_ : ObjectHead ObjectSortList ObjectSort -> Sentence 
     [format(b o d d d s d d) prec 82] .
  op symbol_`(`):_  : ObjectHead                ObjectSort -> Sentence
     [format(b o d d s d d) prec 82] .

  op symbol_`(_`):_ : MetaHead MetaSortList MetaSort -> Sentence
     [format(b o d d d s d d) prec 82] .
  op symbol_`(`):_  : MetaHead              MetaSort -> Sentence
     [format(b o d d s d d) prec 82] .





  op alias`{_`}_:=_ : SortList Pattern Pattern -> Sentence 
     [format(b o d d s d d d) prec 82] .

















  ---- Defining the lifting bracket [[_]]





  vars Ps Ps' : PatternList .
  var OSs OSs' : ObjectSortList .
  var MS : MetaSort .
  var MSs : MetaSortList .
  var PH : ParametricHead .
  var MH : MetaHead .


  op ERROR@AtomicMetaHead : -> [AtomicMetaHead] .
  op ERROR@VariableName   : -> [VariableName]   .


  ---- Lift a pattern
  op [[_]] : Pattern -> Pattern . 
  eq [[H:AtomicObjectHead(Ps)]] = [[H:AtomicObjectHead]]([[Ps]]) .
  eq [[H:AtomicMetaHead(Ps)]] = H:AtomicMetaHead([[Ps]]) .
  ---- It's a bit annoyting that we have to define a special case
  ---- for variables:
  ----   [[variable{Nat}(X)]] = Kvariable(KNat(), "X")
  ----   [[variable{KSort}(X)]] = variable{KSort}(X)
  ----      which is not equal to variable{KSort}([[X]])
  eq [[variable{MS}(X:VariableName)]] = variable{MS}(X:VariableName) .
  eq [[PH:ParametricHead{OSs}(Ps)]] = [[PH:ParametricHead]]([[OSs]] @ [[Ps]]) .
  eq [[PH:ParametricHead{MSs}(Ps)]] = PH:ParametricHead{MSs}([[Ps]]) .
  eq [[S:String]] = S:String .

  ---- Lift a list of patterns by lifting each of them.
  op [[_]] : PatternList -> PatternList .
  eq [[.]] = . .
  eq [[P:Pattern, Ps]] = [[P:Pattern]], [[Ps]] . 

  ---- Lift an atomic object head by putting a "K" in front of it
  op [[_]] : AtomicObjectHead -> AtomicMetaHead .
  eq [[H:AtomicObjectHead]] 
   = downTerm(
       addK(upTerm(H:AtomicObjectHead)),
       ERROR@AtomicMetaHead) . 

  ---- Lift a parametric head by putting a "K" in front of it
  op [[_]] : ParametricHead -> AtomicMetaHead .
  eq [[PH:ParametricHead]]
   = downTerm(
       addK(upTerm(PH:ParametricHead)),
       ERROR@AtomicMetaHead) .

  ---- Lift an object sort to a pattern.
  op [[_]] : ObjectSort -> Pattern .

  ---- Lift an atomic object sort by putting a "K" in front of it
  ----   [[Nat]] = KNat()
  ----   [[Bool]] = KBool()
  eq [[S:AtomicObjectSort]]
   = downTerm(
       addK(upTerm(S:AtomicObjectSort)),
       ERROR@AtomicMetaHead) () .

  ---- Lifting a parametric sort by putting a "K" in front of it
  op [[_]] : ParametricObjectSort -> AtomicMetaHead .
  eq [[S:ParametricObjectSort]]
   = downTerm(
       addK(upTerm(S:ParametricObjectSort)),
       ERROR@AtomicMetaHead) .
  eq [[PS:ParametricObjectSort{OSs}]]
   = [[PS:ParametricObjectSort]]([[OSs]]) .

  ---- Lifting an object sort variable:
  ----   [[S]] = variable{KSort}(S)
  eq [[S:ObjectSortVariable]]
   = variable{KSort}
       (downTerm(
          qid(string(getName(upTerm(S:ObjectSortVariable)))
              + ".VariableName"), 
          ERROR@VariableName)) .

  ---- Lifting a list of object sorts by lifting each of them.
  op [[_]] : ObjectSortList -> PatternList .
  eq [[S:ObjectSort, OSs]]
   = [[S:ObjectSort]], [[OSs]] .

  ---- Lifting a variable name to its string representation.
  eq [[X:VariableName]]
   = string(getName(upTerm(X:VariableName))) .


  ---- Lifting a sentence to sentences at meta-level
  op [[_]] : Sentences -> Sentences .
  eq [[S:Sentence Ss:Sentences]] = [[S:Sentence]] @ [[Ss:Sentences]] .


  ---- Lifting axiom declarations
  ---- Step 1: Get rid of object sort variables.
  ----         In fact, the object sort variables in the curly bracket
  ----         after the keyword "axiom" is of no use in this implementation,
  ----         because we already knew (defined) terminals of ObjectSortVariable
  eq [[axiom P:Pattern]] = axiom liftToAxiom(P:Pattern) .
  eq [[axiom{OSs} P:Pattern]] = axiom liftToAxiom(P:Pattern) .
  eq [[axiom{MSs} P:Pattern]] = axiom{MSs} liftToAxiom(P:Pattern) .
  ---- Step 2: if Pattern has metahead, lift to [[P]]
  ----         otherwise, lift to KisAxiom([[P]]) .
  eq liftToAxiom(P:Pattern)
   = if   hasMetaHead(P:Pattern)
     then [[P:Pattern]]
     else KisAxiom([[P:Pattern]])
     fi .
  op liftToAxiom : Pattern -> Pattern .
  op hasMetaHead : Pattern -> Bool .
  eq hasMetaHead(H:MetaHead(Ps)) = true .
  eq hasMetaHead(H:ObjectHead(Ps)) = false .
  eq hasMetaHead(S:String) = true .


 ---- Lifting sort declarations
 ceq [[sort OS:ObjectSort]] 
   = axiom KisSort([[OS:ObjectSort]])
     axiom equals{KSort, KS}(
             [[OS:ObjectSort]],
             Ksort(name(OS:ObjectSort), ListOfKSortToKSortList(Ps:PatternList)))
  if H:MetaHead(Ps:PatternList) := [[OS:ObjectSort]] .
  ---- Calculating the names (strings) of atomic object sorts and
  ---- parametric sorts.
  ---- For example, name(Nat) = "Nat", name(List) = "List".
  op name : AtomicObjectSort -> String .
  eq name(S:AtomicObjectSort) = string(getName(upTerm(S:AtomicObjectSort))) .
  op name : ParametricObjectSort -> String .
  eq name(PS:ParametricObjectSort) 
   = string(getName(upTerm(PS:ParametricObjectSort))) .
  op name : ObjectSort -> String .
  eq name(PS:ParametricObjectSort{Ss:SortList})
   = name(PS:ParametricObjectSort) .
  ---- Convert a list of meta-level patterns (whose sorts are KSort)
  ---- to one meta-level pattern of the sort KSortList . 
  ---- KnilKSortList and KconsKSortList are constructors of KSortList.
  op ListOfKSortToKSortList : PatternList -> Pattern .
  eq ListOfKSortToKSortList(.) = KnilKSortList() .
  eq ListOfKSortToKSortList(P:Pattern) 
   = KconsKSortList(P:Pattern, KnilKSortList()) .
  eq ListOfKSortToKSortList(P:Pattern, Ps)
   = KconsKSortList(P:Pattern, ListOfKSortToKSortList(Ps)) .



  ---- TODO:: We shouldn't need this case!
  ---- Lifting object symbols declarations: non-parametric constant case
  ---- [[symbol f() : S]]
  ---- = symbol Kf() : KPattern
  ----   axiom Kf(.) = Kapplication(Ksymbol("f", nil, nil, S), nil)
  eq [[symbol H:AtomicObjectHead() : S:ObjectSort]]
   = symbol [[H:AtomicObjectHead]]() : KPattern
     axiom equals{KPattern,KS}(
        [[H:AtomicObjectHead()]],
        Kapplication(Ksymbol(name(H:AtomicObjectHead),
                             KnilKSortList(),
                             KnilKSortList(),
                             [[S:ObjectSort]]), 
                     KnilKPatternList())) .

  ---- Lifting object symbols declarations: non-parametric non-constant case
  ---- [[symbol f(S1,...,Sn) : S]]
  ---- = symbol Kf(KPattern,...,KPattern) : KPattern
  ----   axiom Kf(P1,...,Pn) 
  ----         = Kapplication(Ksymbol("f", nil, (S1,...,Sn), S),
  ----                        (P1,...,Pn))
   
  eq [[symbol H:AtomicObjectHead(OSs) : S:ObjectSort]]
   = symbol
       [[H:AtomicObjectHead]](makeListOfKPattern(len(OSs))) : KPattern
     axiom equals{KPattern,KS}(
       [[H:AtomicObjectHead]](makeListOfKPatternVar(len(OSs))),
       Kapplication(
         Ksymbol(name(H:AtomicObjectHead),
                 KnilKSortList(),
                 ListOfKSortToKSortList([[OSs]]),
                 [[S:ObjectSort]]),
         ListOfKPatternToKPatternList(makeListOfKPatternVar(len(OSs))))) .
  op name : AtomicObjectHead -> String .
  eq name(H:AtomicObjectHead) = string(getName(upTerm(H:AtomicObjectHead))) .
  ---- Some aux functions
  op makeListOfKPattern : NzNat -> MetaSortList . 
  eq makeListOfKPattern(1) = KPattern .
  eq makeListOfKPattern(N:Nat) = KPattern, makeListOfKPattern(N:Nat + -1) .

  op makeKPatternVar : NzNat -> Pattern .
  eq makeKPatternVar(N:Nat)
   = variable{KPattern}(makeVariableName("P", N:Nat)) . 
  op makeVariableName : String Nat -> VariableName .
  eq makeVariableName(Prefix:String, N:Nat)
   = downTerm(
       qid(Prefix:String + string(N:Nat, 10) + ".VariableName"),
       ERROR@VariableName) .
  op makeListOfKPatternVar : NzNat -> PatternList .
  eq makeListOfKPatternVar(1) = makeKPatternVar(1) .
  eq makeListOfKPatternVar(N:NzNat)
   = makeListOfKPatternVar(N:NzNat + -1) @ makeKPatternVar(N:NzNat) .
  ---- Convert a list of meta-level patterns (whose sorts are KPattern)
  ---- to the meta-level pattern of sort KPatternList .
  op ListOfKPatternToKPatternList : PatternList -> Pattern .
  eq ListOfKPatternToKPatternList(.)
   = KnilKPatternList() .
  eq ListOfKPatternToKPatternList(P:Pattern)
   = KconsKPatternList(P:Pattern, KnilKPatternList()) .
  eq ListOfKPatternToKPatternList(P:Pattern, Ps)
   = KconsKPatternList(P:Pattern, ListOfKPatternToKPatternList(Ps)) .


  ---- TODO:: We shouldn't need this case!
  ---- Lifting object symbols declarations: parametric constant case
  ---- [[symbol f{S1,...,Sn}() : S]]
  ---- = symbol Kf(KSort,...,KSort) : KPattern
  ---- = axiom Kf(S1,...,Sn)
  ----         = Kapplication(Ksymbol("f", (S1,...,Sn), nil, S),
  ----                        nil)
  eq [[symbol PH{OSs}() : S:ObjectSort]]
   = symbol [[PH]](makeListOfKSort(len(OSs))) : KPattern
     axiom equals{KPattern,KS}(
       [[PH]]([[OSs]]),
       Kapplication(
         Ksymbol(name(PH),
                 ListOfKSortToKSortList([[OSs]]),
                 KnilKSortList(),
                 [[S:ObjectSort]]),
         KnilKPatternList())) .
  ---- Some aux functions
  op makeListOfKSort : NzNat -> MetaSortList .
  eq makeListOfKSort(1) = KSort .
  eq makeListOfKSort(N:NzNat)
   = KSort, makeListOfKSort(N:NzNat + -1) .


  ---- Lifting object symbols declarations: parametric non-constant case
  ---- [[symbol f{S1...Sn}(T1...Tm) : S]]
  ---- = symbol Kf(KSort,..,KSort,KPattern,...,KPattern) : KPattern
  ---- = axiom Kf(S1,...,Sn,P1,...,Pn)
  ----         = Kapplication(
  ----             Ksymbol("f", (S1...Sn), (T1...Tn), S),
  ----             (P1...Pn)) 
  eq [[symbol PH{OSs}(OSs') : S:ObjectSort]]
   = symbol [[PH]](makeListOfKSort(len(OSs)) 
                 @ makeListOfKPattern(len(OSs'))) : KPattern
     axiom equals{KPattern,KS}(
       [[PH]]([[OSs]] @ makeListOfKPatternVar(len(OSs'))),
       Kapplication(
         Ksymbol(name(PH),
                 ListOfKSortToKSortList([[OSs]]),
                 ListOfKSortToKSortList([[OSs']]),
                 [[S:ObjectSort]]),
         ListOfKPatternToKPatternList(makeListOfKPatternVar(len(OSs'))))) .
  op name : ParametricHead -> String .
  eq name(PH) = string(getName(upTerm(PH))) .



  ---- Lifting object alias declarations: parametric case
  ---- For the same reason, object sort variables in the curly
  ---- bracket after "alias" is of no use in this implementation.
  ---- [[alias{...} g{S1...Sn}(P1...Pn) := Q]]
  ---- = symbol Kg(KSort,...,KSort,KPattern,...,KPattern) : KPattern
  ----   axiom Kg(S1,...,Sn,P1,...,Pn) = [[Q]]
  eq [[alias{OSs'} PH{OSs}(Ps) := Q:Pattern]]
   = symbol [[PH]](makeListOfKSort(len(OSs))
                 @ makeListOfKPattern(len(Ps))) : KPattern
     axiom equals{KPattern,KS}(
       [[PH]]([[OSs]] @ [[Ps]]),
       [[Q:Pattern]]) .



  ---- Lifting meta-level declarations: just keep them!
  eq [[sort MS]] = sort MS .
  eq [[symbol MH() : MS]] = symbol MH() : MS .
  eq [[symbol MH(MSs) : MS]] = symbol MH(MSs) : MS .





  ---- An aux function that takes anything to its corresponding
  ---- atomic meta head at the meta-theory. For example:
  ----   'plus.AtomicObjectHead     ---> 'Kplus.AtomicMetaHead
  ----   'cons.ParametricHead       ---> 'Kcons.AtomicMetaHead
  ----   'Nat.AtomicObjectSort      ---> 'KNat.AtomicMetaHead
  ----   'List.ParametricObjectSort ---> 'KList.AtomicMetaHead
  op addK : Constant -> Constant .
  eq addK(C:Constant) = qid("K" 
                            + string(getName(C:Constant)) 
                            + ".AtomicMetaHead") .







---- Terminals / Tokens of the Kore syntax / grammar are defined
---- as Maude constants, simply because Maude does not allows us
---- to define them as regular expressions. 




  op B         : -> VariableName .
  op C         : -> VariableName .
  op C1        : -> VariableName .
  op C2        : -> VariableName .
  op E         : -> VariableName .
  op X         : -> VariableName .
  op Y         : -> VariableName .
  op Z         : -> VariableName .
  op HOLE      : -> VariableName .
  op SortVarR  : -> VariableName .

  op L         : -> VariableName .
  op L0        : -> VariableName .
  op P         : -> VariableName .
  op P1        : -> VariableName .
  op P2        : -> VariableName .
  op P3        : -> VariableName .
  op P4        : -> VariableName .
  op P5        : -> VariableName .
  op Q         : -> VariableName .
  op R         : -> VariableName .
  op S  : -> VariableName . 
  op S' : -> VariableName .
  op S1 : -> VariableName .
  op S2 : -> VariableName .
  op S3 : -> VariableName .


  op Nat  : -> AtomicObjectSort .
  op Bool : -> AtomicObjectSort .
  op AExp : -> AtomicObjectSort .
  op BExp : -> AtomicObjectSort .
  op Stmt : -> AtomicObjectSort .

  op List : -> ParametricObjectSort .
  op Ctxt : -> ParametricObjectSort .
  op Map  : -> ParametricObjectSort .

  op S  : -> ObjectSortVariable .
  op S' : -> ObjectSortVariable .
  op S1 : -> ObjectSortVariable .
  op S2 : -> ObjectSortVariable .
  op S3 : -> ObjectSortVariable .
  op R  : -> ObjectSortVariable .



  op KS   : -> MetaSortVariable .
  op KS1  : -> MetaSortVariable .
  op KS2  : -> MetaSortVariable .
  op KS3  : -> MetaSortVariable .
  op KS'  : -> MetaSortVariable .
  op KS'' : -> MetaSortVariable .

  op true    : -> AtomicObjectHead .
  op false   : -> AtomicObjectHead .
  op andBool : -> AtomicObjectHead . 
  op notBool : -> AtomicObjectHead . 
  op zero    : -> AtomicObjectHead .
  op succ    : -> AtomicObjectHead .
  op plus    : -> AtomicObjectHead .
  op gte     : -> AtomicObjectHead .

  op variable   : -> ParametricHead .
  op exists     : -> ParametricHead .
  op not        : -> ParametricHead .
  op and        : -> ParametricHead .
  op or         : -> ParametricHead .
  op implies    : -> ParametricHead .
  op iff        : -> ParametricHead .
  op equals     : -> ParametricHead .
  op forall     : -> ParametricHead .
  op ceil       : -> ParametricHead .
  op nil        : -> ParametricHead .
  op cons       : -> ParametricHead .      
  op emp        : -> ParametricHead .      
  op merge      : -> ParametricHead .      
  op bind       : -> ParametricHead .      
  op natemp     : -> ParametricHead .      
  op natmerge   : -> ParametricHead .      
  op natbind    : -> ParametricHead .      
  op floor      : -> ParametricHead .
  op gamma      : -> ParametricHead .




  op KPred        : -> MetaSort .
  op KChar        : -> MetaSort .
  op KString      : -> MetaSort .
  op KSort        : -> MetaSort .
  op KSortList    : -> MetaSort .
  op KSymbol      : -> MetaSort .
  op KSymbolList  : -> MetaSort .
  op KVariable    : -> MetaSort .
  op KPattern     : -> MetaSort .
  op KPatternList : -> MetaSort .



  op KNat       : -> AtomicMetaHead .
  op KMap       : -> AtomicMetaHead .
  op KBool      : -> AtomicMetaHead .
  op KAExp      : -> AtomicMetaHead .
  op KBExp      : -> AtomicMetaHead .
  op KStmt      : -> AtomicMetaHead .
  op KList      : -> AtomicMetaHead .  
  op KCtxt      : -> AtomicMetaHead .


  op ctxtapp    : -> ParametricHead .
  op gamma0     : -> ParametricHead .

  op NatToAExp  : -> AtomicObjectHead .
  op IdToAExp   : -> AtomicObjectHead .
  op plusAExp   : -> AtomicObjectHead .
  op ite        : -> AtomicObjectHead .


  op KisAxiom    : -> AtomicMetaHead .
  op KisSort     : -> AtomicMetaHead .
  op KisSymbol   : -> AtomicMetaHead .




  op Ksort     : -> AtomicMetaHead .
  op Ksymbol   : -> AtomicMetaHead .
  op KnilKSortList : -> AtomicMetaHead .
  op KconsKSortList : -> AtomicMetaHead .
  op KnilKPatternList : -> AtomicMetaHead .
  op KconsKPatternList : -> AtomicMetaHead .
  op Kapplication : -> AtomicMetaHead .




  op Kvariable   : -> AtomicMetaHead  .
  op Kexists     : -> AtomicMetaHead  .
  op Knot        : -> AtomicMetaHead  .
  op Kand        : -> AtomicMetaHead  .
  op Kor         : -> AtomicMetaHead  .
  op Kimplies    : -> AtomicMetaHead  .
  op Kiff        : -> AtomicMetaHead  .
  op Kequals     : -> AtomicMetaHead  .
  op Kforall     : -> AtomicMetaHead  .
  op Kfloor      : -> AtomicMetaHead  .
  op Kgamma      : -> AtomicMetaHead  .

  op Kceil      : -> AtomicMetaHead .
  op Ktrue      : -> AtomicMetaHead .
  op Kfalse     : -> AtomicMetaHead .
  op KandBool   : -> AtomicMetaHead .
  op KnotBool   : -> AtomicMetaHead .
  op Kzero      : -> AtomicMetaHead .
  op Ksucc      : -> AtomicMetaHead .
  op Kplus      : -> AtomicMetaHead .
  op Kgte       : -> AtomicMetaHead .
  op Knil       : -> AtomicMetaHead .
  op Kcons      : -> AtomicMetaHead .
  op Kctxtapp   : -> AtomicMetaHead .
  op Kgamma0    : -> AtomicMetaHead .
  op KNatToAExp : -> AtomicMetaHead .
  op KIdToAExp  : -> AtomicMetaHead .
  op KplusAExp  : -> AtomicMetaHead .
  op Kite       : -> AtomicMetaHead .
  op Kemp       : -> AtomicMetaHead .
  op Kmerge     : -> AtomicMetaHead .
  op Kbind      : -> AtomicMetaHead .
  op Knatemp       : -> AtomicMetaHead .
  op Knatmerge     : -> AtomicMetaHead .
  op Knatbind      : -> AtomicMetaHead .

endfm


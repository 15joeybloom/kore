fmod KORE is

  protecting META-LEVEL *
    (sort Sort     to META-LEVEL.Sort,
     sort Variable to META-LEVEL.Variable) .

  protecting STRING .








  ---- <Sort> ::= 
  ---- | <ObjectSort>
  ---- | <MetaSort>

  ---- <SortList> ::=
  ---- | <ObjectSortList>
  ---- | <MetaSortList>

  ---- An observation about the empty sort list:
  ----   We (will) have two empty lists: .ObjectSortList and .MetaSortList,
  ----   instead of just one .SortList being the empty list of sorts.
  ----   The reason that we have two empty lists (which seems weird) 
  ----   is that we want to decide whether a pattern is an object-level
  ----   one or a meta-level one by just looking at its head. 
  ----   Suppose we have just one operator .SortList as the empty list.
  ----   Then consider the following pattern
  ----     f{.SortList}().
  ----   It is not clear whether it is an object-level one or a meta-level
  ----   one. Having both .ObjectSortList and .MetaSortList makes it
  ----   cystal clear:
  ----     f{.ObjectSortList}() is an object-level pattern,
  ----     f{.MetaSortList}() is a meta-level pattern.

  sorts Sort ObjectSort MetaSort .
  subsorts ObjectSort MetaSort < Sort .

  sorts SortList ObjectSortList MetaSortList .
  subsorts ObjectSortList MetaSortList < SortList .







  ---- <ObjectSort> ::=
  ---- | <AtomicObjectSort>
  ---- | <ParametricObjectSort> "{" <ObjectSortList> "}"
  ---- | <ObjectSortVariable>

  ---- <ObjectSortList> ::=
  ---- | <ObjectSort>
  ---- | <ObjectSort> "," <ObjectSortList>


  sort AtomicObjectSort ParametricObjectSort ObjectSortVariable .
  subsorts AtomicObjectSort ObjectSortVariable < ObjectSort .
  op _`{_`} : ParametricObjectSort ObjectSortList -> ObjectSort [prec 50] .

  op .ObjectSortList : -> ObjectSortList .
  subsort ObjectSort < ObjectSortList .
  op _,_ : ObjectSort ObjectSortList -> ObjectSortList [prec 52] .












  ---- <MetaSort> ::=
  ---- | <MetaSort>          /* has only a finite number of terminals */
  ---- | <MetaSortVariable> 

  ---- <MetaSortList> ::=
  ---- | <MetaSort>
  ---- | <MetaSort> "," <MetaSortList>


  sort MetaSortVariable .
  subsort MetaSortVariable < MetaSort .


  subsort MetaSort < MetaSortList .
  op _,_ : MetaSort MetaSortList -> MetaSortList [prec 52] .







  ---- A pattern is a head applied to a list of patterns.

  ---- <Head> ::=
  ---- | <ObjectHead>
  ---- | <MetaHead>

  ---- <Pattern> ::=
  ---- | <Head> "(" <PatternList> ")"
  ---- | <String>
  ---- | <VariableName>     /* This does look wired. */

  ---- <PatternList> ::=
  ---- | ""
  ---- | <Pattern>
  ---- | <Pattern> "," <PatternList>

  sorts Head ObjectHead MetaHead . 
  subsorts ObjectHead MetaHead < Head .

  sort Pattern PatternList VariableName .
  subsorts String VariableName < Pattern .

  op _`(_`) : Head PatternList -> Pattern [prec 75] .

  subsort Pattern < PatternList .
  op . : -> PatternList .
  op _,_ : Pattern PatternList -> PatternList [prec 78] .
  eq P:Pattern, . = P:Pattern .

  ---- Deal with empty pattern list.
  ---- Parse head() as head(.).
  op _`(`) : Head -> Pattern [prec 75] .
  eq H:Head() = H:Head(.) .


  ---- Append two lists
  op _@_ : PatternList PatternList -> PatternList [assoc] .
  eq . @ Ps = Ps .
  eq P:Pattern @ Ps = P:Pattern, Ps .
  eq (P:Pattern, Ps) @ Ps'
   = P:Pattern, (Ps @ Ps') .



  ---- <ObjectHead> ::=
  ---- | <AtomicObjectHead>
  ---- | <ParametricHead> "{" <ObjectSortList> "}" 

  ---- <MetaHead> ::=
  ---- | <AtomicMetaHead>
  ---- | < ParametricHead> "{" <MetaSortList> "}"

  sorts AtomicObjectHead AtomicMetaHead ParametricHead .
  subsort AtomicObjectHead < ObjectHead .
  subsort AtomicMetaHead < MetaHead .
  op _`{_`} : ParametricHead ObjectSortList -> ObjectHead [prec 72] .
  op _`{_`} : ParametricHead MetaSortList -> MetaHead [prec 72] .









  ---- <Sentence> ::=
  ---- | "sort" <ObjectSort>
  ---- | "symbol" <AtomicObjectHead> "(" <ObjectSortList> ")" ":" <ObjectSort>
  ---- | "symbol" <MetaObjectHead> "(" <MetaSortList> ")" ":" <MetaSort>
  ---- | "symbol" "{" <ObjectSortVariableList> "}" "(" ...
  ---- | "axiom" <Pattern>
  ---- | "alias"  ...

  sorts Sentence Sentences .
  subsort Sentence < Sentences .
  op __ : Sentence Sentences -> Sentences [format(d n d) prec 85] .
  ---- append two sentences
  op _@_ : Sentences Sentences -> Sentences .
  eq S:Sentence @ Ss:Sentences = S:Sentence Ss:Sentences .
  eq (S:Sentence Ss:Sentences) @ Ss':Sentences
   = S:Sentence (Ss:Sentences @ Ss':Sentences) .


  op axiom{_}_ : SortList Pattern -> Sentence [format(b os d d s d) prec 82] .
  op axiom_    : Pattern -> Sentence [format(b o d) prec 82] .


  op sort_ : ObjectSort -> Sentence [format(b o d) prec 82] .


  op symbol_`(_`):_ : ObjectHead ObjectSortList ObjectSort -> Sentence 
     [format(b o d d d s d d) prec 82] .
  op symbol_`(`):_  : ObjectHead                ObjectSort -> Sentence
     [format(b o d d s d d) prec 82] .

















  ---- Defining the lifting bracket [[_]]



  vars Ps Ps' : PatternList .
  var OSs OSs' : ObjectSortList .
  var MSs : MetaSortList .
  var PH : ParametricHead .


  op ERROR@AtomicMetaHead : -> [AtomicMetaHead] .
  op ERROR@VariableName   : -> [VariableName]   .


  ---- Lift a pattern
  op [[_]] : Pattern -> Pattern . 
  eq [[H:AtomicObjectHead(Ps)]] = [[H:AtomicObjectHead]]([[Ps]]) .
  eq [[H:AtomicMetaHead(Ps)]] = H:AtomicMetaHead([[Ps]]) .
  eq [[PH:ParametricHead{OSs}(Ps)]] = [[PH:ParametricHead]]([[OSs]] @ [[Ps]]) .
  eq [[PH:ParametricHead{MSs}(Ps)]] = PH:ParametricHead{MSs}([[Ps]]) .
  eq [[S:String]] = S:String .

  ---- Lift a list of patterns by lifting each of them.
  op [[_]] : PatternList -> PatternList .
  eq [[.]] = . .
  eq [[P:Pattern, Ps]] = [[P:Pattern]], [[Ps]] . 

  ---- Lift an atomic object head by putting a "K" in front of it
  op [[_]] : AtomicObjectHead -> AtomicMetaHead .
  eq [[H:AtomicObjectHead]] 
   = downTerm(
       addK(upTerm(H:AtomicObjectHead)),
       ERROR@AtomicMetaHead) . 

  ---- Lift a parametric head by putting a "K" in front of it
  op [[_]] : ParametricHead -> AtomicMetaHead .
  eq [[PH:ParametricHead]]
   = downTerm(
       addK(upTerm(PH:ParametricHead)),
       ERROR@AtomicMetaHead) .

  ---- Lift an object sort to a pattern.
  op [[_]] : ObjectSort -> Pattern .

  ---- Lift an atomic object sort by putting a "K" in front of it
  ----   [[Nat]] = KNat()
  ----   [[Bool]] = KBool()
  eq [[S:AtomicObjectSort]]
   = downTerm(
       addK(upTerm(S:AtomicObjectSort)),
       ERROR@AtomicMetaHead) () .

  ---- Lifting a parametric sort by putting a "K" in front of it
  op [[_]] : ParametricObjectSort -> AtomicMetaHead .
  eq [[S:ParametricObjectSort]]
   = downTerm(
       addK(upTerm(S:ParametricObjectSort)),
       ERROR@AtomicMetaHead) .
  eq [[PS:ParametricObjectSort{OSs}]]
   = [[PS:ParametricObjectSort]]([[OSs]]) .

  ---- Lifting an object sort variable:
  ----   [[S]] = variable{KSort}(S)
  eq [[S:ObjectSortVariable]]
   = variable{KSort}
       (downTerm(
          qid(string(getName(upTerm(S:ObjectSortVariable)))
              + ".VariableName"), 
          ERROR@VariableName)) .

  ---- Lifting a list of object sorts by lifting each of them.
  op [[_]] : ObjectSortList -> PatternList .
  eq [[S:ObjectSort, OSs]]
   = [[S:ObjectSort]], [[OSs]] .

  ---- Lifting a variable name to its string representation.
  eq [[X:VariableName]]
   = string(getName(upTerm(X:VariableName))) .


  ---- Lifting a sentence to sentences at meta-level
  op [[_]] : Sentences -> Sentences .
  eq [[S:Sentence Ss:Sentences]] = [[S:Sentence]] @ [[Ss:Sentences]] .


  ---- Lifting axiom declarations
  eq [[axiom P:Pattern]] = axiom KisAxiom([[P:Pattern]]) .
  eq [[axiom{Ss:SortList} P:Pattern]] = axiom KisAxiom([[P:Pattern]]) .


 ---- Lifting sort declarations
 ceq [[sort OS:ObjectSort]] 
   = axiom KisSort([[OS:ObjectSort]])
     axiom equals{KSort, KS}(
             [[OS:ObjectSort]],
             Ksort(name(OS:ObjectSort), ListOfKSortToKSortList(Ps:PatternList)))
  if H:MetaHead(Ps:PatternList) := [[OS:ObjectSort]] .
  ---- Calculating the names (strings) of atomic object sorts and
  ---- parametric sorts.
  ---- For example, name(Nat) = "Nat", name(List) = "List".
  op name : AtomicObjectSort -> String .
  eq name(S:AtomicObjectSort) = string(getName(upTerm(S:AtomicObjectSort))) .
  op name : ParametricObjectSort -> String .
  eq name(PS:ParametricObjectSort) 
   = string(getName(upTerm(PS:ParametricObjectSort))) .
  op name : ObjectSort -> String .
  eq name(PS:ParametricObjectSort{Ss:SortList})
   = name(PS:ParametricObjectSort) .
  ---- Convert a list of meta-level patterns (whose sorts are KSort)
  ---- to one meta-level pattern of the sort KSortList . 
  ---- KnilKSortList and KconsKSortList are constructors of KSortList.
  op ListOfKSortToKSortList : PatternList -> Pattern .
  eq ListOfKSortToKSortList(.) = KnilKSortList() .
  eq ListOfKSortToKSortList(P:Pattern) 
   = KconsKSortList(P:Pattern, KnilKSortList()) .
  eq ListOfKSortToKSortList(P:Pattern, Ps)
   = KconsKSortList(P:Pattern, ListOfKSortToKSortList(Ps)) .



  ---- Lifting object symbols declarations: non-parametric case
  eq [[symbol H:AtomicObjectHead() : S:ObjectSort]]
   = axiom KisSymbol([[H:AtomicObjectHead()]])
     axiom equals{KSymbol,KS}(
        [[H:AtomicObjectHead()]],
        Ksymbol(name(H:AtomicObjectHead),
                KnilKSortList(),
                KnilKSortList(),
                [[S:ObjectSort]])) . 

  ---- TODO
  ---- [[symbol f(S1,...,Sn) : S]]
  ---- = axiom KgetSort(P1:KPattern) = S1 /\ ... /\ KgetSort(Pn:KPattern) = Sn
  ----         -> Kf(P1,...,Pn) 
  ----            = Kapplication(Ksymbol("f", nil, (S1,...,Sn), S),
  ----                           (P1,...,Pn))
   
  eq [[symbol H:AtomicObjectHead(Ss:ObjectSortList) : S:ObjectSort]]
   = axiom KisSymbol([[H:AtomicObjectHead()]])
     axiom equals{KSymbol,KS}(
       [[H:AtomicObjectHead()]],
       Ksymbol(name(H:AtomicObjectHead),
               KnilKSortList(),
               ListOfKSortToKSortList([[Ss:ObjectSortList]]),
               [[S:ObjectSort]])) .
  op name : AtomicObjectHead -> String .
  eq name(H:AtomicObjectHead) = string(getName(upTerm(H:AtomicObjectHead))) .

  ---- Lifting object symbols declarations: parametric case
  eq [[symbol PH{OSs}() : S:ObjectSort]]
   = axiom KisSymbol([[PH{OSs}()]])
     axiom equals{KSymbol,KS}(
       [[PH{OSs}()]],
       Ksymbol(name(PH),
               ListOfKSortToKSortList([[OSs]]),
               KnilKSortList(),
               [[S:ObjectSort]])) .
  eq [[symbol PH{OSs}(OSs') : S:ObjectSort]]
   = axiom KisSymbol([[PH{OSs}()]])
     axiom equals{KSymbol,KS}(
       [[PH{OSs}()]],
       Ksymbol(name(PH),
               ListOfKSortToKSortList([[OSs]]),
               ListOfKSortToKSortList([[OSs']]),
               [[S:ObjectSort]])) .
  op name : ParametricHead -> String .
  eq name(PH) = string(getName(upTerm(PH))) .








  ---- An aux function that takes anything to its corresponding
  ---- atomic meta head at the meta-theory. For example:
  ----   'plus.AtomicObjectHead     ---> 'Kplus.AtomicMetaHead
  ----   'cons.ParametricHead       ---> 'Kcons.AtomicMetaHead
  ----   'Nat.AtomicObjectSort      ---> 'KNat.AtomicMetaHead
  ----   'List.ParametricObjectSort ---> 'KList.AtomicMetaHead
  op addK : Constant -> Constant .
  eq addK(C:Constant) = qid("K" 
                            + string(getName(C:Constant)) 
                            + ".AtomicMetaHead") .







---- Terminals / Tokens of the Kore syntax / grammar are defined
---- as Maude constants, simply because Maude does not allows us
---- to define them as regular expressions. 




  op B         : -> VariableName .
  op C         : -> VariableName .
  op C1        : -> VariableName .
  op C2        : -> VariableName .
  op E         : -> VariableName .
  op X         : -> VariableName .
  op Y         : -> VariableName .
  op Z         : -> VariableName .
  op HOLE      : -> VariableName .
  op SortVarR  : -> VariableName .

  op L         : -> VariableName .
  op L0        : -> VariableName .
  op P         : -> VariableName .
  op Q         : -> VariableName .
  op R         : -> VariableName .
  op S  : -> VariableName . 
  op S' : -> VariableName .
  op S1 : -> VariableName .
  op S2 : -> VariableName .
  op S3 : -> VariableName .


  op Nat  : -> AtomicObjectSort .
  op Bool : -> AtomicObjectSort .
  op AExp : -> AtomicObjectSort .
  op BExp : -> AtomicObjectSort .
  op Stmt : -> AtomicObjectSort .

  op List : -> ParametricObjectSort .
  op Ctxt : -> ParametricObjectSort .

  op S  : -> ObjectSortVariable .
  op S' : -> ObjectSortVariable .
  op S1 : -> ObjectSortVariable .
  op S2 : -> ObjectSortVariable .
  op S3 : -> ObjectSortVariable .
  op R  : -> ObjectSortVariable .



  op KS   : -> MetaSortVariable .
  op KS1  : -> MetaSortVariable .
  op KS2  : -> MetaSortVariable .
  op KS3  : -> MetaSortVariable .
  op KS'  : -> MetaSortVariable .
  op KS'' : -> MetaSortVariable .

  op true    : -> AtomicObjectHead .
  op false   : -> AtomicObjectHead .
  op andBool : -> AtomicObjectHead . 
  op notBool : -> AtomicObjectHead . 
  op zero    : -> AtomicObjectHead .
  op succ    : -> AtomicObjectHead .
  op plus    : -> AtomicObjectHead .
  op gte     : -> AtomicObjectHead .

  op variable   : -> ParametricHead .
  op exists     : -> ParametricHead .
  op not        : -> ParametricHead .
  op and        : -> ParametricHead .
  op or         : -> ParametricHead .
  op implies    : -> ParametricHead .
  op iff        : -> ParametricHead .
  op equals     : -> ParametricHead .
  op forall     : -> ParametricHead .
  op ceil       : -> ParametricHead .
  op nil        : -> ParametricHead .
  op cons       : -> ParametricHead .      
  op floor      : -> ParametricHead .
  op gamma      : -> ParametricHead .




  op KPred        : -> MetaSort .
  op KChar        : -> MetaSort .
  op KString      : -> MetaSort .
  op KSort        : -> MetaSort .
  op KSortList    : -> MetaSort .
  op KSymbol      : -> MetaSort .
  op KSymbolList  : -> MetaSort .
  op KVariable    : -> MetaSort .
  op KPattern     : -> MetaSort .
  op KPatternList : -> MetaSort .



  op KNat       : -> AtomicMetaHead .
  op KBool      : -> AtomicMetaHead .
  op KAExp      : -> AtomicMetaHead .
  op KBExp      : -> AtomicMetaHead .
  op KStmt      : -> AtomicMetaHead .
  op KList      : -> AtomicMetaHead .  
  op KCtxt      : -> AtomicMetaHead .


  op ctxtapp    : -> ParametricHead .
  op gamma0     : -> ParametricHead .

  op NatToAExp  : -> AtomicObjectHead .
  op IdToAExp   : -> AtomicObjectHead .
  op plusAExp   : -> AtomicObjectHead .
  op ite        : -> AtomicObjectHead .


  op KisAxiom    : -> AtomicMetaHead .
  op KisSort     : -> AtomicMetaHead .
  op KisSymbol   : -> AtomicMetaHead .




  op Ksort     : -> AtomicMetaHead .
  op Ksymbol   : -> AtomicMetaHead .
  op KnilKSortList : -> AtomicMetaHead .
  op KconsKSortList : -> AtomicMetaHead .




  op Kvariable   : -> AtomicMetaHead  .
  op Kexists     : -> AtomicMetaHead  .
  op Knot        : -> AtomicMetaHead  .
  op Kand        : -> AtomicMetaHead  .
  op Kor         : -> AtomicMetaHead  .
  op Kimplies    : -> AtomicMetaHead  .
  op Kiff        : -> AtomicMetaHead  .
  op Kequals     : -> AtomicMetaHead  .
  op Kforall     : -> AtomicMetaHead  .
  op Kfloor      : -> AtomicMetaHead  .
  op Kgamma      : -> AtomicMetaHead  .

  op Kceil      : -> AtomicMetaHead .
  op Ktrue      : -> AtomicMetaHead .
  op Kfalse     : -> AtomicMetaHead .
  op KandBool   : -> AtomicMetaHead .
  op KnotBool   : -> AtomicMetaHead .
  op Kzero      : -> AtomicMetaHead .
  op Ksucc      : -> AtomicMetaHead .
  op Kplus      : -> AtomicMetaHead .
  op Kgte       : -> AtomicMetaHead .
  op Knil       : -> AtomicMetaHead .
  op Kcons      : -> AtomicMetaHead .
  op Kctxtapp   : -> AtomicMetaHead .
  op Kgamma0    : -> AtomicMetaHead .
  op KNatToAExp : -> AtomicMetaHead .
  op KIdToAExp  : -> AtomicMetaHead .
  op KplusAExp  : -> AtomicMetaHead .
  op Kite       : -> AtomicMetaHead .


endfm



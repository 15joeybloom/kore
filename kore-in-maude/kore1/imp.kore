---- The IMP theory in Kore ----

---- Some preludes ... Just ignore ---
in kore
fmod IMP is
  including KORE .
  op imp : -> Sentence .
  eq imp =

  ---- imp.kore ----
  
  symbol
    ceil{S1,S2}(S1) : S2
  axiom{S1,S2}  
    ceil{S1,S2}(variable{S1}(X))
  alias{S1,S2}
    floor{S1,S2}(variable{S1}(P))
  := not{S2}(ceil{S1,S2}(not{S1}(variable{S1}(P)))) 

  sort   Bool
  symbol true()              : Bool
  symbol false()             : Bool
  symbol notBool(Bool)       : Bool
  symbol andBool(Bool, Bool) : Bool
  symbol zero()           : Nat
  symbol succ(Nat)      : Nat
  symbol plus(Nat, Nat) : Nat
  symbol gte(Nat, Nat)  : Bool 

  axiom{S}  
    exists{Bool, S}(
      variable{Bool}(B), 
      equals{Bool,S}(
        variable{Bool}(B), 
        true()))


  axiom{S, R}
    exists{List{S}, R}(variable{List{S}}(L), 
    equals{List{S}, R}(variable{List{S}}(L), nil{S}()))
  axiom{S, R}
    exists{List{S}, R}(variable{List{S}}(L), 
    equals{List{S}, R}(variable{List{S}}(L), cons{S}(variable{S}(X), variable{List{S}}(L0))))
  
  axiom{S}
    or{List{S}}(nil{S}(), 
                 exists{S, List{S}}(variable{S}(X), exists{List{S}, List{S}}(variable{List{S}}(L), 
                    cons{S}(variable{S}(X), variable{List{S}}(L)))))
  axiom{S}
    not{List{S}}(and{List{S}}(
      nil{S}(), 
      exists{S, List{S}}(variable{S}(X), exists{List{S}, List{S}}(variable{List{S}}(L), 
        cons{S}(variable{S}(X), variable{List{S}}(L))))))

  sort   Nat
  sort   List{S}
  symbol nil{S}()              : List{S}
  symbol cons{S}(S, List{S}) : List{S}
  sort Map{S1,S2}
  symbol emp{S1,S2}() : Map{S1,S2}
  symbol merge{S1,S2}(Map{S1,S2},Map{S1,S2}) : Map{S1,S2}
  symbol bind{S1,S2}(S1,S2) : Map{S1,S2}
  axiom emp{Nat, Bool}() 
  axiom bind{Nat, Bool}(zero(), true()) 
  symbol natemp{S}() : Map{Nat, S}
  symbol natbind{S}(Nat, S) : Map{Nat, S}
  symbol natmerge{S}(Map{Nat,S}, Map{Nat,S}) : Map{Nat,S}
  alias{S} or{S}(variable{KPattern}(P), variable{KPattern}(Q))
        := not{S}(and{S}(
             not{S}(variable{KPattern}(P)), 
             not{S}(variable{KPattern}(Q))))
  .



endfm


reduce [[imp]] .


reduce 
  [[imp]] == [[ [[imp]] ]]
.



quit





























  axiom{S}
    exists{Bool, S}(variable{Bool}(B), equals{Bool, S}(variable{Bool}(B), false()))
  axiom{S}
    exists{Bool, S}(variable{Bool}(B), equals{Bool, S}(variable{Bool}(B), notBool(C:Bool)))
  axiom{S}
    exists{Bool, S}(variable{Bool}(B), equals{Bool, S}(variable{Bool}(B), andBool(C1:Bool, C2:Bool)))
  axiom
    or{Bool}(true(), false())
  axiom
    not{Bool}(and{Bool}(true(), false()))
  axiom{S}
    equals{Bool, S}(notBool(variable{Bool}(B)), not{Bool}(variable{Bool}(B)))
  axiom{S}
    equals{Bool, S}(andBool(variable{Bool}(B), true()), variable{Bool}(B))
  axiom{S}
    equals{Bool, S}(andBool(variable{Bool}(B), false()), false()))
]]


.

quit

-------------------------------
---- Testing lifting [[_]] ----
-------------------------------

reduce
  [[  
     not{List{S}}(and{List{S}}(
      nil{S}(), 
      exists{S, List{S}}(variable{S}(X), exists{List{S}, List{S}}(variable{List{S}}(L), 
        cons{S}(variable{S}(X), variable{List{S}}(L)))))) ]]
.

quit


------------------------------
---- imp.kore starts here ----
------------------------------


reduce


  alias{S} implies{S}(P:KPattern, Q:KPattern) 
        := or{S}(not{S}(P:KPattern), Q:KPattern)
  alias{S} iff{S}(P:KPattern, Q:KPattern) 
        := and{S}(implies{S}(P:KPattern, Q:KPattern), 
                   implies{S}(Q:KPattern, P:KPattern))
  alias{S} forall{S1,S2}(variable{S}(X)1,P:KPattern) 
        := not{S2}(exists{S1,S2}(variable{S}(X)1,not{S2}(P:KPattern)))

  symbol
    ceil{S1,S2}(S1) : S2

  axiom{S1,S2}  
    ceil{S1,S2}(variable{S}(X)1)

  alias{S1,S2}
    floor{S1,S2}(P:KPattern) 
    := not{S2}(ceil{S1,S2}(not{S1}(P:KPattern)))

  alias{S1,S2}
    equals{S1,S2}(P:KPattern,Q:KPattern) 
    := floor{S1,S2}(iff{S1,S2}(P:KPattern,Q:KPattern)) 






  
  
  axiom{S}
    exists{Nat, S}(X:Nat, equals{Nat, S}(X:Nat, zero()))
  axiom{S}
    exists{Nat, S}(X:Nat, equals{Nat, S}(X:Nat, succ(Y:Nat)))
  axiom{S}
    exists{Nat, S}(X:Nat, equals{Nat, S}(X:Nat, plus(Y:Nat, Z:Nat)))
  axiom{S}
    exists{Bool, S}(variable{Bool}(B), equals{Bool, S}(variable{Bool}(B), gte(Y:Nat, Z:Nat)))
  
  axiom  
    or{Nat}(zero(), exists{Nat, Nat}(X:Nat, succ(X:Nat)))
  axiom
    not{Nat}(and{Nat}(zero(), exists{Nat, Nat}(X:Nat, succ(X:Nat))))
  
  axiom{S}
    equals{Nat, S}(plus(X:Nat, zero()), zero())
  axiom{S}
    equals{Nat, S}(plus(X:Nat, succ(Y:Nat)), succ(plus(X:Nat, Y:Nat)))


  


  sort   Ctxt{S1, S2}
  symbol gamma0{S1, S2}(S1, S2)            : Ctxt{S1, S2}
  symbol ctxtapp{S1, S2}(Ctxt{S1, S2}, S1) : S2
  
  alias  gamma{S1,S2}(HOLE:S1, P:KPattern) 
     :=  exists{S1, Ctxt{S1, S2}}(HOLE:S1, gamma0{S1, S2}(HOLE:S1, P:KPattern))

.

quit
  

  sort   AExp
  symbol NatToAExp(Nat)       : AExp
  symbol IdToAExp(Nat)        : AExp
  symbol plusAExp(AExp, AExp) : AExp

  axiom{S, R}
  implies{R}(
  equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S, AExp}),  
  equals{AExp, R}(plusAExp(ctxtapp{S,AExp}(C:KPattern, variable{S}(X)), E:AExp),
                   ctxtapp{S,AExp}(
                     exists{S,AExp}(
                       HOLE:S, 
                       gamma0{S,AExp}(
                         HOLE:S, 
                         plusAExp(ctxtapp{S,AExp}(C:KPattern, HOLE:S), E:AExp))), 
                     variable{S}(X))))

  axiom{S, R}
  implies{R}(
  equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S,AExp}),
  equals{AExp, R}(ctxtapp{S,AExp}(
                     gamma{S,AExp}(
                       HOLE:S, 
                       plusAExp(ctxtapp{S,AExp}(C:KPattern, HOLE:S), E:AExp)), 
                     variable{S}(X))),
                   plusAExp(ctxtapp{S,AExp}(C:KPattern, variable{S}(X)), E:AExp))
  
  axiom{S, R}
  implies{R}(
  equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S, BExp}),
  equals{Stmt, R}(ite(ctxtapp{S, BExp}(C:KPattern, variable{S}(X)), S1:Stmt, S2:Stmt),
                   ctxtapp{S, Stmt}(
                     exists{S, Stmt}(
                       HOLE:S,
                       gamma0{S, Stmt}(
                         HOLE:S,
                         ite(ctxtapp{S, BExp}(C:KPattern, HOLE:S),
                             S1:Stmt, S2:Stmt))), 
                     variable{S}(X))))
  sort KString

  sort KSort
  sort KSortList
  sort KSymbol
  sort KSymbolList
  sort KVariable
  sort KPattern
  sort KPatternList

  sort KSortSentence
  sort KSortSentenceList
  sort KSymbolSentence
  sort KSymbolSentenceList
  sort KAxiomSentence
  sort KAxiomSentenceList

  sort KModule 
  sort KModuleList

  symbol Ksort(KString, KSortList)        : KSort

  symbol KnilKSortList                    : KSortList
  symbol KconsKSortList(KSort, KSortList) : KSortList 

  symbol Ksymbolid(KString, KSortList)                 : KSymbol
  symbol Ksymbol(KString, KSortList, KSortList, KSort) : KSymbol 

  symbol Kvariable(KString, KSort)    : KVariable


.

quit

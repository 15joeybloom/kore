---- The IMP theory in Kore ----

---- Some preludes ... Just ignore ---
in kore
in tokens
fmod IMP is
  including TOKENS .
endfm

------------------------------
---- imp.kore starts here ----
------------------------------

--- set print mixfix off .


parse

module PL-SYNTACTIC-SUGAR
  
  alias  \or{S}(P:KPattern, Q:KPattern)
      := \not{S}(\and{S}(\not{S}(P:KPattern), \not{S}(Q:KPattern)))
  alias  \implies{S}(P:KPattern, Q:KPattern) 
      := \or{S}(\not{S}(P:KPattern), Q:KPattern)
  alias  \iff{S}(P:KPattern, Q:KPattern) 
      := \and{S}(\implies{S}(P:KPattern, Q:KPattern), 
                 \implies{S}(Q:KPattern, P:KPattern))
  alias  \forall{S1,S2}(X:S1,P:KPattern) 
      := \not{S2}(\exists{S1,S2}(X:S1,\not{S2}(P:KPattern)))
  
endmodule

module DEFINEDNESS
  
  symbol ceil{S1,S2}(S1) : S2
  axiom{S1, S2}  
    ceil{S1,S2}(X:S1)
  alias  floor{S1,S2}(P:KPattern) 
      := \not{S2}(ceil{S1,S2}(\not{S1}(P:KPattern)))
  alias  \equals{S1,S2}(P:KPattern,Q:KPattern) 
      := floor{S1,S2}(\iff{S1,S2}(P:KPattern,Q:KPattern)) 
endmodule


module BOOL

  sort   Bool
  symbol true                : Bool
  symbol false               : Bool
  symbol notBool(Bool)       : Bool
  symbol andBool(Bool, Bool) : Bool
  
  axiom{S}  
    \exists{Bool, S}(B:Bool, \equals{Bool, S}(B:Bool, true))
  axiom{S}
    \exists{Bool, S}(B:Bool, \equals{Bool, S}(B:Bool, false))
  axiom{S}
    \exists{Bool, S}(B:Bool, \equals{Bool, S}(B:Bool, notBool(C:Bool)))
  axiom{S}
    \exists{Bool, S}(B:Bool, \equals{Bool, S}(B:Bool, andBool(C1:Bool, C2:Bool)))
  axiom
    \or{Bool}(true, false)
  axiom
    \not{Bool}(\and{Bool}(true, false))
  axiom{S}
    \equals{Bool, S}(notBool(B:Bool), \not{Bool}(B:Bool))
  axiom{S}
    \equals{Bool, S}(andBool(B:Bool, true), B:Bool)
  axiom{S}
    \equals{Bool, S}(andBool(B:Bool, false), false)

endmodule

module PRESBURGER

  sort   Nat
  symbol zero           : Nat
  symbol succ(Nat)      : Nat
  symbol plus(Nat, Nat) : Nat
  symbol gte(Nat, Nat)  : Bool 
  
  
  axiom{S}
    \exists{Nat, S}(X:Nat, \equals{Nat, S}(X:Nat, zero))
  axiom{S}
    \exists{Nat, S}(X:Nat, \equals{Nat, S}(X:Nat, succ(Y:Nat)))
  axiom{S}
    \exists{Nat, S}(X:Nat, \equals{Nat, S}(X:Nat, plus(Y:Nat, Z:Nat)))
  axiom{S}
    \exists{Bool, S}(B:Bool, \equals{Bool, S}(B:Bool, gte(Y:Nat, Z:Nat)))
  
  axiom  
    \or{Nat}(zero, \exists{Nat, Nat}(X:Nat, succ(X:Nat)))
  axiom
    \not{Nat}(\and{Nat}(zero, \exists{Nat, Nat}(X:Nat, succ(X:Nat))))
  
  axiom{S}
    \equals{Nat, S}(plus(X:Nat, zero), zero)
  axiom{S}
    \equals{Nat, S}(plus(X:Nat, succ(Y:Nat)), succ(plus(X:Nat, Y:Nat)))

endmodule


module LIST

  sort   List{S}
  symbol nil{S}              : List{S}
  symbol cons{S}(S, List{S}) : List{S}
  
  axiom{S, R}
    \exists{List{S}, R}(L:List{S}, 
    \equals{List{S}, R}(L:List{S}, nil{S}))
  axiom{S, R}
    \exists{List{S}, R}(L:List{S}, 
    \equals{List{S}, R}(L:List{S}, cons{S}(X:S, L0:List{S})))
  
  axiom{S}
    \or{List{S}}(nil{S}, 
                 \exists{S, List{S}}(X:S, \exists{List{S}, List{S}}(L:List{S}, 
                    cons{S}(X:S, L:List{S}))))
  axiom{S}
    \not{List{S}}(\and{List{S}}(
      nil{S}, 
      \exists{S, List{S}}(X:S, \exists{List{S}, List{S}}(L:List{S}, 
        cons{S}(X:S, L:List{S})))))
  
endmodule

module CONTEXT

  sort   Ctxt{S1, S2}
  symbol gamma0{S1, S2}(S1, S2)            : Ctxt{S1, S2}
  symbol ctxtapp{S1, S2}(Ctxt{S1, S2}, S1) : S2
  
  alias  gamma{S1,S2}(HOLE:S1, P:KPattern) 
     :=  \exists{S1, Ctxt{S1, S2}}(HOLE:S1, gamma0{S1, S2}(HOLE:S1, P:KPattern))
  
endmodule

module AEXP

  import ID
  sort   AExp
  symbol NatToAExp(Nat)       : AExp
  symbol IdToAExp(Nat)        : AExp
  symbol plusAExp(AExp, AExp) : AExp

  axiom{S, R}
  \implies{R}(
  \equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S, AExp}),  
  \equals{AExp, R}(plusAExp(ctxtapp{S,AExp}(C:KPattern, X:S), E:AExp),
                   ctxtapp{S,AExp}(
                     gamma{S,AExp}(
                       HOLE:S, 
                       plusAExp(ctxtapp{S,AExp}(C:KPattern, HOLE:S), E:AExp)), 
                     X:S)))

  axiom{S, R}
  \implies{R}(
  \equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S,AExp}),
  \equals{AExp, R}(ctxtapp{S,AExp}(
                     gamma{S,AExp}(
                       HOLE:S, 
                       plusAExp(ctxtapp{S,AExp}(C:KPattern, HOLE:S), E:AExp)), 
                     X:S)),
                   plusAExp(ctxtapp{S,AExp}(C:KPattern, X:S), E:AExp))
  
  axiom{S, R}
  \implies{R}(
  \equals{KSort, R}(KgetSort(C:KPattern), Ctxt{S, BExp}),
  \equals{Stmt, R}(ite(ctxtapp{S, BExp}(C:KPattern, X:S), S1:Stmt, S2:Stmt),
                   ctxtapp{S, Stmt}(
                     gamma{S, Stmt}(
                       HOLE:S,
                       ite(ctxtapp{S, BExp}(C:KPattern, HOLE:S),
                           S1:Stmt, S2:Stmt)), X:S)))
endmodule

module K

  sort KString

  sort KSort
  sort KSortList
  sort KSymbol
  sort KSymbolList
  sort KVariable
  sort KPattern
  sort KPatternList

  sort KSortSentence
  sort KSortSentenceList
  sort KSymbolSentence
  sort KSymbolSentenceList
  sort KAxiomSentence
  sort KAxiomSentenceList

  sort KModule 
  sort KModuleList

  symbol Ksort(KString)                   : KSort
  symbol Kparsort(KString, KSortList)     : KSort

  symbol KnilKSortList                    : KSortList
  symbol KconsKSortList(KSort, KSortList) : KSortList 

  symbol Ksymbol(KString, KSortList, KSort)               : KSymbol 
  symbol Kparsymbol(KSortList, KString, KSortList, KSort) : KSymbol 

  symbol Kvariable(KString, KSort)    : KPattern

endmodule

.

quit
